
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to Numerical Methods for Variational Problems" href="index.html" />
    <link rel="next" title="Comparison of finite elements and finite differences" href="._book011.html" />
    <link rel="prev" title="Function approximation by finite elements" href="._book009.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book011.html" title="Comparison of finite elements and finite differences"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book009.html" title="Function approximation by finite elements"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="implementation-3">
<span id="fem-approx-fe-impl"></span><h1>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h1>
<p>Based on the experience from the previous example, it makes sense to
write some code to automate the analytical integration process for any
choice of finite element basis functions. In addition, we can automate
the assembly process and the solution of the linear system.  Another
advantage is that the code for these purposes document all details of
all steps in the finite element computational machinery.  The complete
code can be found in the module file <a class="reference external" href="http://tinyurl.com/znpudbt/fe_approx1D.py">fe_approx1D.py</a>.</p>
<div class="section" id="integration">
<span id="fem-approx-fe-impl-intg"></span><h2>Integration<a class="headerlink" href="#integration" title="Permalink to this headline">¶</a></h2>
<p>First we need a Python function for
defining <span class="math">\({\tilde{\varphi}}_r(X)\)</span> in terms of a Lagrange polynomial
of degree <code class="docutils literal"><span class="pre">d</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">point_distribution</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return all local basis function phi as functions of the</span>
<span class="sd">    local point X in a 1D element with d+1 nodes.</span>
<span class="sd">    If symbolic=True, return symbolic expressions, else</span>
<span class="sd">    return Python functions of X.</span>
<span class="sd">    point_distribution can be &#39;uniform&#39; or &#39;Chebyshev&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phi_sym</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">point_distribution</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="c1"># Compute symbolic nodes</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>  <span class="c1"># node spacing</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">point_distribution</span> <span class="o">==</span> <span class="s1">&#39;Chebyshev&#39;</span><span class="p">:</span>
            <span class="c1"># Just numeric nodes</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">Chebyshev_nodes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">phi_sym</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lagrange_polynomial</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># Transform to Python functions</span>
    <span class="n">phi_num</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">X</span><span class="p">],</span> <span class="n">phi_sym</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">phi_sym</span> <span class="k">if</span> <span class="n">symbolic</span> <span class="k">else</span> <span class="n">phi_num</span>

<span class="k">def</span> <span class="nf">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">*=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</div>
<p>Observe how we construct the <code class="docutils literal"><span class="pre">phi_sym</span></code> list to be
symbolic expressions for <span class="math">\({\tilde{\varphi}}_r(X)\)</span> with <code class="docutils literal"><span class="pre">X</span></code> as a
<code class="docutils literal"><span class="pre">Symbol</span></code> object from <code class="docutils literal"><span class="pre">sympy</span></code>. Also note that the
<code class="docutils literal"><span class="pre">Lagrange_polynomial</span></code> function (here simply copied
from the section <a class="reference internal" href="._book005.html#fem-approx-global-fourier"><span class="std std-ref">Fourier series</span></a>)
works with both symbolic and numeric variables.</p>
<p>Now we can write the function that computes the element matrix
with a list of symbolic expressions for <span class="math">\({\varphi}_r\)</span>
(<code class="docutils literal"><span class="pre">phi</span> <span class="pre">=</span> <span class="pre">basis(d,</span> <span class="pre">symbolic=True)</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">A_e</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>  <span class="c1"># dx/dX</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A_e</span>
</pre></div>
</div>
<p>In the symbolic case (<code class="docutils literal"><span class="pre">symbolic</span></code> is <code class="docutils literal"><span class="pre">True</span></code>),
we introduce the element length as a symbol
<code class="docutils literal"><span class="pre">h</span></code> in the computations. Otherwise, the real numerical value
of the element interval <code class="docutils literal"><span class="pre">Omega_e</span></code>
is used and the final matrix elements are numbers,
not symbols.
This functionality can be demonstrated:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">fe_approx1D</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">phi</span>
<span class="p">[</span><span class="o">-</span><span class="n">X</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">[</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="p">[</span><span class="mf">0.0333333333333333</span><span class="p">,</span> <span class="mf">0.0166666666666667</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.0166666666666667</span><span class="p">,</span> <span class="mf">0.0333333333333333</span><span class="p">]</span>
</pre></div>
</div>
<p>The computation of the element vector is done by a similar
procedure:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">element_vector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">b_e</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># Make f a function of X</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span>  <span class="c1"># mapping</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># substitute mapping formula for x</span>
    <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>  <span class="c1"># dx/dX</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">b_e</span>
</pre></div>
</div>
<p>Here we need to replace the symbol <code class="docutils literal"><span class="pre">x</span></code> in the expression for <code class="docutils literal"><span class="pre">f</span></code>
by the mapping formula such that <code class="docutils literal"><span class="pre">f</span></code> can be integrated
in terms of <span class="math">\(X\)</span>, cf. the formula
<span class="math">\(\tilde b^{(e)}_{r} = \int_{-1}^1 f(x(X)){\tilde{\varphi}}_r(X)\frac{h}{2}{\, \mathrm{d}X}\)</span>.</p>
<p>The integration in the element matrix function involves only products
of polynomials, which <code class="docutils literal"><span class="pre">sympy</span></code> can easily deal with, but for the
right-hand side <code class="docutils literal"><span class="pre">sympy</span></code> may face difficulties with certain types of
expressions <code class="docutils literal"><span class="pre">f</span></code>. The result of the integral is then an <code class="docutils literal"><span class="pre">Integral</span></code>
object and not a number or expression
as when symbolic integration is successful.
It may therefore be wise to introduce a fall back on numerical
integration. The symbolic integration can also spend considerable time
before reaching an unsuccessful conclusion, so we may also introduce a parameter
<code class="docutils literal"><span class="pre">symbolic</span></code> to turn symbolic integration on and off:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">element_vector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Ensure h is numerical</span>
            <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">X</span><span class="p">],</span> <span class="n">f</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Numerical integration requires that the symbolic
integrand is converted
to a plain Python function (<code class="docutils literal"><span class="pre">integrand</span></code>) and that
the element length <code class="docutils literal"><span class="pre">h</span></code> is a real number.</p>
</div>
<div class="section" id="linear-system-assembly-and-solution">
<span id="fem-approx-fe-impl-linsys"></span><h2>Linear system assembly and solution<a class="headerlink" href="#linear-system-assembly-and-solution" title="Permalink to this headline">¶</a></h2>
<p>The complete algorithm
for computing and assembling the elementwise contributions
takes the following form</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">N_n</span><span class="p">,</span> <span class="n">N_e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_n</span><span class="p">,</span> <span class="n">N_n</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>    <span class="c1"># note: (N_n, 1) matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_n</span><span class="p">,</span> <span class="n">N_n</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_e</span><span class="p">):</span>
        <span class="n">Omega_e</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>

        <span class="n">A_e</span> <span class="o">=</span> <span class="n">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="p">)</span>
        <span class="n">b_e</span> <span class="o">=</span> <span class="n">element_vector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">])):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">],</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">s</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
            <span class="n">b</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">nodes</span></code> and <code class="docutils literal"><span class="pre">elements</span></code> variables represent the finite
element mesh as explained earlier.</p>
<p>Given the coefficient matrix <code class="docutils literal"><span class="pre">A</span></code> and the right-hand side <code class="docutils literal"><span class="pre">b</span></code>,
we can compute the coefficients <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span> in the expansion
<span class="math">\(u(x)=\sum_jc_j{\varphi}_j\)</span> as the solution vector <code class="docutils literal"><span class="pre">c</span></code> of the linear
system:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are <code class="docutils literal"><span class="pre">sympy</span></code> arrays,
the solution procedure implied by <code class="docutils literal"><span class="pre">A.LUsolve</span></code> is symbolic.
Otherwise, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are <code class="docutils literal"><span class="pre">numpy</span></code> arrays and a standard
numerical solver is called.
The symbolic version is suited for small problems only
(small <span class="math">\(N\)</span> values) since the calculation time becomes prohibitively large
otherwise. Normally, the symbolic <em>integration</em> will be more time
consuming in small problems than the symbolic <em>solution</em> of the linear system.</p>
</div>
<div class="section" id="example-on-computing-symbolic-approximations">
<span id="fem-approx-fe-impl-ex1-symbolic"></span><h2>Example on computing symbolic approximations<a class="headerlink" href="#example-on-computing-symbolic-approximations" title="Permalink to this headline">¶</a></h2>
<p>We can exemplify the use of <code class="docutils literal"><span class="pre">assemble</span></code> on the computational
case from the section <a class="reference internal" href="._book009.html#fem-approx-global-linearsystem"><span class="std std-ref">Calculating the linear system</span></a> with
two P1 elements (linear basis functions) on the domain <span class="math">\(\Omega=[0,1]\)</span>.
Let us first work with a symbolic element length:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">h</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;h x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">elements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="p">[</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[</span>     <span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">6</span> <span class="o">-</span> <span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">12</span><span class="p">]</span>
<span class="p">[</span>      <span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">17</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">12</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="p">[</span>                           <span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="o">*</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">12</span> <span class="o">-</span> <span class="mi">35</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">72</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">h</span><span class="p">)]</span>
<span class="p">[</span>  <span class="mi">7</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">7</span> <span class="o">-</span> <span class="mi">23</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">21</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="section" id="using-interpolation-instead-of-least-squares">
<span id="fem-approx-fe-impl-ex1-collocation"></span><h2>Using interpolation instead of least squares<a class="headerlink" href="#using-interpolation-instead-of-least-squares" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to the least squares formulation,
we may compute the <code class="docutils literal"><span class="pre">c</span></code> vector based on
the interpolation method from the section <a class="reference internal" href="._book006.html#fem-approx-global-interp"><span class="std std-ref">The interpolation (or collocation) principle</span></a>,
using finite element basis functions.
Choosing the nodes as interpolation points, the method can be written as</p>
<div class="math">
\[u(x_{i}) = \sum_{j\in{\mathcal{I}_s}} c_j{\varphi}_j(x_{i}) = f(x_{i}),\quad
i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The coefficient matrix <span class="math">\(A_{i,j}={\varphi}_j(x_{i})\)</span> becomes
the identity matrix because basis function number <span class="math">\(j\)</span> vanishes
at all nodes, except node <span class="math">\(i\)</span>: <span class="math">\({\varphi}_j(x_{i})=\delta_{ij}\)</span>.
Therefore, <span class="math">\(c_i = f(x_{i})\)</span>.</p>
<p>The associated <code class="docutils literal"><span class="pre">sympy</span></code> calculations are</p>
<div class="highlight-ipy"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span> <span class="k">for</span> <span class="n">xc</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
<p>These expressions are much simpler than those based on least squares
or projection in combination with finite element basis functions.
However, which of the two methods that is most appropriate for a given
task is problem-dependent, so we need both methods in our toolbox.</p>
</div>
<div class="section" id="example-on-computing-numerical-approximations">
<span id="fem-approx-fe-impl-ex1-numeric"></span><h2>Example on computing numerical approximations<a class="headerlink" href="#example-on-computing-numerical-approximations" title="Permalink to this headline">¶</a></h2>
<p>The numerical computations corresponding to the
symbolic ones in the section <a class="reference internal" href="#fem-approx-fe-impl-ex1-symbolic"><span class="std std-ref">Example on computing symbolic approximations</span></a>
(still done by <code class="docutils literal"><span class="pre">sympy</span></code> and the <code class="docutils literal"><span class="pre">assemble</span></code> function) go as follows:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">elements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="p">[</span> <span class="mf">0.166666666666667</span><span class="p">,</span> <span class="mf">0.0833333333333333</span><span class="p">,</span>                  <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.0833333333333333</span><span class="p">,</span>  <span class="mf">0.333333333333333</span><span class="p">,</span> <span class="mf">0.0833333333333333</span><span class="p">]</span>
<span class="p">[</span>                 <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0833333333333333</span><span class="p">,</span>  <span class="mf">0.166666666666667</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[</span>          <span class="mf">0.03125</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.104166666666667</span><span class="p">]</span>
<span class="p">[</span>          <span class="mf">0.03125</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="p">[</span><span class="mf">0.0416666666666666</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">0.291666666666667</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.0416666666666666</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">fe_approx1D</span></code> module contains functions for generating the
<code class="docutils literal"><span class="pre">nodes</span></code> and <code class="docutils literal"><span class="pre">elements</span></code> lists for equal-sized elements with
any number of nodes per element. The coordinates in <code class="docutils literal"><span class="pre">nodes</span></code>
can be expressed either through the element length symbol <code class="docutils literal"><span class="pre">h</span></code>
(<code class="docutils literal"><span class="pre">symbolic=True</span></code>) or by real numbers (<code class="docutils literal"><span class="pre">symbolic=False</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">mesh_uniform</span><span class="p">(</span><span class="n">N_e</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also a function</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">approximate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_e</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;tmp.pdf&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>which computes a mesh with <code class="docutils literal"><span class="pre">N_e</span></code> elements, basis functions of
degree <code class="docutils literal"><span class="pre">d</span></code>, and approximates a given symbolic expression
<code class="docutils literal"><span class="pre">f</span></code> by a finite element expansion <span class="math">\(u(x) = \sum_jc_j{\varphi}_j(x)\)</span>.
When <code class="docutils literal"><span class="pre">symbolic</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, <span class="math">\(u(x) = \sum_jc_j{\varphi}_j(x)\)</span>
can be computed at a (large)
number of points and plotted together with <span class="math">\(f(x)\)</span>. The construction
of the pointwise function <span class="math">\(u\)</span> from the solution vector <code class="docutils literal"><span class="pre">c</span></code> is done
elementwise by evaluating <span class="math">\(\sum_rc_r{\tilde{\varphi}}_r(X)\)</span> at a (large)
number of points in each element in the local coordinate system,
and the discrete <span class="math">\((x,u)\)</span> values on
each element are stored in separate arrays that are finally
concatenated to form a global array for <span class="math">\(x\)</span> and for <span class="math">\(u\)</span>.
The details are found in the <code class="docutils literal"><span class="pre">u_glob</span></code> function in
<code class="docutils literal"><span class="pre">fe_approx1D.py</span></code>.</p>
</div>
<div class="section" id="the-structure-of-the-coefficient-matrix">
<span id="fem-approx-fe-a-structure"></span><h2>The structure of the coefficient matrix<a class="headerlink" href="#the-structure-of-the-coefficient-matrix" title="Permalink to this headline">¶</a></h2>
<p>Let us first see how the global matrix looks like if we assemble
symbolic element matrices, expressed in terms of <code class="docutils literal"><span class="pre">h</span></code>, from
several elements:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">N_e</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span> <span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 8 linear elements on [0,1]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">mesh_symbolic</span><span class="p">(</span><span class="n">N_e</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="p">[</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span>  <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">h</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>The reader is encouraged to assemble the element matrices by hand and verify
this result, as this exercise will give a hands-on understanding of
what the assembly is about. In general we have a coefficient matrix that is
tridiagonal:</p>
<div class="math" id="eq-fem-approx-fe-a-fullmat">
\[\begin{split}\tag{102}
A = \frac{h}{6}
    \left(
    \begin{array}{cccccccccc}
    2 &amp; 1 &amp; 0
    &amp;\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0 \\
    1 &amp; 4 &amp; 1 &amp; \ddots &amp;   &amp; &amp;  &amp; &amp;  \vdots \\
    0 &amp; 1 &amp; 4 &amp; 1 &amp;
    \ddots &amp; &amp;  &amp;  &amp; \vdots \\
    \vdots &amp; \ddots &amp;  &amp; \ddots &amp; \ddots &amp; 0 &amp;  &amp; &amp; \vdots \\
    \vdots &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \vdots \\
    \vdots &amp; &amp;  &amp; 0 &amp; 1 &amp; 4 &amp; 1 &amp; \ddots &amp; \vdots \\
    \vdots &amp; &amp; &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp;\ddots  &amp; 0 \\
    \vdots &amp; &amp; &amp; &amp;  &amp;\ddots  &amp; 1  &amp; 4  &amp; 1 \\
    0 &amp;\cdots &amp; \cdots &amp;\cdots &amp; \cdots &amp; \cdots  &amp; 0 &amp; 1 &amp; 2
    \end{array}
    \right)\end{split}\]</div>
<p>The structure of the right-hand side is more difficult to reveal since
it involves an assembly of elementwise integrals of
<span class="math">\(f(x(X)){\tilde{\varphi}}_r(X)h/2\)</span>, which obviously depend on the
particular choice of <span class="math">\(f(x)\)</span>.
Numerical integration can give some insight into the nature of
the right-hand side. For this purpose it
is easier to look at the integration in <span class="math">\(x\)</span> coordinates, which
gives the general formula <a class="reference internal" href="._book009.html#eq-fem-approx-fe-bi-formula1"><span class="std std-ref">(79)</span></a>.
For equal-sized elements of length <span class="math">\(h\)</span>, we can apply the
Trapezoidal rule at the global node points to arrive at</p>
<div class="math">
\[b_i = h\left( \frac{1}{2} {\varphi}_i(x_{0})f(x_{0}) +
\frac{1}{2} {\varphi}_i(x_{N})f(x_{N}) + \sum_{j=1}^{N-1}
{\varphi}_i(x_{j})f(x_{j})\right),\]</div>
<p>which leads to</p>
<div class="math" id="eq-auto42">
\[\begin{split}\tag{103}
b_i =
    \left\lbrace\begin{array}{ll}
    \frac{1}{2} hf(x_i),&amp; i=0\hbox{ or }i=N,\\
    h f(x_i), &amp; 1 \leq i \leq N-1
    \end{array}\right.\end{split}\]</div>
<p>The reason for this simple formula is just that <span class="math">\({\varphi}_i\)</span> is either
0 or 1 at the nodes and 0 at all but one of them.</p>
<p>Going to P2 elements (<code class="docutils literal"><span class="pre">d=2</span></code>) leads
to the element matrix</p>
<div class="math" id="eq-auto43">
\[\begin{split}\tag{104}
A^{(e)} = \frac{h}{30}
    \left(\begin{array}{ccc}
    4 &amp; 2 &amp; -1\\
    2 &amp; 16 &amp; 2\\
    -1 &amp; 2 &amp; 4
    \end{array}\right)\end{split}\]</div>
<p>and the following global matrix, assembled here from four elements:</p>
<div class="math" id="eq-auto44">
\[\begin{split}\tag{105}
A = \frac{h}{30}
    \left(
    \begin{array}{ccccccccc}
    4 &amp; 2 &amp; - 1 &amp; 0
      &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
      2 &amp; 16 &amp; 2
      &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\- 1 &amp; 2 &amp;
      8 &amp; 2 &amp; - 1 &amp; 0 &amp; 0 &amp; 0 &amp;
      0\\0 &amp; 0 &amp; 2 &amp; 16 &amp; 2 &amp; 0 &amp; 0
      &amp; 0 &amp; 0\\0 &amp; 0 &amp; - 1 &amp; 2 &amp; 8
      &amp; 2 &amp; - 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0 &amp;
      2 &amp; 16 &amp; 2 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 0
      &amp; 0 &amp; - 1 &amp; 2 &amp; 8 &amp;
      2 &amp; - 1\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp;
      2 &amp; 16 &amp; 2\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
      &amp; 0 &amp; - 1 &amp; 2 &amp; 4
    \end{array}
    \right)\end{split}\]</div>
<p>In general, for <span class="math">\(i\)</span> odd we have the nonzeroes</p>
<div class="math">
\[A_{i,i-2} = -1,\quad A_{i-1,i}=2,\quad A_{i,i} = 8,\quad A_{i+1,i}=2,
\quad A_{i+2,i}=-1,\]</div>
<p>multiplied by <span class="math">\(h/30\)</span>, and for <span class="math">\(i\)</span> even we have the nonzeros</p>
<div class="math">
\[A_{i-1,i}=2,\quad A_{i,i} = 16,\quad A_{i+1,i}=2,\]</div>
<p>multiplied by <span class="math">\(h/30\)</span>. The rows with odd numbers correspond to
nodes at the element boundaries and get contributions from two
neighboring elements in the assembly process,
while the even numbered rows correspond to
internal nodes in the elements where only one element contributes
to the values in the global matrix.</p>
</div>
<div class="section" id="applications">
<span id="fem-approx-fe-impl-ex2"></span><h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<p>With the aid of the <code class="docutils literal"><span class="pre">approximate</span></code> function in the <code class="docutils literal"><span class="pre">fe_approx1D</span></code>
module we can easily investigate the quality of various finite element
approximations to some given functions. Figure <a class="reference internal" href="#fem-approx-fe-x9-sin"><span class="std std-ref">Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right)</span></a>
shows how linear and quadratic elements approximate the polynomial
<span class="math">\(f(x)=x(1-x)^8\)</span> on <span class="math">\(\Omega =[0,1]\)</span>, using equal-sized elements.
The results arise from the program</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="kn">from</span> <span class="nn">fe_approx1D</span> <span class="kn">import</span> <span class="n">approximate</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_e</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">N_e</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_e</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">N_e</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The quadratic functions are seen to be better than the linear ones for the same
value of <span class="math">\(N\)</span>, as we increase <span class="math">\(N\)</span>. This observation has some generality:
higher degree is not necessarily better on a coarse mesh, but it is as
we refine the mesh and the function is properly resolved.</p>
<div class="figure" id="id1">
<span id="fem-approx-fe-x9-sin"></span><a class="reference internal image-reference" href="_images/fe_p1_p2_x9_248e.png"><img alt="_images/fe_p1_p2_x9_248e.png" src="_images/fe_p1_p2_x9_248e.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right)</em></span></p>
</div>
</div>
<div class="section" id="sparse-matrix-storage-and-solution">
<span id="fem-approx-fe-impl-sparse"></span><h2>Sparse matrix storage and solution<a class="headerlink" href="#sparse-matrix-storage-and-solution" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Some of the examples in the preceding section took several minutes to
compute, even on small meshes consisting of up to eight elements.
The main explanation for slow computations is unsuccessful
symbolic integration: <code class="docutils literal"><span class="pre">sympy</span></code> may use a lot of energy on
integrals like <span class="math">\(\int f(x(X)){\tilde{\varphi}}_r(X)h/2 {\, \mathrm{d}x}\)</span> before
giving up, and the program then resorts to numerical integration.
Codes that can deal with a large number of basis functions and
accept flexible choices of <span class="math">\(f(x)\)</span> should compute all integrals
numerically and replace the matrix objects from <code class="docutils literal"><span class="pre">sympy</span></code> by
the far more efficient array objects from <code class="docutils literal"><span class="pre">numpy</span></code>.</p>
<p>There is also another (potential)
reason for slow code: the solution algorithm for
the linear system performs much more work than necessary. Most of the
matrix entries <span class="math">\(A_{i,j}\)</span> are zero, because <span class="math">\(({\varphi}_i,{\varphi}_j)=0\)</span>
unless <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are nodes in the same element. In 1D problems,
we do not need to store or compute with these zeros when solving the
linear system, but that requires solution methods adapted to the kind
of matrices produced by the finite element approximations.</p>
<p>A matrix whose majority of entries are zeros, is known as a <a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix">sparse</a> matrix.
Utilizing sparsity in software dramatically decreases
the storage demands and the CPU-time needed to compute the solution of
the linear system. This optimization is not very critical in 1D problems
where modern computers can afford computing with all the zeros in the
complete square matrix, but in 2D and especially in 3D, sparse
matrices are fundamental for feasible finite element computations.
One of the advantageous features of the finite element method is that it
produces very sparse matrices. The reason is that the basis functions
have local support such that the product of two basis functions, as
typically met in integrals, is mostly zero.</p>
<p>Using a numbering of nodes and elements from left to right over a 1D
domain, the assembled coefficient matrix has only a few diagonals
different from zero. More precisely, <span class="math">\(2d+1\)</span> diagonals around the main
diagonal are different from zero, where <span class="math">\(d\)</span> is the order of the polynomial. With a different numbering of global
nodes, say a random ordering, the diagonal structure is lost, but the
number of nonzero elements is unaltered. Figures
<a class="reference internal" href="#fem-approx-fe-sparsity-p1"><span class="std std-ref">Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements</span></a> and <a class="reference internal" href="#fem-approx-fe-sparsity-p3"><span class="std std-ref">Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements</span></a>
exemplify sparsity patterns.</p>
<div class="figure" id="id2">
<span id="fem-approx-fe-sparsity-p1"></span><a class="reference internal image-reference" href="_images/sparsity_pattern_1D_30.png"><img alt="_images/sparsity_pattern_1D_30.png" src="_images/sparsity_pattern_1D_30.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements</em></span></p>
</div>
<div class="figure" id="id3">
<span id="fem-approx-fe-sparsity-p3"></span><a class="reference internal image-reference" href="_images/sparsity_pattern_1DP3_30.png"><img alt="_images/sparsity_pattern_1DP3_30.png" src="_images/sparsity_pattern_1DP3_30.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements</em></span></p>
</div>
<p>The <code class="docutils literal"><span class="pre">scipy.sparse</span></code> library supports creation of sparse matrices
and linear system solution.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">scipy.sparse.diags</span></code> for matrix defined via diagonals</li>
<li><code class="docutils literal"><span class="pre">scipy.sparse.dok_matrix</span></code> for matrix incrementally defined via index pairs <span class="math">\((i,j)\)</span></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal"><span class="pre">dok_matrix</span></code> object is most convenient for finite element computations.
This sparse matrix format is called DOK, which stands for Dictionary Of Keys:
the implementation is basically a dictionary (hash) with the
entry indices <code class="docutils literal"><span class="pre">(i,j)</span></code> as keys.</p>
<p>Rather than declaring <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">np.zeros((N_n,</span> <span class="pre">N_n))</span></code>, a DOK sparse
matrix is created by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">((</span><span class="n">N_n</span><span class="p">,</span> <span class="n">N_n</span><span class="p">))</span>
</pre></div>
</div>
<p>When there is any need to set or add some matrix entry <code class="docutils literal"><span class="pre">i,j</span></code>, just do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>  <span class="o">=</span> <span class="n">entry</span>
<span class="c1"># or</span>
<span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">entry</span>
</pre></div>
</div>
<p>The indexing creates the matrix entry on the fly, and
only the nonzero entries in the matrix will be stored.</p>
<p>To solve a system with right-hand side <code class="docutils literal"><span class="pre">b</span></code> (one-dimensional <code class="docutils literal"><span class="pre">numpy</span></code>
array) with a sparse coefficient matrix <code class="docutils literal"><span class="pre">A</span></code>, we must use some kind of
a sparse linear system solver. The safest choice is a method based on
sparse Gaussian elimination. One high-qualify package for
this purpose if <a class="reference external" href="https://en.wikipedia.org/wiki/UMFPACK">UMFPACK</a>.
It is interfaced from SciPy by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="n">use_umfpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The call <code class="docutils literal"><span class="pre">A.tocsr()</span></code> is not strictly needed (a warning is issued
otherwise), but ensures that the solution algorithm can efficiently
work with a copy of the sparse matrix in <em>Compressed Sparse Row</em>  (CSR) format.</p>
<p>An advantage of the <code class="docutils literal"><span class="pre">scipy.sparse.diags</span></code> matrix over the DOK format is
that the former allows vectorized assignment to the matrix.
Vectorization is possible for approximation problems when all elements
are of the same type. However, when solving differential equations,
vectorization may be more difficult in particular because of boundary conditions.
It also appears that the DOK sparse matrix format available in the <code class="docutils literal"><span class="pre">scipy.sparse</span></code> package is fast
enough even for big 1D problems on today&#8217;s laptops, so the need for
improving efficiency occurs only in 2D and 3D problems, but then the
complexity of the mesh favors the DOK format.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementation</a><ul>
<li><a class="reference internal" href="#integration">Integration</a></li>
<li><a class="reference internal" href="#linear-system-assembly-and-solution">Linear system assembly and solution</a></li>
<li><a class="reference internal" href="#example-on-computing-symbolic-approximations">Example on computing symbolic approximations</a></li>
<li><a class="reference internal" href="#using-interpolation-instead-of-least-squares">Using interpolation instead of least squares</a></li>
<li><a class="reference internal" href="#example-on-computing-numerical-approximations">Example on computing numerical approximations</a></li>
<li><a class="reference internal" href="#the-structure-of-the-coefficient-matrix">The structure of the coefficient matrix</a></li>
<li><a class="reference internal" href="#applications">Applications</a></li>
<li><a class="reference internal" href="#sparse-matrix-storage-and-solution">Sparse matrix storage and solution</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book009.html"
                        title="previous chapter">Function approximation by finite elements</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book011.html"
                        title="next chapter">Comparison of finite elements and finite differences</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book010.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book011.html" title="Comparison of finite elements and finite differences"
             >next</a> |</li>
        <li class="right" >
          <a href="._book009.html" title="Function approximation by finite elements"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Kent-Andre Mardal. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>