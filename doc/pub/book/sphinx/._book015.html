
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Variational formulations with global basis functions</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to Numerical Methods for Variational Problems" href="index.html" />
    <link rel="next" title="Abstract notation for variational formulations" href="._book016.html" />
    <link rel="prev" title="Finite elements in 2D and 3D" href="._book014.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book016.html" title="Abstract notation for variational formulations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book014.html" title="Finite elements in 2D and 3D"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="variational-formulations-with-global-basis-functions">
<span id="ch-varform-global"></span><h1>Variational formulations with global basis functions<a class="headerlink" href="#variational-formulations-with-global-basis-functions" title="Permalink to this headline">¶</a></h1>
<p>The finite element method is a very flexible approach for solving partial
differential equations. Its two most attractive features are the ease
of handling domains of complex shape in two and three dimensions and
the ease of using higher-degree polynomials in the approximations.
The latter feature typically leads to errors proportional to
<span class="math">\(h^{d+1}\)</span>, where <span class="math">\(h\)</span> is the element length and <span class="math">\(d\)</span> is the polynomial
degree. When the solution is sufficiently smooth, the ability to use
larger <span class="math">\(d\)</span> creates methods that are much more computationally efficient
than standard finite difference methods (and equally efficient finite
difference methods are technically much harder to construct).</p>
<p>However, before we attack finite element methods, with localized basis
functions, it can be easier from a pedagogical point of view to study
approximations by global functions because the mathematics in this
case gets simpler.</p>
<div class="section" id="basic-principles-for-approximating-differential-equations">
<span id="fem-deq-1d-principles"></span><h2>Basic principles for approximating differential equations<a class="headerlink" href="#basic-principles-for-approximating-differential-equations" title="Permalink to this headline">¶</a></h2>
<p>The finite element method is usually applied for discretization in
space, and therefore spatial problems will be our focus in the coming
sections.  Extensions to time-dependent problems usually employs
finite difference approximations in time.</p>
<p>The coming section addres at how global basis functions and the least
squares, Galerkin, and collocation principles can be used to solve
differential equations.</p>
<div class="section" id="differential-equation-models">
<span id="fem-deq-1d-models"></span><h3>Differential equation models<a class="headerlink" href="#differential-equation-models" title="Permalink to this headline">¶</a></h3>
<p>Let us consider an abstract differential equation for a function <span class="math">\(u(x)\)</span> of
one variable, written as</p>
<div class="math" id="eq-auto68">
\[\tag{136}
\mathcal{L}(u) = 0,\quad x\in\Omega{\thinspace .}\]</div>
<p>Here are a few examples on possible choices of <span class="math">\(\mathcal{L}(u)\)</span>, of
increasing complexity:</p>
<div class="math" id="eq-fem-deq-1d-l1">
\[\tag{137}
\mathcal{L}(u) = \frac{d^2u}{dx^2} - f(x),\]</div>
<div class="math" id="eq-fem-deq-1d-l2">
\[\tag{138}
\mathcal{L}(u) = \frac{d}{dx}\left({\alpha}(x)\frac{du}{dx}\right) + f(x),\]</div>
<div class="math" id="eq-fem-deq-1d-l3">
\[\tag{139}
\mathcal{L}(u) = \frac{d}{dx}\left({\alpha}(u)\frac{du}{dx}\right) - au + f(x),\]</div>
<div class="math" id="eq-fem-deq-1d-l4">
\[ \begin{align}\begin{aligned}\tag{140}
\mathcal{L}(u) = \frac{d}{dx}\left({\alpha}(u)\frac{du}{dx}\right) + f(u,x)\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>Both <span class="math">\({\alpha}(x)\)</span> and <span class="math">\(f(x)\)</span> are considered as specified functions,
while <span class="math">\(a\)</span> is a prescribed parameter.  Differential equations
corresponding to <a class="reference internal" href="#eq-fem-deq-1d-l1"><span class="std std-ref">(137)</span></a>-<a class="reference internal" href="#eq-fem-deq-1d-l2"><span class="std std-ref">(138)</span></a> arise in
diffusion phenomena, such as stationary (time-independent)
transport of heat in solids and
flow of viscous fluids between flat plates. The form
<a class="reference internal" href="#eq-fem-deq-1d-l3"><span class="std std-ref">(139)</span></a> arises when transient diffusion or wave
phenomena are discretized in time by finite differences. The equation
<a class="reference internal" href="#eq-fem-deq-1d-l4"><span class="std std-ref">(140)</span></a> appears in chemical models when diffusion of a
substance is combined with chemical reactions. Also in biology,
<a class="reference internal" href="#eq-fem-deq-1d-l4"><span class="std std-ref">(140)</span></a> plays an important role, both for spreading of
species and in models involving generation and
propagation of electrical signals.</p>
<p>Let <span class="math">\(\Omega =[0,L]\)</span> be the domain in one space dimension.
In addition to the differential equation, <span class="math">\(u\)</span> must fulfill
boundary conditions at the boundaries of the domain, <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>.
When <span class="math">\(\mathcal{L}\)</span> contains up to second-order derivatives, as in the
examples above, we need one boundary condition at each of
the (two) boundary points, here abstractly specified as</p>
<div class="math" id="eq-auto69">
\[\tag{141}
\mathcal{B}_0(u)=0,\ x=0,\quad \mathcal{B}_1(u)=0,\ x=L\]</div>
<p>There are three common choices of boundary conditions:</p>
<div class="math" id="eq-auto70">
\[\tag{142}
\mathcal{B}_i(u) = u - g,\quad \hbox{Dirichlet condition}\]</div>
<div class="math" id="eq-auto71">
\[\tag{143}
\mathcal{B}_i(u) = -{\alpha} \frac{du}{dx} - g,\quad \hbox{Neumann condition}\]</div>
<div class="math" id="eq-auto72">
\[\tag{144}
\mathcal{B}_i(u) = -{\alpha} \frac{du}{dx} - H(u-g),\quad \hbox{Robin condition}\]</div>
<p>Here, <span class="math">\(g\)</span> and <span class="math">\(H\)</span> are specified quantities.</p>
<p>From now on we shall use <span class="math">\({u_{\small\mbox{e}}}(x)\)</span> as symbol for the <em>exact</em> solution,
fulfilling</p>
<div class="math" id="eq-auto73">
\[\tag{145}
\mathcal{L}({u_{\small\mbox{e}}})=0,\quad x\in\Omega,\]</div>
<p>while <span class="math">\(u(x)\)</span> is our notation for an <em>approximate</em> solution of the differential
equation.</p>
<div class="admonition-remark-on-notation admonition">
<p class="first admonition-title">Remark on notation</p>
<p class="last">In the literature about the finite element method,
it is common to use <span class="math">\(u\)</span> as the exact solution and <span class="math">\(u_h\)</span> as the
approximate solution, where <span class="math">\(h\)</span> is a discretization parameter. However,
the vast part of the present text is about the approximate solutions,
and having a subscript <span class="math">\(h\)</span> attached all the time
is cumbersome. Of equal importance is the close correspondence between
implementation and mathematics that we strive to achieve in this text:
when it is natural to use <code class="docutils literal"><span class="pre">u</span></code> and not <code class="docutils literal"><span class="pre">u_h</span></code> in
code, we let the mathematical notation be dictated by the code&#8217;s
preferred notation. In the relatively few cases where we need to work
with the exact solution of the PDE problem we call it <span class="math">\({u_{\small\mbox{e}}}\)</span> in
mathematics and <code class="docutils literal"><span class="pre">u_e</span></code> in the code (the function for computing
<code class="docutils literal"><span class="pre">u_e</span></code> is named <code class="docutils literal"><span class="pre">u_exact</span></code>).</p>
</div>
</div>
<div class="section" id="simple-model-problems-and-their-solutions">
<span id="fem-deq-1d-models-simple"></span><h3>Simple model problems and their solutions<a class="headerlink" href="#simple-model-problems-and-their-solutions" title="Permalink to this headline">¶</a></h3>
<p>A common model problem used much in the forthcoming examples is</p>
<div class="math" id="eq-fem-deq-1d-model1">
\[\tag{146}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=D
    {\thinspace .}\]</div>
<p>A closely related problem with a different boundary condition at
<span class="math">\(x=0\)</span> reads</p>
<div class="math" id="eq-fem-deq-1d-model2">
\[\tag{147}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u'(0)=C,\ u(L)=D{\thinspace .}\]</div>
<p>A third variant has a variable coefficient,</p>
<div class="math" id="eq-fem-deq-1d-model3">
\[\tag{148}
-({\alpha}(x)u'(x))' = f(x),\quad x\in\Omega=[0,L],\quad u'(0)=C,\ u(L)=D{\thinspace .}\]</div>
<p>The solution <span class="math">\(u\)</span> to the model problem <a class="reference internal" href="#eq-fem-deq-1d-model1"><span class="std std-ref">(146)</span></a>
can be determined as</p>
<div class="math">
\[\begin{split}\begin{align*}
u'(x) &amp;= -\int_0^x f(x) + c_0, \\
u(x) &amp;= \int_0^x u'(x) + c_1,
\end{align*}\end{split}\]</div>
<p>where <span class="math">\(c_0\)</span> and <span class="math">\(c_1\)</span> are determined by the boundary conditions
such that <span class="math">\(u'(0) = C\)</span> and <span class="math">\(u(L) = D\)</span>.</p>
<p>Computing the solution is easily done
using <code class="docutils literal"><span class="pre">sympy</span></code>. Some common code is defined first:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span><span class="p">,</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x L C D c_0 c_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following function computes the solution
symbolically for the model problem <a class="reference internal" href="#eq-fem-deq-1d-model1"><span class="std std-ref">(146)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">model1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve -u&#39;&#39; = f(x), u(0)=0, u(L)=D.&quot;&quot;&quot;</span>
    <span class="c1"># Integrate twice</span>
    <span class="n">u_x</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">c_0</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">u_x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">c_1</span>
    <span class="c1"># Set up 2 equations from the 2 boundary conditions and solve</span>
    <span class="c1"># with respect to the integration constants c_0, c_1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># x=0 condition</span>
                   <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">L</span><span class="p">)</span><span class="o">-</span><span class="n">D</span><span class="p">],</span>  <span class="c1"># x=L condition</span>
                  <span class="p">[</span><span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span><span class="p">])</span>       <span class="c1"># unknowns</span>
    <span class="c1"># Substitute the integration constants in the solution</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c_0</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">c_0</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c_1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">c_1</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">model1(2,</span> <span class="pre">L,</span> <span class="pre">D)</span></code> results in the solution</p>
<div class="math" id="eq-fem-deq-1d-model1-sol">
\[\tag{149}
u(x) = \frac{1}{L}x \left(D + L^{2} - L x\right)\]</div>
<p>The model problem <a class="reference internal" href="#eq-fem-deq-1d-model2"><span class="std std-ref">(147)</span></a> can be solved by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">model2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve -u&#39;&#39; = f(x), u&#39;(0)=C, u(L)=D.&quot;&quot;&quot;</span>
    <span class="n">u_x</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">c_0</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">u_x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">c_1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">C</span><span class="p">,</span>  <span class="c1"># x=0 cond.</span>
                   <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">L</span><span class="p">)</span><span class="o">-</span><span class="n">D</span><span class="p">],</span>              <span class="c1"># x=L cond.</span>
                  <span class="p">[</span><span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c_0</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">c_0</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c_1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">c_1</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>to yield</p>
<div class="math" id="eq-fem-deq-1d-model2-sol">
\[\tag{150}
u(x) = - x^{2} + C x - C L + D + L^{2},\]</div>
<p>if <span class="math">\(f(x)=2\)</span>. Model <a class="reference internal" href="#eq-fem-deq-1d-model3"><span class="std std-ref">(148)</span></a> requires a bit more involved
code,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">model3</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve -(a*u&#39;)&#39; = f(x), u(0)=C, u(L)=D.&quot;&quot;&quot;</span>
    <span class="n">au_x</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">c_0</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">au_x</span><span class="o">/</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">c_1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">C</span><span class="p">,</span>
                   <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">L</span><span class="p">)</span><span class="o">-</span><span class="n">D</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c_0</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">c_0</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c_1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">c_1</span><span class="p">])</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">u</span>


<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">model1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;model1:&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">sym</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">model2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
    <span class="c1">#f = x</span>
    <span class="c1">#u = model2(f, L, C, D)</span>
    <span class="k">print</span> <span class="s1">&#39;model2:&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">sym</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">model3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
    <span class="k">print</span> <span class="s1">&#39;model3:&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">sym</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plain&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>
</div>
<p>With <span class="math">\(f(x)=0\)</span> and <span class="math">\({\alpha}(x)=1+x^2\)</span> we get</p>
<div class="math">
\[u(x) =
\frac{C \tan^{-1}\left (L \right ) - C \tan^{-1}\left (x \right ) + D \tan^{-1}\left (x \right )}{\tan^{-1}\left (L \right )}\]</div>
</div>
<div class="section" id="forming-the-residual">
<span id="fem-deq-1d-residual-min"></span><h3>Forming the residual<a class="headerlink" href="#forming-the-residual" title="Permalink to this headline">¶</a></h3>
<p>The fundamental idea is to seek an approximate solution
<span class="math">\(u\)</span> in some space <span class="math">\(V\)</span>,</p>
<div class="math">
\[V = \hbox{span}\{ {\psi}_0(x),\ldots,{\psi}_N(x)\},\]</div>
<p>which means that <span class="math">\(u\)</span> can always be expressed as a linear combination
of the basis functions <span class="math">\(\left\{ {{\psi}}_j \right\}_{j\in{\mathcal{I}_s}}\)</span>, with <span class="math">\({\mathcal{I}_s}\)</span> as
the index set <span class="math">\(\{0,\ldots,N\}\)</span>:</p>
<div class="math">
\[u(x) = \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x){\thinspace .}\]</div>
<p>The coefficients <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span> are unknowns to be computed.</p>
<p>(Later, in the section <a class="reference internal" href="._book020.html#fem-deq-1d-essbc"><span class="std std-ref">Boundary conditions: specified nonzero value</span></a>, we will see that if we specify boundary values of <span class="math">\(u\)</span> different
from zero, we must look for an approximate solution
<span class="math">\(u(x) = B(x) + \sum_{j} c_j{\psi}_j(x)\)</span>,
where <span class="math">\(\sum_{j}c_j{\psi}_j\in V\)</span> and <span class="math">\(B(x)\)</span> is some function for
incorporating the right boundary values. Because of <span class="math">\(B(x)\)</span>, <span class="math">\(u\)</span> will not
necessarily lie in <span class="math">\(V\)</span>. This modification does not imply any difficulties.)</p>
<p>We need principles for deriving <span class="math">\(N+1\)</span> equations to determine the
<span class="math">\(N+1\)</span> unknowns <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>.
When approximating a given function <span class="math">\(f\)</span> by <span class="math">\(u=\sum_jc_j{\varphi}_j\)</span>,
a key idea is to minimize the square norm of the
approximation error <span class="math">\(e=u-f\)</span> or (equivalently) demand that <span class="math">\(e\)</span> is
orthogonal to <span class="math">\(V\)</span>. Working with <span class="math">\(e\)</span> is not so useful here since
the approximation error in our case is <span class="math">\(e={u_{\small\mbox{e}}} - u\)</span> and <span class="math">\({u_{\small\mbox{e}}}\)</span> is
unknown. The only general indicator we have on the quality of the approximate
solution is to what degree <span class="math">\(u\)</span> fulfills the differential equation.
Inserting <span class="math">\(u=\sum_j c_j {\psi}_j\)</span> into <span class="math">\(\mathcal{L}(u)\)</span> reveals that the
result is not zero, because <span class="math">\(u\)</span> in general is an approximation and not identical to <span class="math">\({u_{\small\mbox{e}}}\)</span>.
The nonzero result,</p>
<div class="math" id="eq-auto74">
<span id="index-0"></span>\[\tag{151}
R = \mathcal{L}(u) = \mathcal{L}(\sum_j c_j {\psi}_j),\]</div>
<p>is called the <em>residual</em> and measures the
error in fulfilling the governing equation.</p>
<p>Various principles for determining <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span> try to minimize
<span class="math">\(R\)</span> in some sense. Note that <span class="math">\(R\)</span> varies with <span class="math">\(x\)</span> and
the <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span> parameters. We may write this dependence
explicitly as</p>
<div class="math" id="eq-auto75">
\[\tag{152}
R = R(x; c_0, \ldots, c_N){\thinspace .}\]</div>
<p>Below, we present three principles for making <span class="math">\(R\)</span> small:
a least squares method, a projection or Galerkin method, and
a collocation or interpolation method.</p>
</div>
<div class="section" id="the-least-squares-method-4">
<h3>The least squares method<a class="headerlink" href="#the-least-squares-method-4" title="Permalink to this headline">¶</a></h3>
<p>The least-squares method aims to find <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span> such that
the square norm of the residual</p>
<div class="math" id="eq-auto76">
\[\tag{153}
||R|| = (R, R) = \int_{\Omega} R^2 {\, \mathrm{d}x}\]</div>
<p>is minimized. By introducing
an inner product of two functions <span class="math">\(f\)</span> and <span class="math">\(g\)</span>
on <span class="math">\(\Omega\)</span> as</p>
<div class="math" id="eq-auto77">
\[\tag{154}
(f,g) = \int_{\Omega} f(x)g(x) {\, \mathrm{d}x},\]</div>
<p>the least-squares method can be defined as</p>
<div class="math" id="eq-auto78">
\[\tag{155}
\min_{c_0,\ldots,c_N} E = (R,R){\thinspace .}\]</div>
<p>Differentiating with respect to the free parameters <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>
gives the <span class="math">\(N+1\)</span> equations</p>
<div class="math" id="eq-fem-deq-1d-ls-eq1">
\[\tag{156}
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} {\, \mathrm{d}x} = 0\quad
    \Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
    i\in{\mathcal{I}_s}{\thinspace .}\]</div>
</div>
<div class="section" id="the-galerkin-method-1">
<h3>The Galerkin method<a class="headerlink" href="#the-galerkin-method-1" title="Permalink to this headline">¶</a></h3>
<p>The least-squares
principle is equivalent to demanding the error to be orthogonal to
the space <span class="math">\(V\)</span> when approximating a function <span class="math">\(f\)</span> by <span class="math">\(u\in V\)</span>.
With a differential equation
we do not know the true error so we must instead require the residual <span class="math">\(R\)</span>
to be orthogonal to <span class="math">\(V\)</span>. This idea implies
seeking <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span> such that</p>
<div class="math" id="eq-fem-deq-1d-galerkin0">
\[\tag{157}
(R,v)=0,\quad \forall v\in V{\thinspace .}\]</div>
<p>This is the Galerkin method for differential equations.</p>
<p>The above abstract statement can be made concrete by choosing a concrete basis.
For example, the statement is equivalent to <span class="math">\(R\)</span> being orthogonal to the <span class="math">\(N+1\)</span>
basis functions <span class="math">\(\{{\psi}_i\}\)</span> spanning <span class="math">\(V\)</span> (and this is
the most convenient way to express <a class="reference internal" href="#eq-fem-deq-1d-galerkin0"><span class="std std-ref">(157)</span></a>:</p>
<div class="math" id="eq-fem-deq-1d-galerkin">
\[\tag{158}
(R,{\psi}_i)=0,\quad i\in{\mathcal{I}_s},\]</div>
<p>resulting in <span class="math">\(N+1\)</span> equations for determining <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>.</p>
</div>
<div class="section" id="the-method-of-weighted-residuals">
<h3>The method of weighted residuals<a class="headerlink" href="#the-method-of-weighted-residuals" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-1"></span><p id="index-2">A generalization of the Galerkin method is to demand that <span class="math">\(R\)</span>
is orthogonal to some space <span class="math">\(W\)</span>, but not necessarily the same
space as <span class="math">\(V\)</span> where we seek the unknown function.
This generalization is called the <em>method of weighted residuals</em>:</p>
<div class="math" id="eq-fem-deq-1d-wrm0">
\[\tag{159}
(R,v)=0,\quad \forall v\in W{\thinspace .}\]</div>
<p>If <span class="math">\(\{w_0,\ldots,w_N\}\)</span> is a basis for <span class="math">\(W\)</span>, we can equivalently
express the method of weighted residuals as</p>
<div class="math" id="eq-fem-deq-1d-wrm">
\[\tag{160}
(R,w_i)=0,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The result is <span class="math">\(N+1\)</span> equations for <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>.</p>
<p>The least-squares method can also be viewed as a weighted residual
method with <span class="math">\(w_i = \partial R/\partial c_i\)</span>.</p>
<span class="target" id="index-3"></span><div class="admonition-variational-formulation-of-the-continuous-problem admonition" id="index-4">
<p class="first admonition-title">Variational formulation of the continuous problem</p>
<p>Statements like <a class="reference internal" href="#eq-fem-deq-1d-galerkin0"><span class="std std-ref">(157)</span></a>, <a class="reference internal" href="#eq-fem-deq-1d-galerkin"><span class="std std-ref">(158)</span></a>,
<a class="reference internal" href="#eq-fem-deq-1d-wrm0"><span class="std std-ref">(159)</span></a>, or
<a class="reference internal" href="#eq-fem-deq-1d-wrm"><span class="std std-ref">(160)</span></a>)
are known as
<a class="reference external" href="https://en.wikipedia.org/wiki/Weak_formulation">weak formulations</a>
or <em>variational formulations</em>.
These equations are in this text primarily used for a numerical approximation
<span class="math">\(u\in V\)</span>, where <span class="math">\(V\)</span> is a <em>finite-dimensional</em> space with dimension
<span class="math">\(N+1\)</span>. However, we may also let the exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfill a
variational formulation <span class="math">\((\mathcal{L}({u_{\small\mbox{e}}}),v)=0\)</span> $forall vin V$,
but the exact solution lies in general in a space with infinite
dimensions (because an infinite number of parameters are needed to
specify the solution). The variational formulation for <span class="math">\({u_{\small\mbox{e}}}\)</span>
in an infinite-dimensional space <span class="math">\(V\)</span> is
a mathematical way of stating the problem and acts as an
alternative to the usual (strong) formulation of a differential equation with
initial and/or boundary conditions.</p>
<p class="last">Much of the literature on finite
element methods takes a differential equation problem and first
transforms it to a variational formulation in an infinite-dimensional space
<span class="math">\(V\)</span>, before searching for an approximate solution in a finite-dimensional
subspace of <span class="math">\(V\)</span>. However, we prefer the more intuitive approach with an
approximate solution <span class="math">\(u\)</span> in a finite-dimensional space <span class="math">\(V\)</span> inserted in
the differential equation, and then the resulting residual is demanded to be
orthogonal to <span class="math">\(V\)</span>.</p>
</div>
<div class="admonition-remark-on-terminology admonition">
<p class="first admonition-title">Remark on terminology</p>
<p class="last">The terms weak or variational formulations often refer to a statement like
<a class="reference internal" href="#eq-fem-deq-1d-galerkin0"><span class="std std-ref">(157)</span></a> or <a class="reference internal" href="#eq-fem-deq-1d-wrm0"><span class="std std-ref">(159)</span></a>
after <em>integration by parts</em> has been performed (the integration by
parts technique is
explained in the section <a class="reference internal" href="#fem-deq-1d-varform"><span class="std std-ref">Integration by parts</span></a>).
The result after
integration by parts is what is obtained after taking the <em>first
variation</em> of a minimization problem (see
the section <a class="reference internal" href="._book016.html#fem-deq-1d-optimization"><span class="std std-ref">Variational problems and minimization of functionals</span></a>).
However, in this text we use variational formulation as a common term for
formulations which, in contrast to the differential equation <span class="math">\(R=0\)</span>,
instead demand that an average of <span class="math">\(R\)</span> is zero: <span class="math">\((R,v)=0\)</span> for all <span class="math">\(v\)</span> in some space.</p>
</div>
</div>
<div class="section" id="test-and-trial-functions">
<h3>Test and trial functions<a class="headerlink" href="#test-and-trial-functions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-5"></span><span class="target" id="index-6"></span><span class="target" id="index-7"></span><p id="index-8">In the context of the Galerkin method and the method of weighted residuals it is
common to use the name <em>trial function</em> for the approximate <span class="math">\(u =
\sum_j c_j {\psi}_j\)</span>.</p>
<p>The space containing the trial function is known as the <em>trial space</em>.
The function <span class="math">\(v\)</span> entering the orthogonality requirement in
the Galerkin method and the method of weighted residuals is called
<em>test function</em>, and so are the <span class="math">\({\psi}_i\)</span> or <span class="math">\(w_i\)</span> functions that are
used as weights in the inner products with the residual.  The space
where the test functions comes from is naturally called the
<em>test space</em>.</p>
<p>We see that in the method of weighted residuals the test and trial spaces
are different and so are the test and trial functions.
In the Galerkin method the test and trial spaces are the same (so far).</p>
</div>
<div class="section" id="the-collocation-method-1">
<h3>The collocation method<a class="headerlink" href="#the-collocation-method-1" title="Permalink to this headline">¶</a></h3>
<p>The idea of the collocation method is to demand that <span class="math">\(R\)</span> vanishes
at <span class="math">\(N+1\)</span> selected points <span class="math">\(x_{0},\ldots,x_{N}\)</span> in <span class="math">\(\Omega\)</span>:</p>
<div class="math" id="eq-fem-deq-1d-collocation">
\[\tag{161}
R(x_{i}; c_0,\ldots,c_N)=0,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The collocation method can also be viewed as a method of weighted residuals
with Dirac delta functions as weighting functions.
Let <span class="math">\(\delta (x-x_{i})\)</span> be the Dirac delta function centered around
<span class="math">\(x=x_{i}\)</span> with the properties that <span class="math">\(\delta (x-x_{i})=0\)</span> for <span class="math">\(x\neq x_{i}\)</span>
and</p>
<div class="math" id="eq-fem-deq-1d-dirac">
\[\tag{162}
\int_{\Omega} f(x)\delta (x-x_{i}) {\, \mathrm{d}x} =
    f(x_{i}),\quad x_{i}\in\Omega{\thinspace .}\]</div>
<p>Intuitively, we may think of <span class="math">\(\delta (x-x_{i})\)</span> as a very peak-shaped
function around <span class="math">\(x=x_{i}\)</span> with an integral <span class="math">\(\int_{-\infty}^\infty \delta(x-x_{i})dx\)</span> that evaluates to unity. Mathematically, it can be shown that
<span class="math">\(\delta (x-x_{i})\)</span> is the limit of a Gaussian function centered at
<span class="math">\(x=x_{i}\)</span> with a standard deviation that approaches zero.
Using this latter model, we can roughly visualize delta functions as
done in Figure <a class="reference internal" href="#fem-deq-1d-fig-dirac"><span class="std std-ref">Approximation of delta functions by narrow Gaussian functions</span></a>.
Because of <a class="reference internal" href="#eq-fem-deq-1d-dirac"><span class="std std-ref">(162)</span></a>, we can let <span class="math">\(w_i=\delta(x-x_{i})\)</span>
be weighting functions in the method of weighted residuals,
and <a class="reference internal" href="#eq-fem-deq-1d-wrm"><span class="std std-ref">(160)</span></a> becomes equivalent to
<a class="reference internal" href="#eq-fem-deq-1d-collocation"><span class="std std-ref">(161)</span></a>.</p>
<div class="figure" id="id1">
<span id="fem-deq-1d-fig-dirac"></span><a class="reference internal image-reference" href="_images/delta_func_weight.png"><img alt="_images/delta_func_weight.png" src="_images/delta_func_weight.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Approximation of delta functions by narrow Gaussian functions</em></span></p>
</div>
<div class="section" id="the-subdomain-collocation-method">
<h4>The subdomain collocation method<a class="headerlink" href="#the-subdomain-collocation-method" title="Permalink to this headline">¶</a></h4>
<p>The idea of this approach is to demand the integral of <span class="math">\(R\)</span> to vanish
over <span class="math">\(N+1\)</span> subdomains <span class="math">\(\Omega_i\)</span> of <span class="math">\(\Omega\)</span>:</p>
<div class="math" id="eq-auto79">
\[\tag{163}
\int_{\Omega_i} R\, {\, \mathrm{d}x}=0,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>This statement can also be expressed as a weighted residual method</p>
<div class="math" id="eq-auto80">
\[\tag{164}
\int_{\Omega} Rw_i\, {\, \mathrm{d}x}=0,\quad i\in{\mathcal{I}_s},\]</div>
<p>where <span class="math">\(w_i=1\)</span> for <span class="math">\(x\in\Omega_i\)</span> and <span class="math">\(w_i=0\)</span> otherwise.</p>
</div>
</div>
<div class="section" id="examples-on-using-the-principles">
<span id="fem-deq-1d-ex-sines"></span><h3>Examples on using the principles<a class="headerlink" href="#examples-on-using-the-principles" title="Permalink to this headline">¶</a></h3>
<p>Let us now apply global basis functions to illustrate the different
principles for making the residual <span class="math">\(R\)</span> small.</p>
<div class="section" id="the-model-problem">
<h4>The model problem<a class="headerlink" href="#the-model-problem" title="Permalink to this headline">¶</a></h4>
<p>We consider the differential equation problem</p>
<div class="math" id="eq-fem-deq-1d-model1b">
\[\tag{165}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
    {\thinspace .}\]</div>
</div>
<div class="section" id="basis-functions">
<h4>Basis functions<a class="headerlink" href="#basis-functions" title="Permalink to this headline">¶</a></h4>
<p>Our choice of basis functions <span class="math">\({\psi}_i\)</span>
for <span class="math">\(V\)</span> is</p>
<div class="math" id="eq-fem-deq-1d-ex-sines-psi">
\[\tag{166}
{\psi}_i(x) = {\sin\left((i+1)\pi\frac{x}{L}\right)},\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>An important property of these functions is that <span class="math">\({\psi}_i(0)={\psi}_i(L)=0\)</span>,
which means that the boundary conditions on <span class="math">\(u\)</span> are fulfilled:</p>
<div class="math">
\[u(0) = \sum_jc_j{\psi}_j(0) = 0,\quad u(L) = \sum_jc_j{\psi}_j(L) =0
{\thinspace .}\]</div>
<p>Another nice property is that the chosen sine functions
are orthogonal on <span class="math">\(\Omega\)</span>:</p>
<div class="math" id="eq-auto81">
\[\begin{split}\tag{167}
\int\limits_0^L {\sin\left((i+1)\pi\frac{x}{L}\right)}{\sin\left((j+1)\pi\frac{x}{L}\right)}\, {\, \mathrm{d}x} = \left\lbrace
    \begin{array}{ll} \frac{1}{2} L &amp; i=j  \\ 0, &amp; i\neq j
    \end{array}\right.\end{split}\]</div>
<p>provided <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are integers.</p>
</div>
<div class="section" id="the-residual">
<h4>The residual<a class="headerlink" href="#the-residual" title="Permalink to this headline">¶</a></h4>
<p>We can readily calculate the following explicit expression for the
residual:</p>
<div class="math">
\[R(x;c_0, \ldots, c_N) = u''(x) + f(x),\nonumber\]</div>
<div class="math">
\[= \frac{d^2}{dx^2}\left(\sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x)\right)
+ f(x),\nonumber\]</div>
<div class="math" id="eq-fem-deq-1d-ex-sines-res">
\[\tag{168}
= \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j''(x) + f(x){\thinspace .}\]</div>
</div>
<div class="section" id="the-least-squares-method-5">
<h4>The least squares method<a class="headerlink" href="#the-least-squares-method-5" title="Permalink to this headline">¶</a></h4>
<p>The equations <a class="reference internal" href="#eq-fem-deq-1d-ls-eq1"><span class="std std-ref">(156)</span></a>
in the least squares method require an expression for
<span class="math">\(\partial R/\partial c_i\)</span>. We have</p>
<div class="math" id="eq-auto82">
\[\tag{169}
\frac{\partial R}{\partial c_i} =
    \frac{\partial}{\partial c_i}
    \left(\sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j''(x) + f(x)\right)
    = \sum_{j\in{\mathcal{I}_s}} \frac{\partial c_j}{\partial c_i}{\psi}_j''(x)
    = {\psi}_i''(x){\thinspace .}\]</div>
<p>The governing equations for the unknown parameters <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span> are then</p>
<div class="math" id="eq-auto83">
\[\tag{170}
(\sum_j c_j {\psi}_j'' + f,{\psi}_i'')=0,\quad i\in{\mathcal{I}_s},\]</div>
<p>which can be rearranged as</p>
<div class="math" id="eq-auto84">
\[\tag{171}
\sum_{j\in{\mathcal{I}_s}}({\psi}_i'',{\psi}_j'')c_j = -(f,{\psi}_i''),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>This is nothing but a linear system</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}}A_{i,j}c_j = b_i,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The entries in the coefficient matrix are given by</p>
<div class="math">
\[\begin{split}\begin{align*}
A_{i,j} &amp;= ({\psi}_i'',{\psi}_j'')\nonumber\\
&amp; = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L {\sin\left((i+1)\pi\frac{x}{L}\right)}{\sin\left((j+1)\pi\frac{x}{L}\right)}\, {\, \mathrm{d}x}
\end{align*}\end{split}\]</div>
<p>The orthogonality of the sine functions simplify the coefficient matrix:</p>
<div class="math" id="eq-auto85">
\[\begin{split}\tag{172}
A_{i,j} = \left\lbrace \begin{array}{ll}
    {1\over2}L^{-3}\pi^4(i+1)^4 &amp; i=j  \\
    0,                          &amp; i\neq j
    \end{array}\right.\end{split}\]</div>
<p>The right-hand side reads</p>
<div class="math" id="eq-auto86">
\[\tag{173}
b_i = -(f,{\psi}_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x){\sin\left((i+1)\pi\frac{x}{L}\right)}\, {\, \mathrm{d}x}\]</div>
<p>Since the coefficient matrix is diagonal we can easily solve for</p>
<div class="math" id="eq-fem-deq-1d-ex-sines-solution">
\[\tag{174}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x){\sin\left((i+1)\pi\frac{x}{L}\right)}\, {\, \mathrm{d}x}{\thinspace .}\]</div>
<p>With the special choice of <span class="math">\(f(x)=2\)</span>, the coefficients
can be calculated in <code class="docutils literal"><span class="pre">sympy</span></code> by</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>

<span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;i j&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x L&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">/</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c_i</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
<span class="n">c_i</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">c_i</span><span class="p">)</span>
<span class="k">print</span> <span class="n">c_i</span>
</pre></div>
</div>
<p>The answer becomes</p>
<div class="math">
\[c_i = 4 \frac{L^{2} \left(\left(-1\right)^{i} + 1\right)}{\pi^{3}
\left(i^{3} + 3 i^{2} + 3 i + 1\right)}\]</div>
<p>Now, <span class="math">\(1+(-1)^i=0\)</span> for <span class="math">\(i\)</span> odd, so only the coefficients with even index
are nonzero. Introducing <span class="math">\(i=2k\)</span> for <span class="math">\(k=0,\ldots,N/2\)</span> to count the
relevant indices (for <span class="math">\(N\)</span> odd, <span class="math">\(k\)</span> goes to <span class="math">\((N-1)/2\)</span>), we get the solution</p>
<div class="math" id="eq-auto87">
\[\tag{175}
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}{\sin\left((2k+1)\pi\frac{x}{L}\right)}{\thinspace .}\]</div>
<p>The coefficients decay very fast: <span class="math">\(c_2 = c_0/27\)</span>, <span class="math">\(c_4=c_0/125\)</span>.
The solution will therefore be dominated by the first term,</p>
<div class="math">
\[u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right){\thinspace .}\]</div>
</div>
<div class="section" id="the-galerkin-method-2">
<h4>The Galerkin method<a class="headerlink" href="#the-galerkin-method-2" title="Permalink to this headline">¶</a></h4>
<p>The Galerkin principle <a class="reference internal" href="#eq-fem-deq-1d-galerkin0"><span class="std std-ref">(157)</span></a>
applied to <a class="reference internal" href="#eq-fem-deq-1d-model1b"><span class="std std-ref">(165)</span></a> consists of inserting
our special residual <a class="reference internal" href="#eq-fem-deq-1d-ex-sines-res"><span class="std std-ref">(168)</span></a> in
<a class="reference internal" href="#eq-fem-deq-1d-galerkin0"><span class="std std-ref">(157)</span></a></p>
<div class="math">
\[(u''+f,v)=0,\quad \forall v\in V,\]</div>
<p>or</p>
<div class="math" id="eq-auto88">
\[\tag{176}
(u'',v) = -(f,v),\quad\forall v\in V{\thinspace .}\]</div>
<p>This is the variational formulation, based on the Galerkin principle,
of our differential equation.
The <span class="math">\(\forall v\in V\)</span> requirement is equivalent to
demanding the equation <span class="math">\((u'',v) = -(f,v)\)</span> to be fulfilled for all
basis functions <span class="math">\(v={\psi}_i\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>, see
<a class="reference internal" href="#eq-fem-deq-1d-galerkin0"><span class="std std-ref">(157)</span></a> and <a class="reference internal" href="#eq-fem-deq-1d-galerkin"><span class="std std-ref">(158)</span></a>.
We therefore have</p>
<div class="math" id="eq-auto89">
\[\tag{177}
(\sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j'', {\psi}_i)=-(f,{\psi}_i),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>This equation can be rearranged to a form that explicitly shows
that we get a linear system for the unknowns <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span>:</p>
<div class="math" id="eq-auto90">
\[\tag{178}
\sum_{j\in{\mathcal{I}_s}} ({\psi}_i,{\psi}_j'')c_j = (f, {\psi}_i),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>For the particular choice of the basis functions <a class="reference internal" href="#eq-fem-deq-1d-ex-sines-psi"><span class="std std-ref">(166)</span></a>
we get in fact the same linear system
as in the least squares method
because <span class="math">\({\psi}''= -(i+1)^2\pi^2L^{-2}{\psi}\)</span>.
Consequently, the solution <span class="math">\(u(x)\)</span> becomes identical to the one produced
by the least squares method.</p>
</div>
<div class="section" id="the-collocation-method-2">
<h4>The collocation method<a class="headerlink" href="#the-collocation-method-2" title="Permalink to this headline">¶</a></h4>
<p>For the collocation method <a class="reference internal" href="#eq-fem-deq-1d-collocation"><span class="std std-ref">(161)</span></a> we need to
decide upon a set of <span class="math">\(N+1\)</span> collocation points in <span class="math">\(\Omega\)</span>. A simple
choice is to use uniformly spaced points: <span class="math">\(x_{i}=i\Delta x\)</span>, where
<span class="math">\(\Delta x = L/N\)</span> in our case (<span class="math">\(N\geq 1\)</span>). However, these points
lead to at least two rows in the matrix consisting of zeros
(since <span class="math">\({\psi}_i(x_{0})=0\)</span> and <span class="math">\({\psi}_i(x_{N})=0\)</span>), thereby making the matrix
singular and non-invertible. This forces us to choose some other
collocation points, e.g., random points or points uniformly distributed
in the interior of <span class="math">\(\Omega\)</span>.
Demanding the residual to vanish
at these points leads, in our model problem <a class="reference internal" href="#eq-fem-deq-1d-model1b"><span class="std std-ref">(165)</span></a>, to
the equations</p>
<div class="math" id="eq-auto91">
\[\tag{179}
-\sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j''(x_{i}) = f(x_{i}),\quad i\in{\mathcal{I}_s},\]</div>
<p>which is seen to be a linear system with entries</p>
<div class="math">
\[A_{i,j}=-{\psi}_j''(x_{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),\]</div>
<p>in the coefficient matrix and entries
<span class="math">\(b_i=2\)</span> for the right-hand side (when <span class="math">\(f(x)=2\)</span>).</p>
<p>The special case of <span class="math">\(N=0\)</span>
can sometimes be of interest. A natural choice is then the midpoint
<span class="math">\(x_{0}=L/2\)</span> of the domain, resulting in
<span class="math">\(A_{0,0} = -{\psi}_0''(x_{0}) = \pi^2L^{-2}\)</span>, <span class="math">\(f(x_0)=2\)</span>,
and hence <span class="math">\(c_0=2L^2/\pi^2\)</span>.</p>
</div>
<div class="section" id="comparison">
<h4>Comparison<a class="headerlink" href="#comparison" title="Permalink to this headline">¶</a></h4>
<p>In the present model problem, with <span class="math">\(f(x)=2\)</span>, the exact solution is
<span class="math">\(u(x)=x(L-x)\)</span>, while for <span class="math">\(N=0\)</span> the Galerkin and least squares method
result in <span class="math">\(u(x)=8L^2\pi^{-3}\sin (\pi x/L)\)</span> and the
collocation method leads to <span class="math">\(u(x)=2L^2\pi^{-2}\sin (\pi x/L)\)</span>.
We can quickly use <code class="docutils literal"><span class="pre">sympy</span></code> to verify that the maximum error
occurs at the midpoint <span class="math">\(x=L/2\)</span> and find what the errors are.
First we set up the error expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Computing with Dirichlet conditions: -u&#39;&#39;=2 and sines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x L&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_Galerkin</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_colloc</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>If the derivative of the errors vanish at <span class="math">\(x=L/2\)</span>, the errors reach
their maximum values here (the errors vanish at the boundary points).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dedx_Galerkin</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">e_Galerkin</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dedx_Galerkin</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dedx_colloc</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">e_colloc</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dedx_colloc</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Finally, we can compute the maximum error at <span class="math">\(x=L/2\)</span> and evaluate
the expressions numerically with three decimals:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">e_Galerkin</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">-0.00812*L**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">e_colloc</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">0.0473*L**2</span>
</pre></div>
</div>
<p>The error in the collocation method is about 6 times larger than
the error in the Galerkin or least squares method.</p>
</div>
</div>
<div class="section" id="integration-by-parts-1">
<span id="fem-deq-1d-varform"></span><h3>Integration by parts<a class="headerlink" href="#integration-by-parts-1" title="Permalink to this headline">¶</a></h3>
<p id="index-9">A problem arises if we want to apply popular finite element functions
to solve our model problem <a class="reference internal" href="#eq-fem-deq-1d-model1b"><span class="std std-ref">(165)</span></a>
by the standard least squares, Galerkin, or collocation methods: the piecewise
polynomials <span class="math">\({\psi}_i(x)\)</span> have discontinuous derivatives at the
cell boundaries which makes it problematic to compute
the second-order derivative.  This fact actually makes the least squares and
collocation methods less suitable for finite element approximation of
the unknown function. (By rewriting the equation <span class="math">\(-u''=f\)</span> as a
system of two first-order equations, <span class="math">\(u'=v\)</span> and <span class="math">\(-v'=f\)</span>, the
least squares method can be applied. Also, differentiating discontinuous
functions can actually be handled by distribution theory in
mathematics.)  The Galerkin method and the method of
weighted residuals can, however, be applied together with finite
element basis functions if we use <em>integration by parts</em>
as a means for transforming a second-order derivative to a first-order
one.</p>
<p>Consider the model problem <a class="reference internal" href="#eq-fem-deq-1d-model1b"><span class="std std-ref">(165)</span></a> and its
Galerkin formulation</p>
<div class="math">
\[-(u'',v) = (f,v)\quad\forall v\in V{\thinspace .}\]</div>
<p>Using integration by parts in the Galerkin method,
we can &#8220;move&#8221; a derivative of <span class="math">\(u\)</span> onto <span class="math">\(v\)</span>:</p>
<div class="math">
\[\int_0^L u''(x)v(x) {\, \mathrm{d}x} = - \int_0^Lu'(x)v'(x){\, \mathrm{d}x}
+ [vu']_0^L\nonumber\]</div>
<div class="math" id="eq-fem-deq-1d-intbyparts">
\[\tag{180}
= - \int_0^Lu'(x)v'(x) {\, \mathrm{d}x}
    + u'(L)v(L) - u'(0)v(0){\thinspace .}\]</div>
<p>Usually, one integrates the problem at the stage where the <span class="math">\(u\)</span> and <span class="math">\(v\)</span>
functions enter the formulation.
Alternatively, but less common, we can integrate by parts in the expressions for
the matrix entries:</p>
<div class="math">
\[\int_0^L{\psi}_i(x){\psi}_j''(x) {\, \mathrm{d}x} =
- \int_0^L{\psi}_i'(x){\psi}_j'(x) dx
+ [{\psi}_i{\psi}_j']_0^L\nonumber\]</div>
<div class="math" id="eq-fem-deq-1d-intbyparts0">
\[\tag{181}
= - \int_0^L{\psi}_i'(x){\psi}_j'(x) {\, \mathrm{d}x}
    + {\psi}_i(L){\psi}_j'(L) - {\psi}_i(0){\psi}_j'(0){\thinspace .}\]</div>
<p>Integration by parts serves to reduce the order of the derivatives and
to make the coefficient matrix symmetric since
<span class="math">\(({\psi}_i',{\psi}_j') = ({\psi}_j',{\psi}_i')\)</span>.
The symmetry property depends
on the type of terms that enter the differential equation.
As will be seen later in the section <a class="reference internal" href="._book021.html#fem-deq-1d-bc-nat"><span class="std std-ref">Boundary conditions: specified derivative</span></a>,
integration by parts also provides a method for implementing
boundary conditions involving <span class="math">\(u'\)</span>.</p>
<p>With the choice <a class="reference internal" href="#eq-fem-deq-1d-ex-sines-psi"><span class="std std-ref">(166)</span></a> of basis functions we see
that the &#8220;boundary terms&#8221;
<span class="math">\({\psi}_i(L){\psi}_j'(L)\)</span> and <span class="math">\({\psi}_i(0){\psi}_j'(0)\)</span>
vanish since <span class="math">\({\psi}_i(0)={\psi}_i(L)=0\)</span>.</p>
<p>We therefore end up with the following alternative Galerkin formulation:</p>
<div class="math">
\[-(u'',v) = (u', v') = (f,v)\quad \forall v\in V{\thinspace .}\]</div>
<span class="target" id="index-10"></span><div class="section" id="weak-form">
<span id="index-11"></span><h4>Weak form<a class="headerlink" href="#weak-form" title="Permalink to this headline">¶</a></h4>
<p>Since the variational formulation after integration by parts make
weaker demands on the differentiability of <span class="math">\(u\)</span> and the basis
functions <span class="math">\({\psi}_i\)</span>,
the resulting integral formulation is referred to as a <em>weak form</em> of
the differential equation problem. The original variational formulation
with second-order derivatives, or the differential equation problem
with second-order derivative, is then the <em>strong form</em>, with
stronger requirements on the differentiability of the functions.</p>
<p>For differential equations with second-order derivatives, expressed as
variational formulations and solved by finite element methods, we will
always perform integration by parts to arrive at expressions involving
only first-order derivatives.</p>
</div>
</div>
<div class="section" id="boundary-function-1">
<span id="fem-deq-1d-essbc-bfunc"></span><h3>Boundary function<a class="headerlink" href="#boundary-function-1" title="Permalink to this headline">¶</a></h3>
<p>So far we have assumed zero Dirichlet boundary conditions, typically
<span class="math">\(u(0)=u(L)=0\)</span>, and we have demanded that <span class="math">\({\psi}_i(0)={\psi}_i(L)=0\)</span>
for <span class="math">\(i\in{\mathcal{I}_s}\)</span>. What about a boundary condition like <span class="math">\(u(L)=D\neq0\)</span>?
This condition immediately faces a problem:
<span class="math">\(u = \sum_j c_j{\varphi}_j(L) = 0\)</span> since all <span class="math">\({\varphi}_i(L)=0\)</span>.</p>
<p>We remark that we  faced exactly the same problem  in the section <a class="reference internal" href="._book005.html#fem-approx-global-fourier"><span class="std std-ref">Fourier series</span></a> where
we considered Fourier series approximations of functions that where non-zero at the boundaries.
We will use the same trick as we did earlier to get around this problem.</p>
<p>A boundary condition of the form <span class="math">\(u(L)=D\)</span> can be implemented by
demanding that all <span class="math">\({\psi}_i(L)=0\)</span>, but adding a
<em>boundary function</em> <span class="math">\(B(x)\)</span> with the right boundary value, <span class="math">\(B(L)=D\)</span>, to
the expansion for <span class="math">\(u\)</span>:</p>
<div class="math">
\[u(x) = B(x) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x)
{\thinspace .}\]</div>
<p>This <span class="math">\(u\)</span> gets the right value at <span class="math">\(x=L\)</span>:</p>
<div class="math">
\[u(L) = B(L) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(L) = B(L) = D{\thinspace .}\]</div>
<p>The idea is that for any boundary where <span class="math">\(u\)</span> is known we demand <span class="math">\({\psi}_i\)</span> to
vanish and construct a function <span class="math">\(B(x)\)</span> to attain the boundary value of <span class="math">\(u\)</span>.
There are no restrictions on how <span class="math">\(B(x)\)</span> varies with <span class="math">\(x\)</span> in the interior of the
domain, so this variation needs to be constructed in some way. Exactly how
we decide the variation to be, is not important.</p>
<p>For example, with <span class="math">\(u(0)=0\)</span> and
<span class="math">\(u(L)=D\)</span>, we can choose <span class="math">\(B(x)=x D/L\)</span>, since this form ensures that
<span class="math">\(B(x)\)</span> fulfills the boundary conditions: <span class="math">\(B(0)=0\)</span> and <span class="math">\(B(L)=D\)</span>.
The unknown function is then sought on the form</p>
<div class="math" id="eq-fem-deq-1d-essbc-bfunc-u1">
\[\tag{182}
u(x) = \frac{x}{L}D + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x),\]</div>
<p>with <span class="math">\({\psi}_i(0)={\psi}_i(L)=0\)</span>.</p>
<p>The particular shape of the <span class="math">\(B(x)\)</span> function is not important
as long as its boundary
values are correct. For example, <span class="math">\(B(x)=D(x/L)^p\)</span> for any power <span class="math">\(p\)</span>
will work fine in the above example. Another choice could be
<span class="math">\(B(x)=D\sin (\pi x/(2L))\)</span>.</p>
<p>As a more general example, consider a domain <span class="math">\(\Omega = [a,b]\)</span>
where the boundary conditions are <span class="math">\(u(a)=U_a\)</span> and <span class="math">\(u(b)=U_b\)</span>.  A class
of possible <span class="math">\(B(x)\)</span> functions is</p>
<div class="math" id="eq-fem-deq-1d-essbc-bfunc-gen">
\[\tag{183}
B(x)=U_a + \frac{U_b-U_a}{(b-a)^p}(x-a)^p,\quad p&gt;0
    {\thinspace .}\]</div>
<p>Real applications will most likely use the simplest version, <span class="math">\(p=1\)</span>,
but here such a <span class="math">\(p\)</span> parameter was included to demonstrate that there
are many choices of <span class="math">\(B(x)\)</span> in a problem. Fortunately, there is a general, unique
technique for constructing <span class="math">\(B(x)\)</span> when we use finite element basis functions for
<span class="math">\(V\)</span>.</p>
<p>[<strong>kam 7</strong>: in the below, I cannot really find where it is stated that we need to adjust the right-hand side as well]
[<strong>hpl 8</strong>: I don&#8217;t understand what you mean.]</p>
<div class="admonition-how-to-deal-with-nonzero-dirichlet-conditions admonition">
<p class="first admonition-title">How to deal with nonzero Dirichlet conditions</p>
<p class="last">The general procedure of incorporating Dirichlet boundary
conditions goes as follows.
Let <span class="math">\(\partial\Omega_E\)</span> be the part(s) of the boundary
<span class="math">\(\partial\Omega\)</span> of the domain <span class="math">\(\Omega\)</span> where <span class="math">\(u\)</span> is specified.
Set <span class="math">\({\psi}_i=0\)</span> at the points in <span class="math">\(\partial\Omega_E\)</span> and seek <span class="math">\(u\)</span>
as</p>
</div>
<div class="math" id="eq-fem-deq-1d-essbc-bfunc-u2">
\[ \begin{align}\begin{aligned} \tag{184}
 u(x) = B(x) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x),\\where  \( B(x) \)  equals the boundary conditions on  \( u \)  at  \( \partial\Omega_E \) .\end{aligned}\end{align} \]</div>
<p><strong>Remark.</strong>
With the <span class="math">\(B(x)\)</span> term, <span class="math">\(u\)</span> does not in general lie in <span class="math">\(V=\hbox{span}\,
\{{\psi}_0,\ldots,{\psi}_N\}\)</span> anymore. Moreover, when a prescribed value
of <span class="math">\(u\)</span> at the boundary, say <span class="math">\(u(a)=U_a\)</span> is different from zero, it does
not make sense to say that <span class="math">\(u\)</span> lies in a vector space, because
this space does not obey the requirements of addition and scalar multiplication.
For example,
<span class="math">\(2u\)</span> does not lie in the space since its boundary value is <span class="math">\(2U_a\)</span>,
which is incorrect. It only makes sense to split <span class="math">\(u\)</span> in two parts,
as done above, and have the unknown part <span class="math">\(\sum_j c_j {\psi}_j\)</span> in a
proper function space.</p>
</div>
</div>
<div class="section" id="computing-with-global-polynomials">
<h2>Computing with global polynomials<a class="headerlink" href="#computing-with-global-polynomials" title="Permalink to this headline">¶</a></h2>
<p>The next example uses global polynomials and shows
that if our solution, modulo boundary conditions, lies in the space spanned
by these polynomials, then the Galerkin method recovers the exact solution.</p>
<div class="section" id="computing-with-dirichlet-and-neumann-conditions">
<span id="fem-deq-1d-varform-ex-dn-case"></span><h3>Computing with Dirichlet and Neumann conditions<a class="headerlink" href="#computing-with-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h3>
<p>Let us perform the necessary calculations to solve</p>
<div class="math">
\[-u''(x)=2,\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D,\]</div>
<p>using a global polynomial basis <span class="math">\({\psi}_i\sim x^i\)</span>.
The requirements on <span class="math">\({\psi}_i\)</span> is that <span class="math">\({\psi}_i(1)=0\)</span>, because <span class="math">\(u\)</span> is
specified at <span class="math">\(x=1\)</span>, so a proper set of polynomial basis functions can be</p>
<div class="math">
\[{\psi}_i(x)=(1-x)^{i+1}, \quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>A suitable <span class="math">\(B(x)\)</span> function
to handle the boundary condition <span class="math">\(u(1)=D\)</span> is <span class="math">\(B(x)=Dx\)</span>.
The variational formulation becomes</p>
<div class="math">
\[(u',v') = (2,v) - Cv(0)\quad\forall v\in V{\thinspace .}\]</div>
<p>From inserting <span class="math">\(u=B + \sum_{j}c_j{\psi}_j\)</span> and choosing <span class="math">\(v={\psi}_i\)</span> we get</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}} ({\psi}_j',{\psi}_i')c_j = (2,{\psi}_i)
- (B',{\psi}_i') - C{\psi}_i(0),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The entries in the linear system are then</p>
<div class="math">
\[\begin{split}\begin{align*}
A_{i,j} &amp;= ({\psi}_j',{\psi}_i') = \int_{0}^1 {\psi}_i'(x){\psi}_j'(x){\, \mathrm{d}x}
= \int_0^1 (i+1)(j+1)(1-x)^{i+j}{\, \mathrm{d}x}\\
&amp;= \frac{(i+1)(j+1)}{i + j + 1},\\
b_i &amp;= (2,{\psi}_i) - (D,{\psi}_i') -C{\psi}_i(0)\\
&amp;= \int_0^1\left( 2{\psi}_i(x) - D{\psi}_i'(x)\right){\, \mathrm{d}x} -C{\psi}_i(0)\\
&amp;= \int_0^1 \left( 2(1-x)^{i+1} + D(i+1)(1-x)^i\right){\, \mathrm{d}x}  -C\\
&amp;= \frac{(D-C)(i+2) + 2}{i+2} = D - C + \frac{2}{i+2}
{\thinspace .}
\end{align*}\end{split}\]</div>
<p>Relevant <code class="docutils literal"><span class="pre">sympy</span></code> commands to help calculate these expressions are</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x C D&#39;</span><span class="p">)</span>
<span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;i j&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">psi_i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">psi_j</span> <span class="o">=</span> <span class="n">psi_i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">psi_j</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">integrand</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">integrand</span><span class="p">)</span>
<span class="n">A_ij</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">A_ij</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">A_ij</span><span class="p">)</span>
<span class="k">print</span> <span class="s1">&#39;A_ij:&#39;</span><span class="p">,</span> <span class="n">A_ij</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">b_i</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">psi_i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> \
      <span class="n">integrate</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> \
      <span class="n">C</span><span class="o">*</span><span class="n">psi_i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">b_i</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">b_i</span><span class="p">)</span>
<span class="k">print</span> <span class="s1">&#39;b_i:&#39;</span><span class="p">,</span> <span class="n">b_i</span>
</pre></div>
</div>
<p>The output becomes</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>A_ij: (i + 1)*(j + 1)/(i + j + 1)
b_i: ((-C + D)*(i + 2) + 2)/(i + 2)
</pre></div>
</div>
<p>We can now choose some <span class="math">\(N\)</span> and form the linear system, say for <span class="math">\(N=1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="s1">&#39;fresh b:&#39;</span><span class="p">,</span> <span class="n">b</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_ij</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">b</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>The system becomes</p>
<div class="math">
\[\begin{split}\left(\begin{array}{cc}
1 &amp; 1\\
1 &amp; 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\
c_1
\end{array}\right)
=
\left(\begin{array}{c}
1-C+D\\
2/3 -C + D
\end{array}\right)\end{split}\]</div>
<p>The solution (<code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">A.LUsolve(b)</span></code>)
becomes <span class="math">\(c_0=2 -C+D\)</span> and <span class="math">\(c_1=-1\)</span>, resulting in</p>
<div class="math" id="eq-auto92">
\[\tag{185}
u(x) = 1 -x^2 + D + C(x-1),\]</div>
<p>We can form this <span class="math">\(u\)</span> in <code class="docutils literal"><span class="pre">sympy</span></code> and check that the differential equation
and the boundary conditions are satisfied:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi_i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">D</span><span class="o">*</span><span class="n">x</span>
<span class="k">print</span> <span class="s1">&#39;u:&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="k">print</span> <span class="s2">&quot;u&#39;&#39;:&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="k">print</span> <span class="s1">&#39;BC x=0:&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="k">print</span> <span class="s1">&#39;BC x=1:&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The output becomes</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>u: C*x - C + D - x**2 + 1
u&#39;&#39;: -2
BC x=0: C
BC x=1: D
</pre></div>
</div>
<p>The complete <code class="docutils literal"><span class="pre">sympy</span></code> code is found in <a class="reference external" href="http://tinyurl.com/znpudbt/u_xx_2_CD.py">u_xx_2_CD.py</a>.</p>
<p>The exact solution is found by integrating twice and applying the
boundary conditions, either by hand or using <code class="docutils literal"><span class="pre">sympy</span></code> as shown in
the section <a class="reference internal" href="#fem-deq-1d-models-simple"><span class="std std-ref">Simple model problems and their solutions</span></a>.  It appears that the numerical
solution coincides with the exact one.  This result is to be expected
because if <span class="math">\(({u_{\small\mbox{e}}} - B)\in V\)</span>, <span class="math">\(u = {u_{\small\mbox{e}}}\)</span>, as proved next.</p>
</div>
<div class="section" id="when-the-numerical-method-is-exact">
<h3>When the numerical method is exact<a class="headerlink" href="#when-the-numerical-method-is-exact" title="Permalink to this headline">¶</a></h3>
<p>We have some variational formulation: find <span class="math">\((u-B)\in V\)</span> such that
<span class="math">\(a(u,v)=L(u)\ \forall v\in V\)</span>. The exact solution also fulfills
<span class="math">\(a({u_{\small\mbox{e}}},v)=L(v)\)</span>, but normally <span class="math">\(({u_{\small\mbox{e}}} -B)\)</span> lies in a much larger
(infinite-dimensional) space. Suppose, nevertheless, that
<span class="math">\({u_{\small\mbox{e}}} - B = E\)</span>, where <span class="math">\(E\in V\)</span>. That is, apart from Dirichlet conditions,
<span class="math">\({u_{\small\mbox{e}}}\)</span> lies in our finite-dimensional space <span class="math">\(V\)</span> which we use to compute <span class="math">\(u\)</span>.
Writing also <span class="math">\(u\)</span> on the same form <span class="math">\(u=B+F\)</span>, <span class="math">\(F\in V\)</span>, we have</p>
<div class="math">
\[\begin{split}\begin{align*}
a(B+E,v) &amp;= L(v)\quad\forall v\in V,\\
a(B+F,v) &amp;= L(v)\quad\forall v\in V{\thinspace .}
\end{align*}\end{split}\]</div>
<p>Since these are two variational statements in the same space, we
can subtract them and use the bilinear property of <span class="math">\(a(\cdot,\cdot)\)</span>:</p>
<div class="math">
\[\begin{split}\begin{align*}
a(B+E,v) - a(B+F, v) &amp;= L(v) - L(v)\\
a(B+E-(B+F),v) &amp;= 0\\
a(E-F),v) &amp;= 0
\end{align*}\end{split}\]</div>
<p>If <span class="math">\(a(E-F),v) = 0\)</span> for all <span class="math">\(v\)</span> in <span class="math">\(V\)</span>, then <span class="math">\(E-F\)</span> must be zero everywhere
in the domain, i.e., <span class="math">\(E=F\)</span>. Or in other words: <span class="math">\(u={u_{\small\mbox{e}}}\)</span>. This proves
that the exact solution is recovered if <span class="math">\({u_{\small\mbox{e}}} - B\)</span> lies in <span class="math">\(V\)</span>., i.e.,
can be expressed as <span class="math">\(\sum_{j\in{\mathcal{I}_s}}d_j{\psi}_j\)</span> where <span class="math">\(\{{\psi}_j\}_{j\in{\mathcal{I}_s}}\)</span>
is a basis for <span class="math">\(V\)</span>. The method will then compute the solution <span class="math">\(c_j=d_j\)</span>,
<span class="math">\(j\in{\mathcal{I}_s}\)</span>.</p>
<p>The case treated in the section <a class="reference internal" href="#fem-deq-1d-varform-ex-dn-case"><span class="std std-ref">Computing with Dirichlet and Neumann conditions</span></a>
is of the type where <span class="math">\({u_{\small\mbox{e}}} - B\)</span> is a quadratic function that is 0
at <span class="math">\(x=1\)</span>, and therefore <span class="math">\(({u_{\small\mbox{e}}} -B)\in V\)</span>, and the method
finds the exact solution.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Variational formulations with global basis functions</a><ul>
<li><a class="reference internal" href="#basic-principles-for-approximating-differential-equations">Basic principles for approximating differential equations</a><ul>
<li><a class="reference internal" href="#differential-equation-models">Differential equation models</a></li>
<li><a class="reference internal" href="#simple-model-problems-and-their-solutions">Simple model problems and their solutions</a></li>
<li><a class="reference internal" href="#forming-the-residual">Forming the residual</a></li>
<li><a class="reference internal" href="#the-least-squares-method-4">The least squares method</a></li>
<li><a class="reference internal" href="#the-galerkin-method-1">The Galerkin method</a></li>
<li><a class="reference internal" href="#the-method-of-weighted-residuals">The method of weighted residuals</a></li>
<li><a class="reference internal" href="#test-and-trial-functions">Test and trial functions</a></li>
<li><a class="reference internal" href="#the-collocation-method-1">The collocation method</a><ul>
<li><a class="reference internal" href="#the-subdomain-collocation-method">The subdomain collocation method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-on-using-the-principles">Examples on using the principles</a><ul>
<li><a class="reference internal" href="#the-model-problem">The model problem</a></li>
<li><a class="reference internal" href="#basis-functions">Basis functions</a></li>
<li><a class="reference internal" href="#the-residual">The residual</a></li>
<li><a class="reference internal" href="#the-least-squares-method-5">The least squares method</a></li>
<li><a class="reference internal" href="#the-galerkin-method-2">The Galerkin method</a></li>
<li><a class="reference internal" href="#the-collocation-method-2">The collocation method</a></li>
<li><a class="reference internal" href="#comparison">Comparison</a></li>
</ul>
</li>
<li><a class="reference internal" href="#integration-by-parts-1">Integration by parts</a><ul>
<li><a class="reference internal" href="#weak-form">Weak form</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boundary-function-1">Boundary function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-with-global-polynomials">Computing with global polynomials</a><ul>
<li><a class="reference internal" href="#computing-with-dirichlet-and-neumann-conditions">Computing with Dirichlet and Neumann conditions</a></li>
<li><a class="reference internal" href="#when-the-numerical-method-is-exact">When the numerical method is exact</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book014.html"
                        title="previous chapter">Finite elements in 2D and 3D</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book016.html"
                        title="next chapter">Abstract notation for variational formulations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book015.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book016.html" title="Abstract notation for variational formulations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book014.html" title="Finite elements in 2D and 3D"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Kent-Andre Mardal. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>