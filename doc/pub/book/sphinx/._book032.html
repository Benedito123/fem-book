
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Exercises</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to Numerical Methods for Variational Problems" href="index.html" />
    <link rel="next" title="Uncertainty quantification and polynomial chaos expansions" href="._book033.html" />
    <link rel="prev" title="Multi-dimensional PDE problems" href="._book031.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book033.html" title="Uncertainty quantification and polynomial chaos expansions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book031.html" title="Multi-dimensional PDE problems"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="exercises-7">
<span id="nonlin-exer"></span><h1>Exercises<a class="headerlink" href="#exercises-7" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-41-determine-if-equations-are-nonlinear-or-not">
<span id="nonlin-exer-lin-vs-nonlin"></span><h2>Problem 41: Determine if equations are nonlinear or not<a class="headerlink" href="#problem-41-determine-if-equations-are-nonlinear-or-not" title="Permalink to this headline">¶</a></h2>
<p>Classify each term in the following equations as linear or nonlinear.
Assume that <span class="math">\(u\)</span>, <span class="math">\(\boldsymbol{u}\)</span>, and <span class="math">\(p\)</span> are unknown functions and that
all other symbols are known quantities.</p>
<ol class="arabic simple">
<li><span class="math">\(mu^{\prime\prime} + \beta |u^{\prime}|u^{\prime} + cu = F(t)\)</span></li>
<li><span class="math">\(u_t = {\alpha} u_{xx}\)</span></li>
<li><span class="math">\(u_{tt} = c^2\nabla^2 u\)</span></li>
<li><span class="math">\(u_t = \nabla\cdot({\alpha}(u)\nabla u) + f(x,y)\)</span></li>
<li><span class="math">\(u_t + f(u)_x = 0\)</span></li>
<li><span class="math">\(\boldsymbol{u}_t + \boldsymbol{u}\cdot\nabla \boldsymbol{u} = -\nabla p + r\nabla^2\boldsymbol{u}\)</span>, <span class="math">\(\nabla\cdot\boldsymbol{u} = 0\)</span>
(<span class="math">\(\boldsymbol{u}\)</span> is a vector field)</li>
<li><span class="math">\(u^{\prime} = f(u,t)\)</span></li>
<li><span class="math">\(\nabla^2 u = \lambda e^u\)</span></li>
</ol>
<p>Filename: <code class="docutils literal"><span class="pre">nonlinear_vs_linear</span></code>.</p>
</div>
<div class="section" id="exercise-42-derive-and-investigate-a-generalized-logistic-model">
<span id="nonlin-exer-logistic-gen"></span><h2>Exercise 42: Derive and investigate a generalized logistic model<a class="headerlink" href="#exercise-42-derive-and-investigate-a-generalized-logistic-model" title="Permalink to this headline">¶</a></h2>
<p>The logistic model for population growth is derived by assuming
a nonlinear growth rate,</p>
<div class="math" id="eq-nonlin-exer-logistic-gen-eq">
\[\tag{450}
u^{\prime} = a(u)u,\quad u(0)=I,\]</div>
<p>and the logistic model arises from the simplest possible choice of
<span class="math">\(a(u)\)</span>: <span class="math">\(r(u)=\varrho(1 - u/M)\)</span>, where <span class="math">\(M\)</span> is the maximum value of <span class="math">\(u\)</span> that
the environment can sustain, and <span class="math">\(\varrho\)</span> is the growth under
unlimited access to resources (as in the beginning when <span class="math">\(u\)</span> is small).
The idea is that <span class="math">\(a(u)\sim\varrho\)</span> when <span class="math">\(u\)</span> is small and that
<span class="math">\(a(t)\rightarrow 0\)</span> as <span class="math">\(u\rightarrow M\)</span>.</p>
<p>An <span class="math">\(a(u)\)</span> that generalizes the linear choice is the polynomial form</p>
<div class="math" id="eq-nonlin-exer-logistic-gen-r1">
\[\tag{451}
a(u) = \varrho(1-u/M)^p,\]</div>
<p>where <span class="math">\(p&gt;0\)</span> is some real number.</p>
<p><strong>a)</strong>
Formulate a Forward Euler, Backward Euler, and a Crank-Nicolson
scheme for <a class="reference internal" href="#eq-nonlin-exer-logistic-gen-eq"><span class="std std-ref">(450)</span></a>.</p>
<p><strong>Hint.</strong>
Use a geometric mean approximation in the Crank-Nicolson scheme:
<span class="math">\([a(u)u]^{n+1/2}\approx a(u^n)u^{n+1}\)</span>.</p>
<p><strong>b)</strong>
Formulate Picard and Newton iteration for the Backward Euler scheme in a).</p>
<p><strong>c)</strong>
Implement the numerical solution methods from a) and b).
Use <a class="reference external" href="http://tinyurl.com/znpudbt/logistic.py">logistic.py</a> to compare the case
<span class="math">\(p=1\)</span> and the choice <a class="reference internal" href="#eq-nonlin-exer-logistic-gen-r1"><span class="std std-ref">(451)</span></a>.</p>
<p><strong>d)</strong>
Implement unit tests that check the asymptotic limit of the solutions:
<span class="math">\(u\rightarrow M\)</span> as <span class="math">\(t\rightarrow\infty\)</span>.</p>
<p><strong>Hint.</strong>
You need to experiment to find what &#8220;infinite time&#8221; is
(increases substantially with <span class="math">\(p\)</span>) and what the
appropriate tolerance is for testing the asymptotic limit.</p>
<p><strong>e)</strong>
Perform experiments with Newton and Picard iteration for
the model <a class="reference internal" href="#eq-nonlin-exer-logistic-gen-r1"><span class="std std-ref">(451)</span></a>.
See how sensitive
the number of iterations is to <span class="math">\(\Delta t\)</span> and <span class="math">\(p\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">logistic_p</span></code>.</p>
</div>
<div class="section" id="problem-43-experience-the-behavior-of-newton-s-method">
<span id="nonlin-exer-newton-problems1"></span><h2>Problem 43: Experience the behavior of Newton&#8217;s method<a class="headerlink" href="#problem-43-experience-the-behavior-of-newton-s-method" title="Permalink to this headline">¶</a></h2>
<p>[<strong>kam 44</strong>: where do we find this demo]</p>
<p>The program <a class="reference external" href="http://tinyurl.com/znpudbt/Newton_demo.py">Newton_demo.py</a> illustrates
graphically each step in Newton&#8217;s method and is run like</p>
<p>[<strong>kam 45</strong>: where is this program?]</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python Newton_demo.py f dfdx x0 xmin xmax
</pre></div>
</div>
<p>Use this program to investigate potential
problems with Newton&#8217;s method when solving <span class="math">\(e^{-0.5x^2}\cos (\pi x)=0\)</span>.
Try a starting point <span class="math">\(x_0=0.8\)</span> and <span class="math">\(x_0=0.85\)</span> and watch the different
behavior. Just run</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt;  python Newton_demo.py &#39;0.2 + exp(-0.5*x**2)*cos(pi*x)&#39; \
           &#39;-x*exp(-x**2)*cos(pi*x) - pi*exp(-x**2)*sin(pi*x)&#39; \
           0.85 -3 3
</pre></div>
</div>
<p>and repeat with 0.85 replaced by 0.8.</p>
</div>
<div class="section" id="problem-44-compute-the-jacobian-of-a-system">
<span id="nonlin-exer-vib-jacobian"></span><h2>Problem 44: Compute the Jacobian of a <span class="math">\(2\times 2\)</span> system<a class="headerlink" href="#problem-44-compute-the-jacobian-of-a-system" title="Permalink to this headline">¶</a></h2>
<p>Write up the system <a class="reference internal" href="._book027.html#eq-nonlin-ode-generic-sys-pendulum-u0"><span class="std std-ref">(397)</span></a>-<a class="reference internal" href="._book027.html#eq-nonlin-ode-generic-sys-pendulum-u1"><span class="std std-ref">(398)</span></a> in the form <span class="math">\(F(u)=0\)</span>, <span class="math">\(F=(F_0,F_1)\)</span>, <span class="math">\(u=(u_0,u_1)\)</span>,
and compute the Jacobian <span class="math">\(J_{i,j}=\partial F_i/\partial u_j\)</span>.</p>
</div>
<div class="section" id="problem-45-solve-nonlinear-equations-arising-from-a-vibration-ode">
<span id="nonlin-exer-vib-geometric-mean"></span><h2>Problem 45: Solve nonlinear equations arising from a vibration ODE<a class="headerlink" href="#problem-45-solve-nonlinear-equations-arising-from-a-vibration-ode" title="Permalink to this headline">¶</a></h2>
<p>Consider a nonlinear vibration problem</p>
<div class="math" id="eq-auto186">
\[\tag{452}
mu^{\prime\prime} + bu^{\prime}|u^{\prime}| + s(u) = F(t),\]</div>
<p>where <span class="math">\(m&gt;0\)</span> is a constant, <span class="math">\(b\geq 0\)</span> is a constant, <span class="math">\(s(u)\)</span> a possibly
nonlinear function of <span class="math">\(u\)</span>, and <span class="math">\(F(t)\)</span> is a prescribed function. Such
models arise from Newton&#8217;s second law of motion in mechanical
vibration problems where <span class="math">\(s(u)\)</span> is a spring or restoring force,
<span class="math">\(mu^{\prime\prime}\)</span> is mass times acceleration, and
<span class="math">\(bu^{\prime}|u^{\prime}|\)</span> models water or air drag.</p>
<p><strong>a)</strong>
Rewrite the equation for <span class="math">\(u\)</span> as a system of two first-order ODEs, and
discretize this system by a Crank-Nicolson (centered difference)
method. With <span class="math">\(v=u^\prime\)</span>, we get a nonlinear term
<span class="math">\(v^{n+\frac{1}{2}}|v^{n+\frac{1}{2}}|\)</span>. Use a geometric
average for <span class="math">\(v^{n+\frac{1}{2}}\)</span>.</p>
<p><strong>b)</strong>
Formulate a Picard iteration method to solve the system of nonlinear
algebraic equations.</p>
<p><strong>c)</strong>
Explain how to apply Newton&#8217;s method to solve the nonlinear equations
at each time level. Derive expressions for the Jacobian and the
right-hand side in each Newton iteration.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_vib</span></code>.</p>
</div>
<div class="section" id="exercise-46-find-the-truncation-error-of-arithmetic-mean-of-products">
<span id="nonlin-exer-products-arith-mean"></span><h2>Exercise 46: Find the truncation error of arithmetic mean of products<a class="headerlink" href="#exercise-46-find-the-truncation-error-of-arithmetic-mean-of-products" title="Permalink to this headline">¶</a></h2>
<p>In the section <a class="reference internal" href="._book029.html#nonlin-pdelevel-picard-cn"><span class="std std-ref">Crank-Nicolson discretization</span></a> we introduce alternative
arithmetic means of a product. Say the product is <span class="math">\(P(t)Q(t)\)</span> evaluated
at <span class="math">\(t=t_{n+\frac{1}{2}}\)</span>. The exact value is</p>
<div class="math">
\[[PQ]^{n+\frac{1}{2}} = P^{n+\frac{1}{2}}Q^{n+\frac{1}{2}}\]</div>
<p>There are two obvious candidates for evaluating <span class="math">\([PQ]^{n+\frac{1}{2}}\)</span>
as a mean of values of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> at <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>. Either
we can take the arithmetic mean of each factor <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>,</p>
<div class="math" id="eq-nonlin-exer-products-arith-mean-f">
\[\tag{453}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^n + P^{n+1})\frac{1}{2}(Q^n + Q^{n+1}),\]</div>
<p>or we can take the arithmetic mean of the product <span class="math">\(PQ\)</span>:</p>
<div class="math" id="eq-nonlin-exer-products-arith-mean-p">
\[\tag{454}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^nQ^n + P^{n+1}Q^{n+1}){\thinspace .}\]</div>
<p>The arithmetic average
of <span class="math">\(P(t_{n+\frac{1}{2}})\)</span> is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>:</p>
<div class="math">
\[P(t_{n+\frac{1}{2}}) = \frac{1}{2}(P^n + P^{n+1}) +{\mathcal{O}(\Delta t^2)}{\thinspace .}\]</div>
<p>A fundamental question is whether <a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-f"><span class="std std-ref">(453)</span></a>
and <a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-p"><span class="std std-ref">(454)</span></a> have different
orders of accuracy in <span class="math">\(\Delta t = t_{n+1}-t_n\)</span>. To investigate
this question, expand quantities at <span class="math">\(t_{n+1}\)</span> and <span class="math">\(t_n\)</span> in
Taylor series around <span class="math">\(t_{n+\frac{1}{2}}\)</span>, and subtract the true
value <span class="math">\([PQ]^{n+\frac{1}{2}}\)</span> from the approximations
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-f"><span class="std std-ref">(453)</span></a> and
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-p"><span class="std std-ref">(454)</span></a> to see what the
order of the error terms are.</p>
<p><strong>Hint.</strong>
You may explore <code class="docutils literal"><span class="pre">sympy</span></code> for carrying out the tedious calculations.
A general Taylor series expansion of <span class="math">\(P(t+\frac{1}{2}\Delta t)\)</span> around <span class="math">\(t\)</span>
involving just a general function <span class="math">\(P(t)\)</span> can be
created as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t dt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">P(0) + t*Subs(Derivative(P(_x), _x), (_x,), (0,)) +</span>
<span class="go">t**2*Subs(Derivative(P(_x), _x, _x), (_x,), (0,))/2 +</span>
<span class="go">t**3*Subs(Derivative(P(_x), _x, _x, _x), (_x,), (0,))/6 + O(t**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P_p</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P_p</span>
<span class="go">P(0) + dt*Subs(Derivative(P(_x), _x), (_x,), (0,))/2 +</span>
<span class="go">dt**2*Subs(Derivative(P(_x), _x, _x), (_x,), (0,))/8 +</span>
<span class="go">dt**3*Subs(Derivative(P(_x), _x, _x, _x), (_x,), (0,))/48 + O(dt**4)</span>
</pre></div>
</div>
<p>The error of the arithmetic mean, <span class="math">\(\frac{1}{2}(P(-\frac{1}{2}\Delta t)
+ P(-\frac{1}{2}\Delta t))\)</span> for <span class="math">\(t=0\)</span> is then</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P_m</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">P_m</span> <span class="o">+</span> <span class="n">P_p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span>
<span class="go">dt**2*Subs(Derivative(P(_x), _x, _x), (_x,), (0,))/8 + O(dt**4)</span>
</pre></div>
</div>
<p>Use these examples to investigate the error of
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-f"><span class="std std-ref">(453)</span></a> and
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-p"><span class="std std-ref">(454)</span></a> for <span class="math">\(n=0\)</span>. (Choosing <span class="math">\(n=0\)</span>
is necessary for not making the expressions too complicated for <code class="docutils literal"><span class="pre">sympy</span></code>,
but there is of course no lack of generality by using <span class="math">\(n=0\)</span> rather
than an arbitrary <span class="math">\(n\)</span> - the main point is the product and addition
of Taylor series.)</p>
<p>Filename: <code class="docutils literal"><span class="pre">product_arith_mean</span></code>.</p>
</div>
<div class="section" id="problem-47-newton-s-method-for-linear-problems">
<span id="nonlin-exer-newton-linear"></span><h2>Problem 47: Newton&#8217;s method for linear problems<a class="headerlink" href="#problem-47-newton-s-method-for-linear-problems" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a linear system <span class="math">\(F(u) = Au- b=0\)</span>. Apply Newton&#8217;s method
to this system, and show that the method converges in one iteration.
Filename: <code class="docutils literal"><span class="pre">Newton_linear</span></code>.</p>
</div>
<div class="section" id="exercise-48-discretize-a-1d-problem-with-a-nonlinear-coefficient">
<span id="nonlin-exer-1d-1pu2-fem"></span><h2>Exercise 48: Discretize a 1D problem with a nonlinear coefficient<a class="headerlink" href="#exercise-48-discretize-a-1d-problem-with-a-nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>We consider the problem</p>
<div class="math" id="eq-nonlin-exer-1d-1pu2-fem-pde">
\[\tag{455}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0{\thinspace .}\]</div>
<p>Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-fem-pde"><span class="std std-ref">(455)</span></a> by a centered
finite difference method on a uniform mesh.
Filename: <code class="docutils literal"><span class="pre">nonlin_1D_coeff_discretize</span></code>.</p>
</div>
<div class="section" id="exercise-49-linearize-a-1d-problem-with-a-nonlinear-coefficient">
<span id="nonlin-exer-1d-1pu2-picardnewton"></span><h2>Exercise 49: Linearize a 1D problem with a nonlinear coefficient<a class="headerlink" href="#exercise-49-linearize-a-1d-problem-with-a-nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>We have a two-point boundary value problem</p>
<div class="math" id="eq-nonlin-exer-1d-1pu2-picardnewton-pde">
\[\tag{456}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0{\thinspace .}\]</div>
<p><strong>a)</strong>
Construct a Picard iteration method for <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(456)</span></a>
without discretizing in space.</p>
<p><strong>b)</strong>
Apply Newton&#8217;s method to <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(456)</span></a>
without discretizing in space.</p>
<p><strong>c)</strong>
Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(456)</span></a> by a centered finite
difference scheme. Construct a Picard method for the resulting
system of nonlinear algebraic equations.</p>
<p><strong>d)</strong>
Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(456)</span></a> by a centered finite
difference scheme. Define the system of nonlinear algebraic equations,
calculate the Jacobian, and set up Newton&#8217;s method for solving the system.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_1D_coeff_linearize</span></code>.</p>
</div>
<div class="section" id="problem-50-finite-differences-for-the-1d-bratu-problem">
<span id="nonlin-exer-1d-fu-discretize-fd"></span><h2>Problem 50: Finite differences for the 1D Bratu problem<a class="headerlink" href="#problem-50-finite-differences-for-the-1d-bratu-problem" title="Permalink to this headline">¶</a></h2>
<p>We address the so-called Bratu problem</p>
<div class="math" id="eq-nonlin-exer-1d-fu-discretize-fd-pde">
\[\tag{457}
u^{\prime\prime} + \lambda e^u=0,\quad x\in (0,1),\quad u(0)=u(1)=0,\]</div>
<p>where <span class="math">\(\lambda\)</span> is a given parameter and <span class="math">\(u\)</span> is a function of <span class="math">\(x\)</span>.
This is a widely used model problem for studying numerical
methods for nonlinear differential equations.
The problem <a class="reference internal" href="#eq-nonlin-exer-1d-fu-discretize-fd-pde"><span class="std std-ref">(457)</span></a> has an
exact solution</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x) = -2\ln\left(\frac{\cosh((x-\frac{1}{2})\theta/2)}{\cosh(\theta/4)}\right),\]</div>
<p>where <span class="math">\(\theta\)</span> solves</p>
<div class="math">
\[\theta = \sqrt{2\lambda}\cosh(\theta/4){\thinspace .}\]</div>
<p>There are two solutions of <a class="reference internal" href="#eq-nonlin-exer-1d-fu-discretize-fd-pde"><span class="std std-ref">(457)</span></a> for
<span class="math">\(0&lt;\lambda &lt;\lambda_c\)</span> and no solution for <span class="math">\(\lambda &gt;\lambda_c\)</span>.
For <span class="math">\(\lambda = \lambda_c\)</span> there is one unique solution. The critical
value <span class="math">\(\lambda_c\)</span> solves</p>
<div class="math">
\[1 = \sqrt{2\lambda_c}\frac{1}{4}\sinh(\theta(\lambda_c)/4){\thinspace .}\]</div>
<p>A numerical value is <span class="math">\(\lambda_c = 3.513830719\)</span>.</p>
<p><strong>a)</strong>
Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-fu-discretize-fd-pde"><span class="std std-ref">(457)</span></a> by a
centered finite difference method.</p>
<p><strong>b)</strong>
Set up the nonlinear equations <span class="math">\(F_i(u_0,u_1,\ldots,u_{N_x})=0\)</span>
from a). Calculate the associated Jacobian.</p>
<p><strong>c)</strong>
Implement a solver that can compute <span class="math">\(u(x)\)</span> using Newton&#8217;s method.
Plot the error as a function of <span class="math">\(x\)</span> in each iteration.</p>
<p><strong>d)</strong>
Investigate whether Newton&#8217;s method gives second-order convergence
by computing
<span class="math">\(|| {u_{\small\mbox{e}}} - u||/||{u_{\small\mbox{e}}} - u^{-}||^2\)</span>
in each iteration, where <span class="math">\(u\)</span> is solution in the current iteration and
<span class="math">\(u^{-}\)</span> is the solution in the previous iteration.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_1D_Bratu_fd</span></code>.</p>
</div>
<div class="section" id="exercise-51-discretize-a-nonlinear-1d-heat-conduction-pde-by-finite-differences">
<span id="nonlin-exer-1d-heat-nonlinear-fdm"></span><h2>Exercise 51: Discretize a nonlinear 1D heat conduction PDE by finite differences<a class="headerlink" href="#exercise-51-discretize-a-nonlinear-1d-heat-conduction-pde-by-finite-differences" title="Permalink to this headline">¶</a></h2>
<p>We address the 1D heat conduction PDE</p>
<div class="math">
\[\varrho c(T) T_t = (k(T)T_x)_x,\]</div>
<p>for <span class="math">\(x\in [0,L]\)</span>,
where <span class="math">\(\varrho\)</span> is the density of the solid material, <span class="math">\(c(T)\)</span> is
the heat capacity, <span class="math">\(T\)</span> is the temperature, and <span class="math">\(k(T)\)</span> is the
heat conduction coefficient. <span class="math">\(T(x,0)=I(x)\)</span>, and ends are
subject to a cooling law:</p>
<div class="math">
\[k(T)T_x|_{x=0} = h(T)(T-T_s),\quad -k(T)T_x|_{x=L}=h(T)(T-T_s),\]</div>
<p>where <span class="math">\(h(T)\)</span> is a heat transfer coefficient and <span class="math">\(T_s\)</span> is the
given surrounding temperature.</p>
<p><strong>a)</strong>
Discretize this PDE in time using either a
Backward Euler or Crank-Nicolson scheme.</p>
<p><strong>b)</strong>
Formulate a Picard iteration method for the time-discrete problem
(i.e., an iteration method before discretizing in space).</p>
<p><strong>c)</strong>
Formulate a Newton method for the time-discrete problem in b).</p>
<p><strong>d)</strong>
Discretize the PDE by a finite difference method in space.
Derive the matrix and right-hand side of a Picard iteration method applied
to the space-time discretized PDE.</p>
<p><strong>e)</strong>
Derive the matrix and right-hand side of a Newton method applied
to the discretized PDE in d).</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_1D_heat_FD</span></code>.</p>
</div>
<div class="section" id="exercise-52-differentiate-a-highly-nonlinear-term">
<span id="nonlin-exer-grad-pow-term"></span><h2>Exercise 52: Differentiate a highly nonlinear term<a class="headerlink" href="#exercise-52-differentiate-a-highly-nonlinear-term" title="Permalink to this headline">¶</a></h2>
<p>The operator <span class="math">\(\nabla\cdot({\alpha}(u)\nabla u)\)</span> with
<span class="math">\({\alpha}(u) = |\nabla u|^q\)</span> appears in several physical problems,
especially flow of Non-Newtonian fluids. The expression <span class="math">\(|\nabla u|\)</span>
is defined as the Euclidean norm of a vector:
<span class="math">\(|\nabla u|^2 = \nabla u \cdot \nabla u\)</span>.
In a Newton method one
has to carry out the differentiation <span class="math">\(\partial{\alpha}(u)/\partial c_j\)</span>,
for <span class="math">\(u=\sum_kc_k{\psi}_k\)</span>. Show that</p>
<div class="math">
\[{\partial\over\partial u_j} |\nabla u|^q =
q|\nabla  u|^{q-2}\nabla u\cdot
\nabla{\psi}_j{\thinspace .}\]</div>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_differentiate</span></code>.</p>
</div>
<div class="section" id="exercise-53-crank-nicolson-for-a-nonlinear-3d-diffusion-equation">
<span id="nonlin-exer-2d-heat-nonlinear-fd"></span><h2>Exercise 53: Crank-Nicolson for a nonlinear 3D diffusion equation<a class="headerlink" href="#exercise-53-crank-nicolson-for-a-nonlinear-3d-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>Redo the section <a class="reference internal" href="._book031.html#nonlin-alglevel-dd-fd"><span class="std std-ref">Finite difference discretization</span></a> when a Crank-Nicolson scheme
is used to discretize the equations in time and the problem is
formulated for three spatial dimensions.</p>
<p><strong>Hint.</strong>
Express the Jacobian as <span class="math">\(J_{i,j,k,r,s,t} = \partial F_{i,j,k}/\partial u_{r,s,t}\)</span> and observe, as in the 2D case, that <span class="math">\(J_{i,j,k,r,s,t}\)</span> is very sparse:
<span class="math">\(J_{i,j,k,r,s,t}\neq 0\)</span> only for <span class="math">\(r=i\pm i\)</span>, <span class="math">\(s=j\pm 1\)</span>, and <span class="math">\(t=k\pm 1\)</span>
as well as <span class="math">\(r=i\)</span>, <span class="math">\(s=j\)</span>, and <span class="math">\(t=k\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_heat_FD_CN_2D</span></code>.</p>
</div>
<div class="section" id="exercise-54-find-the-sparsity-of-the-jacobian">
<span id="nonlin-exer-sparsity-jacobian"></span><h2>Exercise 54: Find the sparsity of the Jacobian<a class="headerlink" href="#exercise-54-find-the-sparsity-of-the-jacobian" title="Permalink to this headline">¶</a></h2>
<p>Consider a typical nonlinear Laplace term like
<span class="math">\(\nabla\cdot{\alpha}(u)\nabla u\)</span> discretized by centered finite differences.
Explain why the Jacobian corresponding to this term has the same
sparsity pattern as the matrix associated with the corresponding linear
term <span class="math">\({\alpha}\nabla^2 u\)</span>.</p>
<p><strong>Hint.</strong>
Set up the unknowns that enter the difference equation at a
point <span class="math">\((i,j)\)</span> in 2D or <span class="math">\((i,j,k)\)</span> in 3D, and identify the
nonzero entries of the Jacobian that can arise from such a type
of difference equation.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_sparsity_Jacobian</span></code>.</p>
</div>
<div class="section" id="problem-55-investigate-a-1d-problem-with-a-continuation-method">
<span id="nonlin-exer-continuation-1dnnflow"></span><h2>Problem 55: Investigate a 1D problem with a continuation method<a class="headerlink" href="#problem-55-investigate-a-1d-problem-with-a-continuation-method" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Flow of a pseudo-plastic power-law fluid between two flat plates can be
modeled by</p>
<div class="math">
\[\frac{d}{dx}\left(\mu_0\left\vert\frac{du}{dx}\right\vert^{n-1}
\frac{du}{dx}\right) = -\beta,\quad u^{\prime}(0)=0,\ u(H) = 0,\]</div>
<p>where <span class="math">\(\beta&gt;0\)</span> and <span class="math">\(\mu_0&gt;0\)</span> are constants.
A target value of <span class="math">\(n\)</span> may be <span class="math">\(n=0.2\)</span>.</p>
<p><strong>a)</strong>
Formulate a Picard iteration method directly for the differential
equation problem.</p>
<p><strong>b)</strong>
Perform a finite difference discretization of the problem in
each Picard iteration. Implement a solver that can compute <span class="math">\(u\)</span>
on a mesh. Verify that the solver gives an exact solution for <span class="math">\(n=1\)</span>
on a uniform mesh regardless of the cell size.</p>
<p><strong>c)</strong>
Given a sequence of decreasing <span class="math">\(n\)</span> values, solve the problem for each
<span class="math">\(n\)</span> using the solution for the previous <span class="math">\(n\)</span> as initial guess for
the Picard iteration. This is called a continuation method.
Experiment with <span class="math">\(n=(1,0.6,0.2)\)</span> and <span class="math">\(n=(1,0.9,0.8,\ldots,0.2)\)</span>
and make a table of the number of Picard iterations versus <span class="math">\(n\)</span>.</p>
<p><strong>d)</strong>
Derive a Newton method at the differential equation level and
discretize the resulting linear equations in each Newton iteration
with the finite difference method.</p>
<p><strong>e)</strong>
Investigate if Newton&#8217;s method has better convergence properties than
Picard iteration, both in combination with a continuation method.</p>
</div>
</div>
<div class="section" id="symbolic-nonlinear-finite-element-equations">
<span id="nonlin-app-fem-vs-fdm"></span><h1>Symbolic nonlinear finite element equations<a class="headerlink" href="#symbolic-nonlinear-finite-element-equations" title="Permalink to this headline">¶</a></h1>
<p>The integrals in nonlinear finite element equations are computed
by numerical integration rules in computer programs, so the
formulas for the variational form is directly transferred to numbers.
It is of interest to understand the nature of the system of difference equations
that arises from the finite element method in nonlinear problems and
to compare with corresponding expressions arising from finite difference
discretization. We shall dive into this problem here. To see the
structure of the difference equations implied by the finite element method,
we have to find symbolic expressions for the integrals, and this is
extremely difficult since the integrals involve the unknown function
in nonlinear problems. However, there are some techniques that allow
us to approximate the integrals and work out symbolic formulas that
can compared with their finite difference counterparts.</p>
<p>We shall address the 1D model problem <a class="reference internal" href="._book030.html#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(429)</span></a> from
the beginning of the section <a class="reference internal" href="._book030.html#nonlin-alglevel-1d"><span class="std std-ref">1D stationary nonlinear differential equations</span></a>.
The finite difference discretization is shown in the section <a class="reference internal" href="._book030.html#nonlin-alglevel-1d-fd"><span class="std std-ref">Finite difference discretization</span></a>, while the variational form based on
Galerkin&#8217;s method is developed in the section <span class="xref std std-ref">nonlin:alglevel:1D:fe</span>.
We build directly on formulas developed in the latter section.</p>
<div class="section" id="finite-element-basis-functions-3">
<span id="nonlin-alglevel-1d-fe-basis"></span><h2>Finite element basis functions<a class="headerlink" href="#finite-element-basis-functions-3" title="Permalink to this headline">¶</a></h2>
<p>Introduction of finite element basis functions <span class="math">\({\varphi}_i\)</span> means setting</p>
<div class="math">
\[{\psi}_i = {\varphi}_{\nu(i)},\quad i\in{\mathcal{I}_s},\]</div>
<p>where degree of freedom number <span class="math">\(\nu(i)\)</span> in the mesh corresponds to
unknown number <span class="math">\(i\)</span> (<span class="math">\(c_i\)</span>).
In the present example, we use all the basis functions except the
last at <span class="math">\(i=N_n-1\)</span>, i.e., <span class="math">\({\mathcal{I}_s} = \{0,\ldots,N_n-2\}\)</span>, and <span class="math">\(\nu(j)=j\)</span>.
The expansion of <span class="math">\(u\)</span> can be taken as</p>
<div class="math">
\[u = D + \sum_{j\in{\mathcal{I}_s}} c_j{\varphi}_{\nu(j)},\]</div>
<p>but it is more common in a finite element context to use a boundary
function <span class="math">\(B=\sum_{j\in{I_b}}U_j{\varphi}_j\)</span>, where <span class="math">\(U_j\)</span> are prescribed
Dirichlet conditions for degree of freedom number <span class="math">\(j\)</span> and <span class="math">\(U_j\)</span> is
the corresponding value.</p>
<div class="math">
\[u = D{\varphi}_{N_n-1} + \sum_{j\in{\mathcal{I}_s}} c_j{\varphi}_{\nu(j)}{\thinspace .}\]</div>
<p>In the general case with <span class="math">\(u\)</span> prescribed as <span class="math">\(U_j\)</span> at some nodes <span class="math">\(j\in{I_b}\)</span>,
we set</p>
<div class="math">
\[u = \sum_{j\in{I_b}} U_j{\varphi}_j +
\sum_{j\in{\mathcal{I}_s}}c_j{\varphi}_{\nu(j)},\]</div>
<p>where <span class="math">\(c_j = u(x^{\nu(j)})\)</span>. That is, <span class="math">\(\nu(j)\)</span> maps unknown number <span class="math">\(j\)</span> to
the corresponding node number <span class="math">\(\nu(j)\)</span> such that <span class="math">\(c_j = u(x^{\nu(j)})\)</span>.</p>
</div>
<div class="section" id="the-group-finite-element-method">
<span id="nonlin-alglevel-1d-fe-group"></span><h2>The group finite element method<a class="headerlink" href="#the-group-finite-element-method" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finite-element-approximation-of-functions-of">
<h3>Finite element approximation of functions of <span class="math">\(u\)</span><a class="headerlink" href="#finite-element-approximation-of-functions-of" title="Permalink to this headline">¶</a></h3>
<p>Since we already expand <span class="math">\(u\)</span> as <span class="math">\(\sum_j{\varphi}_j u(x_{j})\)</span>, we may use the
same approximation for other functions as well. For example,</p>
<div class="math">
\[f(u)\approx \sum_{j} f(x_{j}){\varphi}_j,\]</div>
<p>where <span class="math">\(f(x_{j})\)</span> is the value of <span class="math">\(f\)</span> at node <span class="math">\(j\)</span>. Since <span class="math">\(f\)</span> is a function
of <span class="math">\(u\)</span>, <span class="math">\(f(x_{j})=f(u(x_{j}))\)</span>. Introducing
<span class="math">\(u_j\)</span> as a short form for <span class="math">\(u(x_{j})\)</span>, we can write</p>
<div class="math">
\[f(u)\approx \sum_{j} f(u_{j}){\varphi}_j{\thinspace .}\]</div>
<p>This approximation is known as the <em>group finite element method</em>
or the <em>product approximation</em> technique. The index <span class="math">\(j\)</span> runs over
all node numbers in the mesh.</p>
<p>The principal advantages of the group finite element method are two-fold:</p>
<ol class="arabic simple">
<li>Complicated nonlinear expressions can be simplified to increase
the efficiency of numerical computations.</li>
<li>One can derive <em>symbolic forms</em> of the difference equations arising
from the finite element method in nonlinear problems.
The symbolic form is useful for comparing finite element and finite
difference equations of nonlinear differential equation problems.</li>
</ol>
<p>Below, we shall explore point 2 to see exactly how the finite element
method creates more complex expressions in the resulting
linear system (the difference equations) that the finite difference
method does. It turns out that is very difficult to see
what kind of terms in the difference equations that arise from
<span class="math">\(\int f(u){\varphi}_i{\, \mathrm{d}x}\)</span> without using the group finite element
method or numerical integration utilizing the nodes only.</p>
<p>Note, however, that an expression like <span class="math">\(\int f(u){\varphi}_i{\, \mathrm{d}x}\)</span> causes
no problems in a computer program as the integral is calculated by
numerical integration using an existing approximation of <span class="math">\(u\)</span> in
<span class="math">\(f(u)\)</span> such that the integrand can be sampled at any spatial point.</p>
</div>
<div class="section" id="simplified-problem">
<h3>Simplified problem<a class="headerlink" href="#simplified-problem" title="Permalink to this headline">¶</a></h3>
<p>Our aim now is to derive symbolic expressions for the difference
equations arising from the finite element method in nonlinear
problems and compare the expressions with those arising in the
finite difference method. To this end,
let us simplify the model problem and set <span class="math">\(a=0\)</span>, <span class="math">\({\alpha}=1\)</span>,
<span class="math">\(f(u)=u^2\)</span>, and have Neumann conditions at both ends such that we
get a very simple nonlinear problem <span class="math">\(-u^{\prime\prime}=u^2\)</span>,
<span class="math">\(u'(0)=1\)</span>, <span class="math">\(u'(L)=0\)</span>.
The variational form is then</p>
<div class="math">
\[\int_0^L u^{\prime}v^{\prime}{\, \mathrm{d}x} = \int_0^L u^2v{\, \mathrm{d}x}
- v(0),\quad\forall v\in V{\thinspace .}\]</div>
<p>The term with <span class="math">\(u^{\prime}v^{\prime}\)</span> is well known so the only new feature is
the term <span class="math">\(\int u^2v{\, \mathrm{d}x}\)</span>.</p>
<p>To make the distance from finite element equations to finite
difference equations as short as possible, we shall substitute <span class="math">\(c_j\)</span>
in the sum <span class="math">\(u=\sum_jc_j{\varphi}_j\)</span> by <span class="math">\(u_j=u(x_{j})\)</span> since <span class="math">\(c_j\)</span> is
the value of <span class="math">\(u\)</span> at node <span class="math">\(j\)</span>. (In the more general case
with Dirichlet conditions as well, we have a sum
<span class="math">\(\sum_jc_j{\varphi}_{\nu(j)}\)</span> where <span class="math">\(c_j\)</span> is replaced by <span class="math">\(u(x_{\nu(j)})\)</span>.
We can then introduce some other counter <span class="math">\(k\)</span> such that it is
meaningful to write <span class="math">\(u=\sum_k u_k{\varphi}_k\)</span>, where <span class="math">\(k\)</span> runs over appropriate
node numbers.)
The quantity <span class="math">\(u_j\)</span> in <span class="math">\(\sum_ju_j{\varphi}_j\)</span>
is the same as <span class="math">\(u\)</span> at mesh point number <span class="math">\(j\)</span>
in the finite difference method, which is commonly denoted <span class="math">\(u_j\)</span>.</p>
</div>
<div class="section" id="integrating-nonlinear-functions">
<h3>Integrating nonlinear functions<a class="headerlink" href="#integrating-nonlinear-functions" title="Permalink to this headline">¶</a></h3>
<p>Consider the term <span class="math">\(\int u^2v{\, \mathrm{d}x}\)</span> in the variational formulation
with <span class="math">\(v={\varphi}_i\)</span> and <span class="math">\(u=\sum_k{\varphi}_ku_k\)</span>:</p>
<div class="math">
\[\int_0^L (\sum_ku_k{\varphi}_k)^2{\varphi}_i{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Evaluating this integral for P1 elements (see <span class="xref std std-ref">nonlin:exer:fu:fem:int</span>) results in the expression</p>
<div class="math">
\[\frac{h}{12}(u_{i-1}^2 + 2u_i(u_{i-1} + u_{i+1}) + 6u_i^2
+ u_{i+1}^2),\]</div>
<p>to be compared with the simple value <span class="math">\(u_i^2\)</span> that would arise in
a finite difference discretization when <span class="math">\(u^2\)</span> is sampled at
mesh point <span class="math">\(x_i\)</span>. More complicated <span class="math">\(f(u)\)</span> functions
in the integral <span class="math">\(\int_0^L f(u){\varphi}_i{\, \mathrm{d}x}\)</span>
give rise to much more lengthy expressions, if it is possible to
carry out the integral symbolically at all.</p>
<span class="target" id="index-1"></span></div>
<div class="section" id="application-of-the-group-finite-element-method">
<span id="index-2"></span><h3>Application of the group finite element method<a class="headerlink" href="#application-of-the-group-finite-element-method" title="Permalink to this headline">¶</a></h3>
<p>Let us use the group finite element method to derive the terms in
the difference equation corresponding to <span class="math">\(f(u)\)</span> in the differential
equation. We have</p>
<div class="math">
\[\int_0^L f(u){\varphi}_i{\, \mathrm{d}x} \approx
\int_0^L (\sum_j {\varphi}_jf(u_j)){\varphi}_i{\, \mathrm{d}x}
= \sum_j \left(\int_0^L {\varphi}_i{\varphi}_j{\, \mathrm{d}x}\right) f(u_j){\thinspace .}\]</div>
<p>We recognize this expression as the mass matrix <span class="math">\(M\)</span>, arising from
<span class="math">\(\int{\varphi}_i{\varphi}_j{\, \mathrm{d}x}\)</span>, times the
vector <span class="math">\(f=(f(u_0),f(u_1),\ldots,)\)</span>: <span class="math">\(Mf\)</span>. The associated terms
in the difference equations are, for P1 elements,</p>
<div class="math">
\[\frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1})){\thinspace .}\]</div>
<p>Occasionally, we want to interpret this expression in terms of finite
differences, and to this end a rewrite of this expression is convenient:</p>
<div class="math">
\[\frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1}))
= h[f(u) - \frac{h^2}{6}D_xD_x f(u)]_i{\thinspace .}\]</div>
<p>That is, the finite element treatment of <span class="math">\(f(u)\)</span> (when using a group
finite element method) gives the same term as in a finite difference
approach, <span class="math">\(f(u_i)\)</span>, minus a diffusion term which is the
2nd-order discretization of <span class="math">\(\frac{1}{6}h^2f''(x_i)\)</span>.</p>
<p>We may lump the mass matrix through integration with the Trapezoidal
rule so that <span class="math">\(M\)</span> becomes diagonal in the finite element method.
In that case the <span class="math">\(f(u)\)</span> term in the differential equation
gives rise to a single term <span class="math">\(hf(u_i)\)</span>, just as in the finite difference
method.</p>
</div>
</div>
<div class="section" id="numerical-integration-of-nonlinear-terms-by-hand">
<span id="nonlin-alglevel-1d-fe-f"></span><h2>Numerical integration of nonlinear terms by hand<a class="headerlink" href="#numerical-integration-of-nonlinear-terms-by-hand" title="Permalink to this headline">¶</a></h2>
<p>Let us reconsider a term <span class="math">\(\int f(u)v{\, \mathrm{d}x}\)</span> as treated in the previous
section, but now we want to integrate this term numerically.
Such an approach can lead to easy-to-interpret formulas if we apply
a numerical integration rule that samples the integrand at the node
points <span class="math">\(x_{i}\)</span> only, because at such points, <span class="math">\({\varphi}_j(x_{i})=0\)</span>
if <span class="math">\(j\neq i\)</span>, which leads to great simplifications.</p>
<p>The term in question takes the form</p>
<div class="math">
\[\int_0^L f(\sum_k u_k{\varphi}_k){\varphi}_i{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Evaluation of the integrand at a node <span class="math">\(x_{\ell}\)</span> leads to a
collapse of the sum <span class="math">\(\sum_k u_k{\varphi}_k\)</span> to one term because</p>
<div class="math">
\[\sum_k u_k{\varphi}_k(x_{\ell}) = u_\ell{\thinspace .}\]</div>
<div class="math">
\[f(\sum_k u_k\underbrace{{\varphi}_k(x_{\ell})}_{\delta_{k\ell}})
\underbrace{{\varphi}_i(x_{\ell})}_{\delta_{i\ell}}
= f(u_\ell)\delta_{i\ell},\]</div>
<p>where we have used the Kronecker delta: <span class="math">\(\delta_{ij}=0\)</span> if <span class="math">\(i\neq j\)</span> and
<span class="math">\(\delta_{ij}=1\)</span> if <span class="math">\(i=j\)</span>.</p>
<p>Considering the Trapezoidal rule for integration, where the integration
points are the nodes, we have</p>
<div class="math">
\[\int_0^L f(\sum_k u_k{\varphi}_k(x)){\varphi}_i(x){\, \mathrm{d}x}
\approx h\sum_{\ell=0}^{N_n} f(u_\ell)\delta_{i\ell} - \mathcal{C}
= hf(u_i){\thinspace .}\]</div>
<p>This is the same representation of the <span class="math">\(f\)</span> term as in the finite
difference method.
The term <span class="math">\(\mathcal{C}\)</span> contains the evaluations of the integrand
at the ends with weight <span class="math">\(\frac{1}{2}\)</span>, needed to make a true Trapezoidal rule:</p>
<div class="math">
\[\mathcal{C} = \frac{h}{2}f(u_0){\varphi}_i(0) + \frac{h}{2}f(u_{N_n-1}){\varphi}_i(L){\thinspace .}\]</div>
<p>The answer <span class="math">\(hf(u_i)\)</span> must therefore be multiplied by <span class="math">\(\frac{1}{2}\)</span> if
<span class="math">\(i=0\)</span> or <span class="math">\(i=N_n-1\)</span>. Note that <span class="math">\(\mathcal{C}=0\)</span> for <span class="math">\(i=1,\ldots,N_n-2\)</span>.</p>
<p>One can alternatively use the Trapezoidal rule on the reference cell and
assemble the contributions. It is a bit more labor in this context,
but working on the reference cell is safer as that approach is
guaranteed to handle discontinuous derivatives of finite element
functions correctly (not important in this particular example),
while the rule above was derived with the
assumption that <span class="math">\(f\)</span> is continuous at the integration points.</p>
<p>The conclusion is that it suffices to use the Trapezoidal rule if
one wants to derive the difference equations in the finite element
method and make them similar to those arising in the finite difference
method. The Trapezoidal rule has sufficient accuracy for P1 elements, but
for P2 elements one should turn to Simpson&#8217;s rule.</p>
</div>
<div class="section" id="discretization-of-a-variable-coefficient-laplace-term">
<span id="nonlin-alglevel-1d-fe-laplace"></span><h2>Discretization of a variable coefficient Laplace term<a class="headerlink" href="#discretization-of-a-variable-coefficient-laplace-term" title="Permalink to this headline">¶</a></h2>
<p>Turning back to the model problem <a class="reference internal" href="._book030.html#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(429)</span></a>, it
remains to calculate the contribution of the <span class="math">\(({\alpha} u^{\prime})^{\prime}\)</span>
and boundary terms
to the difference equations. The integral in the variational form
corresponding to <span class="math">\(({\alpha} u^{\prime})^{\prime}\)</span> is</p>
<div class="math">
\[\int_0^L {\alpha}(\sum_k c_k{\psi}_k){\psi}_i^{\prime}{\psi}_j^{\prime}{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Numerical integration utilizing a value of <span class="math">\(\sum_k c_k{\psi}_k\)</span> from
a previous iteration must in general be used to compute the integral.
Now our aim is to integrate symbolically, as much as we can, to obtain
some insight into how the finite element method approximates
this term.
To be able to derive symbolic expressions, we must either turn to
the group finite element method or numerical integration in the
node points. Finite element basis functions <span class="math">\({\varphi}_i\)</span> are now used.</p>
<div class="section" id="group-finite-element-method">
<h3>Group finite element method<a class="headerlink" href="#group-finite-element-method" title="Permalink to this headline">¶</a></h3>
<p>We set <span class="math">\({\alpha}(u)\approx \sum_k\alpha(u_k){\varphi}_k\)</span>, and then
we write</p>
<div class="math">
\[\int_0^L {\alpha}(\sum_k c_k{\varphi}_k){\varphi}_i^{\prime}{\varphi}_j^{\prime}{\, \mathrm{d}x}
\approx
\sum_k (\underbrace{\int_0^L {\varphi}_k{\varphi}_i^{\prime}{\varphi}_j^{\prime}{\, \mathrm{d}x}}_{L_{i,j,k}})
{\alpha}(u_k) = \sum_k L_{i,j,k}{\alpha}(u_k){\thinspace .}\]</div>
<p>Further calculations are now easiest to carry out in the reference
cell. With P1 elements we can compute
<span class="math">\(L_{i,j,k}\)</span> for the two <span class="math">\(k\)</span> values that are relevant on the reference
cell. Turning to local indices, one gets</p>
<div class="math">
\[\begin{split}L_{r,s,t}^{(e)} =
\frac{1}{2h}\left(\begin{array}{rr}
1 &amp; -1\\
-1 &amp; 1
\end{array}\right),\quad t=0, 1,\end{split}\]</div>
<p>where <span class="math">\(r,s,t=0,1\)</span> are indices over local degrees of
freedom in the reference cell
(<span class="math">\(i=q(e,r)\)</span>, <span class="math">\(j=q(e,s)\)</span>, and <span class="math">\(k=q(e,t)\)</span>). The
sum <span class="math">\(\sum_k L_{i,j,k}{\alpha}(u_k)\)</span> at the cell level becomes
<span class="math">\(\sum_{t=0}^1 L_{r,s,t}^{(e)}{\alpha}(\tilde u_t)\)</span>, where <span class="math">\(\tilde u_t\)</span>
is <span class="math">\(u(x_{q(e,t)})\)</span>, i.e., the value of <span class="math">\(u\)</span> at local node number <span class="math">\(t\)</span> in
cell number <span class="math">\(e\)</span>. The element matrix becomes</p>
<div class="math" id="eq-nonlin-alglevel-1d-fe-laplace-ae">
\[\begin{split}\tag{458}
\frac{1}{2} ({\alpha}(\tilde u_0) + {\alpha}(\tilde u^{(1)}))
    \frac{1}{h}\left(\begin{array}{rr}
    1 &amp; -1\\
    -1 &amp; 1
    \end{array}\right){\thinspace .}\end{split}\]</div>
<p>As usual, we employ
a left-to-right numbering of cells and nodes.
Row number <span class="math">\(i\)</span> in the global matrix gets contributions from
the first row of the element matrix in cell <span class="math">\(i\)</span> and the last
row of the element matrix in cell <span class="math">\(i-1\)</span>.
In cell number <span class="math">\(i-1\)</span> the sum
<span class="math">\({\alpha}(\tilde u_0) + {\alpha}(\tilde u^{(1)})\)</span> corresponds to
<span class="math">\({\alpha}(u_{i-1}) + {\alpha}(u_i)\)</span>. The same sum becomes
<span class="math">\({\alpha}(u_{i}) + {\alpha}(u_{i+1})\)</span> in cell number <span class="math">\(i\)</span>.
We can with this insight assemble the contributions to row number <span class="math">\(i\)</span>
in the global matrix:</p>
<div class="math">
\[\frac{1}{2h}(-({\alpha}(u_{i-1}) + {\alpha}(u_i)),\quad
{\alpha}(u_{i-1}) + 2{\alpha}(u_i) + {\alpha}(u_{i+1}),\quad
{\alpha}(u_{i}) + {\alpha}(u_{i+1})){\thinspace .}\]</div>
<p>Multiplying by the vector of unknowns <span class="math">\(u_i\)</span> results in a formula that
can be arranged to</p>
<div class="math" id="eq-nonlin-alglevel-1d-fe-laplace-diffeq">
\[\tag{459}
-\frac{1}{h}(\frac{1}{2}({\alpha}(u_i) + {\alpha}(u_{i+1}))(u_{i+1}-u_i)
    -  \frac{1}{2}({\alpha}(u_{i-1}) + {\alpha}(u_{i}))(u_{i}-u_{i-1})),\]</div>
<p>which is nothing but the standard finite difference discretization
of <span class="math">\(-({\alpha}(u)u^{\prime})^{\prime}\)</span> with an arithmetic mean of <span class="math">\({\alpha}(u)\)</span> (and
the usual factor <span class="math">\(h\)</span> because of the integration in the finite element method).</p>
</div>
<div class="section" id="numerical-integration-at-the-nodes">
<h3>Numerical integration at the nodes<a class="headerlink" href="#numerical-integration-at-the-nodes" title="Permalink to this headline">¶</a></h3>
<p>Instead of using the group finite element method and exact integration
we can turn to the Trapezoidal rule for computing
<span class="math">\(\int_0^L {\alpha}(\sum_k u_k{\varphi}_k){\varphi}_i^{\prime}{\varphi}_j^{\prime}{\, \mathrm{d}x}\)</span>, again at
the cell level since that is most convenient when we deal with discontinuous
functions <span class="math">\({\varphi}_i'\)</span>:</p>
<div class="math">
\[\int_{-1}^1 \alpha(\sum_t\tilde u_t{\tilde{\varphi}}_t){\tilde{\varphi}}_r'{\tilde{\varphi}}_s'\frac{h}{2}dX
= \int_{-1}^1 {\alpha}(\sum_{t=0}^1
\tilde u_t{\tilde{\varphi}}_t)\frac{2}{h}\frac{d{\tilde{\varphi}}_r}{dX}
\frac{2}{h}\frac{d{\tilde{\varphi}}_s}{dX}\frac{h}{2}dX\nonumber\]</div>
<div class="math">
\[ = \frac{1}{2h}(-1)^r(-1)^s \int_{-1}^1 {\alpha}(\sum_{t=0}^1 u_t{\tilde{\varphi}}_t(X))dX
\nonumber\]</div>
<div class="math">
\[ \approx \frac{1}{2h}(-1)^r(-1)^s{\alpha} (
\sum_{t=0}^1{\tilde{\varphi}}_t(-1)\tilde u_t) + {\alpha}(\sum_{t=0}^1{\tilde{\varphi}}_t(1)\tilde u_t)
\nonumber\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fe-laplace-ae-trapez">
\[\tag{460}
= \frac{1}{2h}(-1)^r(-1)^s({\alpha}(\tilde u_0) + {\alpha}(\tilde u^{(1)})){\thinspace .}\]</div>
<p>The element matrix in <a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-laplace-ae-trapez"><span class="std std-ref">(460)</span></a>
is identical to the one in
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-laplace-ae"><span class="std std-ref">(458)</span></a>, showing that the
group finite element method and Trapezoidal integration are
equivalent with a standard finite discretization of a
nonlinear Laplace term <span class="math">\(({\alpha}(u)u^{\prime})^{\prime}\)</span> using an arithmetic mean for
<span class="math">\({\alpha}\)</span>: <span class="math">\([D_x\overline{x}D_xu]_i\)</span>.</p>
<div class="admonition-remark-about-integration-in-the-physical-math-x-coordinate admonition">
<p class="first admonition-title">Remark about integration in the physical <span class="math">\(x\)</span> coordinate</p>
<p class="last">We might comment on integration in the physical coordinate system too.
The common Trapezoidal rule in the section <a class="reference internal" href="#nonlin-alglevel-1d-fe-f"><span class="std std-ref">Numerical integration of nonlinear terms by hand</span></a>
cannot be used to integrate derivatives like <span class="math">\({\varphi}_i^{\prime}\)</span>, because
the formula is derived under the assumption of a continuous integrand.
One must instead use the more basic version of the Trapezoidal rule
where all the trapezoids are summed up. This is straightforward, but
I think it is even more straightforward to apply the Trapezoidal
rule on the reference cell and assemble the contributions.</p>
</div>
<p>The term <span class="math">\(\int auv{\, \mathrm{d}x}\)</span> in the variational form is linear and gives
these terms in the algebraic equations:</p>
<div class="math">
\[\frac{ah}{6}(u_{i-1} + 4u_i + u_{i+1})
= ah[u - \frac{h^2}{6}D_xD_x u]_i{\thinspace .}\]</div>
<p>The final term in the variational form is the Neumann condition
at the boundary: <span class="math">\(Cv(0)=C{\varphi}_i(0)\)</span>. With a left-to-right numbering
only <span class="math">\(i=0\)</span> will give a contribution <span class="math">\(Cv(0)=C\delta_{i0}\)</span> (since
<span class="math">\({\varphi}_i(0)\neq 0\)</span> only for <span class="math">\(i=0\)</span>).</p>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>For the equation</p>
<div class="math">
\[-({\alpha}(u)u^{\prime})^{\prime} +au = f(u),\]</div>
<p>P1 finite elements results in difference equations where</p>
<blockquote class="last">
<div><ul class="simple">
<li>the term <span class="math">\(-({\alpha}(u)u^{\prime})^{\prime}\)</span> becomes <span class="math">\(-h[D_x\overline{{\alpha}(u)}^xD_x u]_i\)</span>
if the group finite element method or Trapezoidal integration is applied,</li>
<li><span class="math">\(f(u)\)</span> becomes <span class="math">\(hf(u_i)\)</span> with Trapezoidal integration or the
&#8220;mass matrix&#8221; representation <span class="math">\(h[f(u) - \frac{h}{6}D_xD_x f(u)]_i\)</span>
if computed by a group finite element method,</li>
<li><span class="math">\(au\)</span> leads to the &#8220;mass matrix&#8221; form <span class="math">\(ah[u - \frac{h}{6}D_xD_x u]_i\)</span>.</li>
</ul>
</div></blockquote>
</div>
<p>As we now have explicit expressions for the nonlinear difference
equations also in the finite element method, a Picard or Newton method
can be defined as shown for the finite difference method.  However,
our efforts in deriving symbolic forms of the difference equations in
the finite element method was motivated by a desire to see how
nonlinear terms in differential equations make the finite element and
difference method different. For practical calculations in computer
programs we apply numerical integration, normally the more accurate
Gauss-Legendre quadrature rules, to the integrals directly. This
allows us to easily <em>evaluate</em> the nonlinear algebraic equations for a
given numerical approximation of <span class="math">\(u\)</span> (here denoted <span class="math">\(u^{-}\)</span>).  To
<em>solve</em> the nonlinear algebraic equations we need to apply the Picard
iteration method or Newton&#8217;s method to the variational form directly,
as shown next.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Exercises</a><ul>
<li><a class="reference internal" href="#problem-41-determine-if-equations-are-nonlinear-or-not">Problem 41: Determine if equations are nonlinear or not</a></li>
<li><a class="reference internal" href="#exercise-42-derive-and-investigate-a-generalized-logistic-model">Exercise 42: Derive and investigate a generalized logistic model</a></li>
<li><a class="reference internal" href="#problem-43-experience-the-behavior-of-newton-s-method">Problem 43: Experience the behavior of Newton&#8217;s method</a></li>
<li><a class="reference internal" href="#problem-44-compute-the-jacobian-of-a-system">Problem 44: Compute the Jacobian of a <span class="math">\(2\times 2\)</span> system</a></li>
<li><a class="reference internal" href="#problem-45-solve-nonlinear-equations-arising-from-a-vibration-ode">Problem 45: Solve nonlinear equations arising from a vibration ODE</a></li>
<li><a class="reference internal" href="#exercise-46-find-the-truncation-error-of-arithmetic-mean-of-products">Exercise 46: Find the truncation error of arithmetic mean of products</a></li>
<li><a class="reference internal" href="#problem-47-newton-s-method-for-linear-problems">Problem 47: Newton&#8217;s method for linear problems</a></li>
<li><a class="reference internal" href="#exercise-48-discretize-a-1d-problem-with-a-nonlinear-coefficient">Exercise 48: Discretize a 1D problem with a nonlinear coefficient</a></li>
<li><a class="reference internal" href="#exercise-49-linearize-a-1d-problem-with-a-nonlinear-coefficient">Exercise 49: Linearize a 1D problem with a nonlinear coefficient</a></li>
<li><a class="reference internal" href="#problem-50-finite-differences-for-the-1d-bratu-problem">Problem 50: Finite differences for the 1D Bratu problem</a></li>
<li><a class="reference internal" href="#exercise-51-discretize-a-nonlinear-1d-heat-conduction-pde-by-finite-differences">Exercise 51: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
<li><a class="reference internal" href="#exercise-52-differentiate-a-highly-nonlinear-term">Exercise 52: Differentiate a highly nonlinear term</a></li>
<li><a class="reference internal" href="#exercise-53-crank-nicolson-for-a-nonlinear-3d-diffusion-equation">Exercise 53: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
<li><a class="reference internal" href="#exercise-54-find-the-sparsity-of-the-jacobian">Exercise 54: Find the sparsity of the Jacobian</a></li>
<li><a class="reference internal" href="#problem-55-investigate-a-1d-problem-with-a-continuation-method">Problem 55: Investigate a 1D problem with a continuation method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#symbolic-nonlinear-finite-element-equations">Symbolic nonlinear finite element equations</a><ul>
<li><a class="reference internal" href="#finite-element-basis-functions-3">Finite element basis functions</a></li>
<li><a class="reference internal" href="#the-group-finite-element-method">The group finite element method</a><ul>
<li><a class="reference internal" href="#finite-element-approximation-of-functions-of">Finite element approximation of functions of <span class="math">\(u\)</span></a></li>
<li><a class="reference internal" href="#simplified-problem">Simplified problem</a></li>
<li><a class="reference internal" href="#integrating-nonlinear-functions">Integrating nonlinear functions</a></li>
<li><a class="reference internal" href="#application-of-the-group-finite-element-method">Application of the group finite element method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-integration-of-nonlinear-terms-by-hand">Numerical integration of nonlinear terms by hand</a></li>
<li><a class="reference internal" href="#discretization-of-a-variable-coefficient-laplace-term">Discretization of a variable coefficient Laplace term</a><ul>
<li><a class="reference internal" href="#group-finite-element-method">Group finite element method</a></li>
<li><a class="reference internal" href="#numerical-integration-at-the-nodes">Numerical integration at the nodes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book031.html"
                        title="previous chapter">Multi-dimensional PDE problems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book033.html"
                        title="next chapter">Uncertainty quantification and polynomial chaos expansions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book032.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book033.html" title="Uncertainty quantification and polynomial chaos expansions"
             >next</a> |</li>
        <li class="right" >
          <a href="._book031.html" title="Multi-dimensional PDE problems"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Kent-Andre Mardal. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>