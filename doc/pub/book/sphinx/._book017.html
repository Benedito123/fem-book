
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Examples on variational formulations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to Numerical Methods for Variational Problems" href="index.html" />
    <link rel="next" title="Exercises" href="._book018.html" />
    <link rel="prev" title="Abstract notation for variational formulations" href="._book016.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book018.html" title="Exercises"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book016.html" title="Abstract notation for variational formulations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="examples-on-variational-formulations">
<span id="fem-deq-1d-varform-ex"></span><h1>Examples on variational formulations<a class="headerlink" href="#examples-on-variational-formulations" title="Permalink to this headline">¶</a></h1>
<p>The following sections derive variational formulations for some
prototype differential equations in 1D, and demonstrate how we with
ease can handle variable coefficients, mixed Dirichlet and Neumann
boundary conditions, first-order derivatives, and nonlinearities.</p>
<div class="section" id="variable-coefficient">
<h2>Variable coefficient<a class="headerlink" href="#variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>Consider the problem</p>
<div class="math" id="eq-auto93">
\[\tag{186}
-\frac{d}{dx}\left( {\alpha}(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\
    u(0)=C,\ u(L)=D{\thinspace .}\]</div>
<p>There are two new features of this problem compared with
previous examples: a variable
coefficient <span class="math">\({\alpha} (x)\)</span> and nonzero Dirichlet conditions at both boundary points.</p>
<p>Let us first deal with the boundary conditions. We seek</p>
<div class="math">
\[u(x) = B(x) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_i(x){\thinspace .}\]</div>
<p>Since the Dirichlet conditions demand</p>
<div class="math">
\[{\psi}_i(0)={\psi}_i(L)=0,\quad i\in{\mathcal{I}_s},\]</div>
<p>the function <span class="math">\(B(x)\)</span>
must fulfill <span class="math">\(B(0)=C\)</span> and <span class="math">\(B(L)=D\)</span>. The we are guaranteed that <span class="math">\(u(0)=C\)</span>
and <span class="math">\(u(L)=D\)</span>. How <span class="math">\(B\)</span> varies in between
<span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span> is not of importance. One possible choice is</p>
<div class="math">
\[B(x) = C + \frac{1}{L}(D-C)x,\]</div>
<p>which follows from <a class="reference internal" href="._book015.html#eq-fem-deq-1d-essbc-bfunc-gen"><span class="std std-ref">(183)</span></a> with <span class="math">\(p=1\)</span>.</p>
<p>We seek <span class="math">\((u-B)\in V\)</span>. As usual,</p>
<div class="math">
\[V = \hbox{span}\{{\psi}_0,\ldots,{\psi}_N\}{\thinspace .}\]</div>
<p>Note that any <span class="math">\(v\in V\)</span> has the property <span class="math">\(v(0)=v(L)=0\)</span>.</p>
<p>The residual arises by inserting our <span class="math">\(u\)</span> in the differential equation:</p>
<div class="math">
\[R = -\frac{d}{dx}\left( {\alpha}\frac{du}{dx}\right) -f{\thinspace .}\]</div>
<p>Galerkin&#8217;s method is</p>
<div class="math">
\[(R, v) = 0,\quad \forall v\in V,\]</div>
<p>or written with explicit integrals,</p>
<div class="math">
\[\int_{\Omega} \left(-\frac{d}{dx}\left( {\alpha}\frac{du}{dx}\right) -f\right)v {\, \mathrm{d}x} = 0,\quad \forall v\in V {\thinspace .}\]</div>
<p>We proceed with integration by parts to lower the derivative from
second to first order:</p>
<div class="math">
\[-\int_{\Omega} \frac{d}{dx}\left( {\alpha}(x)\frac{du}{dx}\right) v {\, \mathrm{d}x}
= \int_{\Omega} {\alpha}(x)\frac{du}{dx}\frac{dv}{dx}{\, \mathrm{d}x} -
\left[{\alpha}\frac{du}{dx}v\right]_0^L
{\thinspace .}\]</div>
<p>The boundary term vanishes since <span class="math">\(v(0)=v(L)=0\)</span>.
The variational formulation is then</p>
<div class="math">
\[\int_{\Omega} {\alpha}(x)\frac{du}{dx}\frac{dv}{dx}{\, \mathrm{d}x} = \int_{\Omega} f(x)v{\, \mathrm{d}x},\quad
\forall v\in V{\thinspace .}\]</div>
<p>The variational formulation can alternatively be written in a more
compact form:</p>
<div class="math">
\[({\alpha} u',v') = (f,v),\quad \forall v\in V
{\thinspace .}\]</div>
<p>The corresponding abstract notation reads</p>
<div class="math">
\[a(u,v)=L(v)\quad\forall v\in V,\]</div>
<p>with</p>
<div class="math">
\[a(u,v)= ({\alpha} u',v'),\quad L(v)=(f,v) {\thinspace .}\]</div>
<p>We may insert <span class="math">\(u=B + \sum_jc_j{\psi}_j\)</span> and <span class="math">\(v={\psi}_i\)</span> to
derive the linear system:</p>
<div class="math">
\[({\alpha} B' + {\alpha} \sum_{j\in{\mathcal{I}_s}} c_j {\psi}_j', {\psi}_i') =
(f,{\psi}_i), \quad i\in{\mathcal{I}_s} {\thinspace .}\]</div>
<p>Isolating everything with the <span class="math">\(c_j\)</span> coefficients on the left-hand side
and all known terms on the right-hand side
gives</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}} ({\alpha}{\psi}_j', {\psi}_i')c_j  =
(f,{\psi}_i) + (\alpha (D-C)L^{-1}, {\psi}_i'), \quad i\in{\mathcal{I}_s}
{\thinspace .}\]</div>
<p>This is nothing but a linear system <span class="math">\(\sum_j A_{i,j}c_j=b_i\)</span>
with</p>
<div class="math">
\[\begin{split}\begin{align*}
A_{i,j} &amp;= (\alpha {\psi}_j', {\psi}_i') = \int_{\Omega} {\alpha}(x){\psi}_j'(x),
{\psi}_i'(x){\, \mathrm{d}x},\\
b_i &amp;= (f,{\psi}_i) + (\alpha (D-C)L^{-1},{\psi}_i')=
\int_{\Omega} \left(f(x){\psi}_i(x) + {\alpha}(x)\frac{D-C}{L}{\psi}_i'(x)\right) {\, \mathrm{d}x}
{\thinspace .}
\end{align*}\end{split}\]</div>
</div>
<div class="section" id="first-order-derivative-in-the-equation-and-boundary-condition">
<h2>First-order derivative in the equation and boundary condition<a class="headerlink" href="#first-order-derivative-in-the-equation-and-boundary-condition" title="Permalink to this headline">¶</a></h2>
<p>The next problem to formulate in terms of a variational form reads</p>
<div class="math" id="eq-auto94">
\[\tag{187}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\
    u(0)=C,\ u'(L)=E{\thinspace .}\]</div>
<p>The new features are a first-order derivative <span class="math">\(u'\)</span> in the equation
and the boundary
condition involving the derivative: <span class="math">\(u'(L)=E\)</span>.
Since we have a Dirichlet condition at <span class="math">\(x=0\)</span>,
we must force <span class="math">\({\psi}_i(0)=0\)</span> and use a boundary function
to take care of the condition <span class="math">\(u(0)=C\)</span>.
Because there is no Dirichlet
condition on <span class="math">\(x=L\)</span> we do not make any requirements to <span class="math">\({\psi}_i(L)\)</span>.
The simplest possible choice of <span class="math">\(B(x)\)</span> is <span class="math">\(B(x)=C\)</span>.</p>
<p>The expansion for <span class="math">\(u\)</span> becomes</p>
<div class="math">
\[u = C + \sum_{j\in{\mathcal{I}_s}} c_j {\psi}_i(x)
{\thinspace .}\]</div>
<p>The variational formulation arises from multiplying the equation by
a test function <span class="math">\(v\in V\)</span> and integrating over <span class="math">\(\Omega\)</span>:</p>
<div class="math">
\[(-u'' + bu' - f, v) = 0,\quad\forall v\in V\]</div>
<p>We apply integration by parts to the <span class="math">\(u''v\)</span> term only. Although we could
also integrate <span class="math">\(u' v\)</span> by parts, this is not common.
The result becomes</p>
<div class="math">
\[(u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V {\thinspace .}\]</div>
<p>Now, <span class="math">\(v(0)=0\)</span> so</p>
<div class="math">
\[[u' v]_0^L = u'(L)v(L) = E v(L),\]</div>
<p>because <span class="math">\(u'(L)=E\)</span>.
Thus, integration by parts allows us to take care of the Neumann condition
in the boundary term.</p>
<span class="target" id="index-0"></span><div class="admonition-natural-and-essential-boundary-conditions admonition" id="index-1">
<p class="first admonition-title">Natural and essential boundary conditions</p>
<p>A common mistake is to forget a boundary term like <span class="math">\([u'v]_0^L\)</span> in
the integration by parts. Such a mistake implies that we actually
impose the condition <span class="math">\(u'=0\)</span> unless there is a Dirichlet condition
(i.e., <span class="math">\(v=0\)</span>) at that point! This fact has great practical
consequences, because it is easy to forget the boundary term, and that
implicitly set a boundary condition!</p>
<p class="last">Since homogeneous Neumann conditions can be incorporated without
&#8220;doing anything&#8221; (i.e., omitting the boundary term), and
non-homogeneous Neumann conditions can just be inserted in the
boundary term, such conditions are known as <em>natural boundary
conditions</em>.  Dirichlet conditions require more essential steps in the
mathematical formulation, such as forcing all <span class="math">\({\varphi}_i=0\)</span> on the
boundary and constructing a <span class="math">\(B(x)\)</span>, and are therefore known as
<em>essential boundary conditions</em>.</p>
</div>
<p>The final variational form reads</p>
<div class="math">
\[(u',v') + (bu',v) = (f,v) + E v(L), \quad\forall v\in V {\thinspace .}\]</div>
<p>In the abstract notation we have</p>
<div class="math">
\[a(u,v)=L(v)\quad\forall v\in V,\]</div>
<p>with the particular formulas</p>
<div class="math">
\[a(u,v)=(u',v') + (bu',v),\quad L(v)= (f,v) + E v(L){\thinspace .}\]</div>
<p>The associated linear system is derived by inserting <span class="math">\(u=B+\sum_jc_j{\psi}_j\)</span>
and replacing <span class="math">\(v\)</span> by <span class="math">\({\psi}_i\)</span> for <span class="math">\(i\in{\mathcal{I}_s}\)</span>. Some algebra results in</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}} \underbrace{(({\psi}_j',{\psi}_i') + (b{\psi}_j',{\psi}_i))}_{A_{i,j}} c_j = \underbrace{(f,{\psi}_i) + E {\psi}_i(L)}_{b_i}
{\thinspace .}\]</div>
<p>Observe that in this problem, the coefficient matrix is not symmetric,
because of the term</p>
<div class="math">
\[(b{\psi}_j',{\psi}_i)=\int_{\Omega} b{\psi}_j'{\psi}_i {\, \mathrm{d}x}
 \neq \int_{\Omega} b {\psi}_i' {\psi}_j {\, \mathrm{d}x} = ({\psi}_i',b{\psi}_j)
{\thinspace .}\]</div>
</div>
<div class="section" id="nonlinear-coefficient">
<h2>Nonlinear coefficient<a class="headerlink" href="#nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>Finally, we show that the techniques used above to derive variational
forms apply to nonlinear differential equation
problems as well. Here is a model problem with
a nonlinear coefficient <span class="math">\(\alpha(u)\)</span> and a nonlinear right-hand side <span class="math">\(f(u)\)</span>:</p>
<div class="math" id="eq-auto95">
\[\tag{188}
-({\alpha}(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
    {\thinspace .}\]</div>
<p>Our space <span class="math">\(V\)</span> has basis <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>, and because of the
condition <span class="math">\(u(0)=0\)</span>, we must require <span class="math">\({\psi}_i(0)=0\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>.</p>
<p>Galerkin&#8217;s method is about inserting the approximate
<span class="math">\(u\)</span>, multiplying the differential equation by <span class="math">\(v\in V\)</span>, and integrate,</p>
<div class="math">
\[-\int_0^L \frac{d}{dx}\left({\alpha}(u)\frac{du}{dx}\right)v {\, \mathrm{d}x} =
\int_0^L f(u)v {\, \mathrm{d}x}\quad\forall v\in V
{\thinspace .}\]</div>
<p>The integration by parts does not differ from the case where we have
<span class="math">\({\alpha}(x)\)</span> instead of <span class="math">\({\alpha}(u)\)</span>:</p>
<div class="math">
\[\int_0^L {\alpha}(u)\frac{du}{dx}\frac{dv}{dx}{\, \mathrm{d}x} =
\int_0^L f(u)v{\, \mathrm{d}x} + [{\alpha}(u)vu']_0^L\quad\forall v\in V
{\thinspace .}\]</div>
<p>The term <span class="math">\({\alpha}(u(0))v(0)u'(0)=0\)</span> since <span class="math">\(v(0)\)</span>.
The other term, <span class="math">\({\alpha}(u(L))v(L)u'(L)\)</span>,
is used to impose the other boundary condition <span class="math">\(u'(L)=E\)</span>, resulting in</p>
<div class="math">
\[\int_0^L {\alpha}(u)\frac{du}{dx}\frac{dv}{dx}{\, \mathrm{d}x} =
\int_0^L f(u)v{\, \mathrm{d}x} + {\alpha}(u(L))v(L)E\quad\forall v\in V,\]</div>
<p>or alternatively written more compactly as</p>
<div class="math">
\[({\alpha}(u)u', v') = (f(u),v) + {\alpha}(u(L))v(L)E\quad\forall v\in V
{\thinspace .}\]</div>
<p>Since the problem is nonlinear, we cannot identify a bilinear
form <span class="math">\(a(u,v)\)</span> and a linear form <span class="math">\(L(v)\)</span>.
An abstract formulation is typically <em>find  \( u \)  such that</em></p>
<div class="math">
\[F(u;v) = 0\quad\forall v\in V,\]</div>
<p>with</p>
<div class="math">
\[F(u;v) = (a(u)u', v') - (f(u),v) - a(L)v(L)E
{\thinspace .}\]</div>
<p>By inserting <span class="math">\(u=\sum_j c_j{\psi}_j\)</span> and <span class="math">\(v={\psi}_i\)</span> in <span class="math">\(F(u;v)\)</span>,
we get a <em>nonlinear system of
algebraic equations</em> for the unknowns <span class="math">\(c_i\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>. Such systems must
be solved by constructing a sequence of linear systems whose solutions
hopefully converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton&#8217;s method.</p>
</div>
</div>
<div class="section" id="implementation-of-the-algorithms">
<span id="fem-global-deq-1d-code"></span><h1>Implementation of the algorithms<a class="headerlink" href="#implementation-of-the-algorithms" title="Permalink to this headline">¶</a></h1>
<p>Our hand calculations can benefit greatly by symbolic computing, as shown
earlier, so it is natural to extend our approximation programs based on
<code class="docutils literal"><span class="pre">sympy</span></code> to the problem domain of variational formulations.</p>
<div class="section" id="extensions-of-the-code-for-approximation-1">
<span id="fem-deq-1d-code-global"></span><h2>Extensions of the code for approximation<a class="headerlink" href="#extensions-of-the-code-for-approximation-1" title="Permalink to this headline">¶</a></h2>
<p>The user must prepare a function <code class="docutils literal"><span class="pre">integrand_lhs(psi,</span> <span class="pre">i,</span> <span class="pre">j)</span></code> for
returning the integrand of the integral that contributes to matrix
entry <span class="math">\((i,j)\)</span> on the left-hand side.  The <code class="docutils literal"><span class="pre">psi</span></code> variable is a Python dictionary holding the
basis functions and their derivatives in symbolic form. More
precisely, <code class="docutils literal"><span class="pre">psi[q]</span></code> is a list of</p>
<div class="math">
\[\{\frac{d^q{\psi}_0}{dx^q},\ldots,\frac{d^q{\psi}_{N_n-1}}{dx^q}\}
{\thinspace .}\]</div>
<p>Similarly, <code class="docutils literal"><span class="pre">integrand_rhs(psi,</span> <span class="pre">i)</span></code> returns the integrand
for entry number <span class="math">\(i\)</span> in the right-hand side vector.</p>
<p>Since we also have contributions to the right-hand side vector (and
potentially also the matrix) from boundary terms without any integral,
we introduce two additional functions, <code class="docutils literal"><span class="pre">boundary_lhs(psi,</span> <span class="pre">i,</span> <span class="pre">j)</span></code> and
<code class="docutils literal"><span class="pre">boundary_rhs(psi,</span> <span class="pre">i)</span></code> for returning terms in the variational
formulation that are not to be integrated over the domain <span class="math">\(\Omega\)</span>.
Examples, to be shown later, will explain in more detail how these
user-supplied function may look like.</p>
<p>The linear system can be computed and solved symbolically by
the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">integrand_lhs</span><span class="p">,</span> <span class="n">integrand_rhs</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
           <span class="n">boundary_lhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">boundary_rhs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">boundary_lhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>   <span class="c1"># assume symmetry</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">boundary_rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
</div>
<div class="section" id="fallback-on-numerical-methods">
<h2>Fallback on numerical methods<a class="headerlink" href="#fallback-on-numerical-methods" title="Permalink to this headline">¶</a></h2>
<p>Not surprisingly, symbolic solution of differential
equations, discretized by a Galerkin or least squares method
with global basis functions,
is of limited interest beyond the simplest problems, because
symbolic integration might be very time consuming or impossible, not
only in <code class="docutils literal"><span class="pre">sympy</span></code> but also in
<a class="reference external" href="http://wolframalpha.com">WolframAlpha</a>
(which applies the perhaps most powerful symbolic integration
software available today: Mathematica). Numerical integration
as an option is therefore desirable.</p>
<p>The extended <code class="docutils literal"><span class="pre">solver</span></code> function below tries to combine symbolic and
numerical integration.  The latter can be enforced by the user, or it
can be invoked after a non-successful symbolic integration (being
detected by an <code class="docutils literal"><span class="pre">Integral</span></code> object as the result of the integration
in <code class="docutils literal"><span class="pre">sympy</span></code>).</p>
<p>Note that for a
numerical integration, symbolic expressions must be converted to
Python functions (using <code class="docutils literal"><span class="pre">lambdify</span></code>), and the expressions cannot contain
other symbols than <code class="docutils literal"><span class="pre">x</span></code>. The real <code class="docutils literal"><span class="pre">solver</span></code> routine in the
<a class="reference external" href="http://tinyurl.com/znpudbt/varform1D.py">varform1D.py</a>
file has error checking and meaningful error messages in such cases.
The <code class="docutils literal"><span class="pre">solver</span></code> code below is a condensed version of the real one, with
the purpose of showing how to automate the Galerkin or least squares
method for solving differential equations in 1D with global basis functions:</p>
<p>[<strong>kam 10</strong>: this point has been made many times already]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">integrand_lhs</span><span class="p">,</span> <span class="n">integrand_rhs</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
           <span class="n">boundary_lhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">boundary_rhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                    <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># force num.int. hereafter</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span><span class="p">:</span>
                <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">boundary_lhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">boundary_rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
</div>
<div class="section" id="example-with-constant-right-hand-side">
<h2>Example with constant right-hand side<a class="headerlink" href="#example-with-constant-right-hand-side" title="Permalink to this headline">¶</a></h2>
<p>To demonstrate the code above, we address</p>
<div class="math">
\[-u''(x)=b,\quad x\in\Omega=[0,1],\quad u(0)=1,\ u(1)=0,\]</div>
<p>with <span class="math">\(b\)</span> as a (symbolic) constant. A possible basis for the space <span class="math">\(V\)</span>
is <span class="math">\({\psi}_i(x) = x^{i+1}(1-x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>. Note that
<span class="math">\({\psi}_i(0)={\psi}_i(1)=0\)</span> as required by the Dirichlet conditions.
We need a <span class="math">\(B(x)\)</span> function to take care of the known boundary
values of <span class="math">\(u\)</span>. Any function <span class="math">\(B(x)=1-x^p\)</span>, <span class="math">\(p\in\mathbb{R}\)</span>, is a candidate,
and one arbitrary choice from this family
is <span class="math">\(B(x)=1-x^3\)</span>. The unknown function is then written as</p>
<div class="math">
\[u(x) = B(x) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x){\thinspace .}\]</div>
<p>Let us use the Galerkin method to derive the variational formulation.
Multiplying the differential
equation by <span class="math">\(v\)</span> and integrating by parts yield</p>
<div class="math">
\[\int_0^1 u'v' {\, \mathrm{d}x} = \int_0^1 fv {\, \mathrm{d}x}\quad\forall v\in V,\]</div>
<p>and with <span class="math">\(u=B + \sum_jc_j{\psi}_j\)</span> we get the linear system</p>
<div class="math" id="eq-auto96">
\[\tag{189}
\sum_{j\in{\mathcal{I}_s}}\left(\int_0^1{\psi}_i'{\psi}_j' {\, \mathrm{d}x}\right)c_j =
    \int_0^1(f{\psi}_i-B'{\psi}_i') {\, \mathrm{d}x},
    \quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The application can be coded as follows with <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x b&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span>
<span class="n">dBdx</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># Compute basis functions and their derivatives</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">psi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]}</span>
<span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">psi_i</span> <span class="ow">in</span> <span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">integrand_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">integrand_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dBdx</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">varform1D</span> <span class="kn">import</span> <span class="n">solver</span>
<span class="n">u_bar</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">integrand_lhs</span><span class="p">,</span> <span class="n">integrand_rhs</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">u_bar</span>
<span class="k">print</span> <span class="s1">&#39;solution u:&#39;</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
</pre></div>
</div>
<p>[<strong>kam 11</strong>: does not work]
[<strong>hpl 12</strong>: We must get it to work. It&#8217;s a small extension of the code for approximation and very natural to include when we have so much material already on <code class="docutils literal"><span class="pre">sympy</span></code> for implementing algorithms.]</p>
<p>The printout of <code class="docutils literal"><span class="pre">u</span></code> reads <code class="docutils literal"><span class="pre">-b*x**2/2</span> <span class="pre">+</span> <span class="pre">b*x/2</span> <span class="pre">-</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>.  Note that
expanding <code class="docutils literal"><span class="pre">u</span></code>, before simplifying, is necessary in the present case to
get a compact, final expression with <code class="docutils literal"><span class="pre">sympy</span></code>. Doing <code class="docutils literal"><span class="pre">expand</span></code> before
<code class="docutils literal"><span class="pre">simplify</span></code> is a common strategy for simplifying expressions in
<code class="docutils literal"><span class="pre">sympy</span></code>. However, a non-expanded <code class="docutils literal"><span class="pre">u</span></code> might be preferable in other
cases - this depends on the problem in question.</p>
<p>The exact solution <span class="math">\({u_{\small\mbox{e}}}(x)\)</span> can be derived by some <code class="docutils literal"><span class="pre">sympy</span></code> code that
closely follows the examples in the section <a class="reference internal" href="._book015.html#fem-deq-1d-models-simple"><span class="std std-ref">Simple model problems and their solutions</span></a>. The idea is to integrate <span class="math">\(-u''=b\)</span> twice
and determine the integration constants from the boundary conditions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1 C2&#39;</span><span class="p">)</span>    <span class="c1"># integration constants</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C2</span>
<span class="c1"># Find C1 and C2 from the boundary conditions u(0)=0, u(1)=1</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">u_e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u_e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">])</span>
<span class="c1"># Form the exact solution</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="o">-</span><span class="n">f2</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">C1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">C2</span><span class="p">]</span>
<span class="k">print</span> <span class="s1">&#39;analytical solution:&#39;</span><span class="p">,</span> <span class="n">u_e</span>
<span class="k">print</span> <span class="s1">&#39;error:&#39;</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">))</span>
</pre></div>
</div>
<p>The last line prints <code class="docutils literal"><span class="pre">0</span></code>, which is not surprising when
<span class="math">\({u_{\small\mbox{e}}}(x)\)</span> is a parabola and our approximate <span class="math">\(u\)</span> contains polynomials up to
degree 4. It suffices to have <span class="math">\(N=1\)</span>, i.e., polynomials of degree
2, to recover the exact solution.</p>
<p>We can play around with the code and test that with <span class="math">\(f=Kx^p\)</span>, for
some constants <span class="math">\(K\)</span> and <span class="math">\(p\)</span>,
the solution is a polynomial of degree <span class="math">\(p+2\)</span>, and <span class="math">\(N=p+1\)</span> guarantees
that the approximate solution is exact.</p>
<p>Although the symbolic code is capable of integrating many choices of <span class="math">\(f(x)\)</span>,
the symbolic expressions for <span class="math">\(u\)</span> quickly become lengthy and non-informative,
so numerical integration in the code, and hence numerical answers,
have the greatest application potential.</p>
</div>
</div>
<div class="section" id="approximations-may-fail-convection-diffusion">
<span id="ch-convdiff"></span><h1>Approximations may fail: convection-diffusion<a class="headerlink" href="#approximations-may-fail-convection-diffusion" title="Permalink to this headline">¶</a></h1>
<p id="index-2">In the previous examples we have obtained reasonable approximations
of the continuous solution with several different approaches. In this
chapter we will consider a convection-diffusion equation where
many methods will fail. The failure is purely numerical
and it is often tied to the resolution. The current example is perhaps
the prime example of numerical instabilities in the context of
numerical solution algorithms for PDEs.</p>
<p>Consider the equation</p>
<div class="math" id="eq-convdiff-1d">
\[\tag{190}
\
    - \epsilon u_{xx} - u_x = 0, \quad \in  (0,1),\]</div>
<div class="math" id="eq-auto97">
\[\tag{191}
u(0) = 1,\]</div>
<div class="math" id="eq-auto98">
\[\tag{192}
u(1) = 0 .\]</div>
<p>The problem describes a convection-diffusion problem where the
convection is modelled by the first order term <span class="math">\(-u_x\)</span> and diffusion is
described by the second order term <span class="math">\(-\epsilon u_{xx}\)</span>. In many
applications <span class="math">\(\epsilon \ll 1\)</span> and the dominating term is <span class="math">\(-u_x\)</span>. The
sign of <span class="math">\(-u_x\)</span> is not important, the same problem occurs for
<span class="math">\(u_x\)</span>. The sign only determine the direction of the convection.</p>
<p>For <span class="math">\(\epsilon=0\)</span>, the solution satisfies</p>
<div class="math">
\[u(x) - u(1) = \int_1^x (-u_x) (-{\, \mathrm{d}x}) = 0 ,\]</div>
<p>which means that <span class="math">\(u(x) = u(1)\)</span>. Clearly only the boundary condition at <span class="math">\(x=1\)</span> is required
and the solution is constant throughout the domain.</p>
<p>If <span class="math">\(0 &lt; \epsilon \ll 1\)</span> such that the term <span class="math">\(-u_x\)</span> is dominating, the
solution is similar to the solution for <span class="math">\(\epsilon=0\)</span> in the interior.
However, the second order term <span class="math">\(-\epsilon u_{xx}\)</span> makes the problem a
second order problem and two boundary conditions are required, one
condition at each side.  The boundary condition at <span class="math">\(x=0\)</span> forces the
solution to be zero at that point and this creates a sharp gradient
close to <span class="math">\(x=0\)</span>.  For this reason, the problem is called a <em>singular
perturbation problem</em> as the problem changes fundamentally in the
sense that different boundary conditions are required in the limiting
case <span class="math">\(\epsilon=0\)</span>.</p>
<p>The solution of the above problem is</p>
<div class="math" id="eq-convdiff-1d-analytical">
\[\tag{193}
\
    u(x) = \frac{e^{-x/\epsilon} - 1}{ e^{-1/\epsilon} -1 } .\]</div>
<div class="figure" id="id1">
<span id="convdiff-analytical"></span><a class="reference internal image-reference" href="_images/conv-diff-analytical.png"><img alt="_images/conv-diff-analytical.png" src="_images/conv-diff-analytical.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">Analytical solution to the convection-diffusion problem for varying <span class="math">\(\epsilon\)</span></span></p>
</div>
<p>The solution is plotted in Figure <a class="reference internal" href="#convdiff-analytical"><span class="std std-ref">Analytical solution to the convection-diffusion problem for varying </span></a> for
different values of <span class="math">\(\epsilon\)</span>.  Clearly, as <span class="math">\(\epsilon\)</span> decrease the
exponential function represents a sharper and sharper gradient.  From
a physical or engineering point of view, the equation
<a class="reference internal" href="#eq-convdiff-1d"><span class="std std-ref">(190)</span></a> represents the simplest problem involving a common
phenomenon of boundary layers.  Boundary layers are common in all
kinds of fluid flow and is a main problem when discretizing such
equations.  Boundary layers have the characteristics of the solution
<a class="reference internal" href="#eq-convdiff-1d-analytical"><span class="std std-ref">(193)</span></a>, that is; a sharp local exponential
gradient.  In fluid flow the parameter <span class="math">\(\epsilon\)</span> is often related to
the inverse of the Reynolds number which frequently in engineering is
significantly larger than <span class="math">\(10^3\)</span> as it was here.  In these
applications the boundary layer is extremely thin and the gradient
extremely sharp.</p>
<p>In this chapter we will not embark on the fascinating and complex
issue of boundary layer theory but only consider the numerical issues
related to this phenomenon.  Let us as earlier therefore consider an
approximate solution on the following form</p>
<div class="math" id="eq-auto99">
\[\tag{194}
u(x) =  \hat{u}(x) + B(x) = \sum^{N-1}_{j=1} c_j {\psi}_j(x)  + B(x)\]</div>
<p>As earlier <span class="math">\(\{{\psi}_j(x)\}_{j=1}^{N-1}\}\)</span> are zero at the boundary <span class="math">\(x=0\)</span>
and <span class="math">\(x=1\)</span> and the boundary conditions are accounted for by the function <span class="math">\(B(x)\)</span>.
Let</p>
<div class="math" id="eq-auto100">
\[\tag{195}
B(x) = c_0 (1-x) + c_N x {\thinspace .}\]</div>
<p>Then we fixate <span class="math">\(c_0=0\)</span> and <span class="math">\(c_N=1\)</span> which makes <span class="math">\(B(x) = x\)</span>.
To determine <span class="math">\(\{c_j\}_{j=1}^{N-1}\}\)</span>  we consider the homogeneous Dirichlet problem
where we solve for <span class="math">\(\hat{u} = u - B\)</span>. The homogeneous Dirichlet problem reads</p>
<div class="math" id="eq-auto101">
\[\tag{196}
- \epsilon \hat{u}_{xx} + \hat{u}_x = 1, \quad \in  (0,1),\]</div>
<div class="math" id="eq-convdiff-1d-homo">
\[\tag{197}
\hat{u}(0) = 0,\]</div>
<div class="math">
\[\nonumber
\hat{u}(1) = 0 {\thinspace .}
\nonumber\]</div>
<p>The Galerkin formulation of <a class="reference internal" href="#eq-convdiff-1d-homo"><span class="std std-ref">(197)</span></a> is obtained as</p>
<div class="math">
\[\int_0^1
(- \epsilon \hat{u}'' + \hat{u}' - 1) {\psi}_j {\, \mathrm{d}x} {\thinspace .}\]</div>
<p>Integration by parts leads to</p>
<div class="math">
\[\int_0^1
\epsilon \hat{u}' {\psi}_i' + \hat{u}' {\psi}_i - 1 {\psi}_i {\, \mathrm{d}x} {\thinspace .}\]</div>
<p>In other words, we need to solve the linear system <span class="math">\(\sum_j A_{i,j} c_j = b_i\)</span> where</p>
<div class="math">
\[\begin{split}\begin{align*}
A_{i,j} &amp;= \int_0^1\epsilon {\psi}_j' {\psi}_i' + {\psi}_j' {\psi}_i {\, \mathrm{d}x},\\
b_i &amp;=\int_0^1 1 {\psi}_j {\, \mathrm{d}x} {\thinspace .}
\end{align*}\end{split}\]</div>
<p>A sketch of a
corresponding code where we also plot the behavior of the solution
with respect to different <span class="math">\(\epsilon\)</span> goes as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">series_type</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>  <span class="c1"># Lagrange, Bernstein, sin, ...</span>
<span class="n">eps_values</span> <span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">]</span>
<span class="k">for</span> <span class="n">eps</span> <span class="ow">in</span> <span class="n">eps_valuess</span><span class="p">:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">eps</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span>\
                 <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span>
                                     <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
    <span class="n">x_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">100.0</span><span class="p">))</span>
    <span class="n">U_</span> <span class="o">=</span> <span class="n">U</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">U_</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="id2">
<span id="convdiff-osc-lagrange8"></span><a class="reference internal image-reference" href="_images/Lagrange_convdiff_8.png"><img alt="_images/Lagrange_convdiff_8.png" src="_images/Lagrange_convdiff_8.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">Solution obtained with Galerkin approximation using Lagrangian polynomials of order up to 8 for various <span class="math">\(\epsilon\)</span></span></p>
</div>
<div class="figure" id="id3">
<span id="convdiff-osc-lagrange16"></span><a class="reference internal image-reference" href="_images/Lagrange_convdiff_16.png"><img alt="_images/Lagrange_convdiff_16.png" src="_images/Lagrange_convdiff_16.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">Solution obtained with Galerkin approximation using Lagrangian polynomials of order up to 16 for various <span class="math">\(\epsilon\)</span></span></p>
</div>
<p>The numerical solutions for different <span class="math">\(\epsilon\)</span> is shown in Figure
<a class="reference internal" href="#convdiff-osc-lagrange8"><span class="std std-ref">Solution obtained with Galerkin approximation using Lagrangian polynomials of order up to 8 for various </span></a> and <a class="reference internal" href="#convdiff-osc-lagrange16"><span class="std std-ref">Solution obtained with Galerkin approximation using Lagrangian polynomials of order up to 16 for various </span></a> for <span class="math">\(N=8\)</span>
and <span class="math">\(N=16\)</span>, respectively.  From these figures we can make two
observations. The first observation is that the numerical solution
contains non-physical oscillations that grows as <span class="math">\(\epsilon\)</span>
decreases. These oscillations are so strong that for <span class="math">\(N=8\)</span>, the
numerical solutions do not resemble the true solution at all for
<span class="math">\(\epsilon\)</span> less than <span class="math">\(1/10\)</span>. The true solution is always in the
interval <span class="math">\([0,1]\)</span> while the numerical solution has values larger than 2
for <span class="math">\(\epsilon=1/100\)</span> and larger than 10 for <span class="math">\(\epsilon=1/1000\)</span>.  The
second observation is that the numerical solutions appear to improve
as <span class="math">\(N\)</span> increases. While the numerical solution is outside the interval
<span class="math">\([0,1]\)</span> for <span class="math">\(\epsilon\)</span> less than <span class="math">\(1/10\)</span> the magnitude of the
oscillations clearly has decreased.</p>
<p>We will return to this example later and show examples of
techniques that can be used to improve the approximation.
The complete source code can be found in</p>
<blockquote>
<div><a class="reference external" href="http://tinyurl.com/znpudbt/conv_diff_global.py">conv_diff_global.py</a>.</div></blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Examples on variational formulations</a><ul>
<li><a class="reference internal" href="#variable-coefficient">Variable coefficient</a></li>
<li><a class="reference internal" href="#first-order-derivative-in-the-equation-and-boundary-condition">First-order derivative in the equation and boundary condition</a></li>
<li><a class="reference internal" href="#nonlinear-coefficient">Nonlinear coefficient</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-the-algorithms">Implementation of the algorithms</a><ul>
<li><a class="reference internal" href="#extensions-of-the-code-for-approximation-1">Extensions of the code for approximation</a></li>
<li><a class="reference internal" href="#fallback-on-numerical-methods">Fallback on numerical methods</a></li>
<li><a class="reference internal" href="#example-with-constant-right-hand-side">Example with constant right-hand side</a></li>
</ul>
</li>
<li><a class="reference internal" href="#approximations-may-fail-convection-diffusion">Approximations may fail: convection-diffusion</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book016.html"
                        title="previous chapter">Abstract notation for variational formulations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book018.html"
                        title="next chapter">Exercises</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book017.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book018.html" title="Exercises"
             >next</a> |</li>
        <li class="right" >
          <a href="._book016.html" title="Abstract notation for variational formulations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Introduction to Numerical Methods for Variational Problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Kent-Andre Mardal. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>