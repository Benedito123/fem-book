<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,polynomial chaos,Chaospy software,intrusive polynomial chaos,non-intrusive polynomial chaos,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, u'ch:preface', u'ch:preface'),
              (u'Contents', 3, None, '___sec1'),
              (u'Supplementary materials', 3, None, '___sec2'),
              (u'Quick overview of the finite element method',
               0,
               u'ch:overview',
               u'ch:overview'),
              (u'Function approximation by global functions',
               0,
               u'ch:approx:global',
               u'ch:approx:global'),
              (u'Approximation of vectors',
               1,
               u'fem:approx:vec',
               u'fem:approx:vec'),
              (u'Approximation of planar vectors',
               2,
               u'fem:approx:vec:plane',
               u'fem:approx:vec:plane'),
              (u'The least squares method', 3, None, '___sec7'),
              (u'The projection method', 3, None, '___sec8'),
              (u'Approximation of general vectors',
               2,
               u'fem:approx:vec:Np1dim',
               u'fem:approx:vec:Np1dim'),
              (u'The least squares method', 3, None, '___sec10'),
              (u'The Galerkin or projection method', 3, None, '___sec11'),
              (u'Approximation principles',
               1,
               u'fem:approx:global',
               u'fem:approx:global'),
              (u'The least squares method',
               2,
               u'fem:approx:LS',
               u'fem:approx:LS'),
              (u'The projection (or Galerkin) method', 2, None, '___sec14'),
              (u'Example on linear approximation',
               2,
               u'fem:approx:global:linear',
               u'fem:approx:global:linear'),
              (u'Implementation of the least squares method',
               2,
               u'fem:approx:global:LS:code',
               u'fem:approx:global:LS:code'),
              (u'Symbolic integration', 3, None, '___sec17'),
              (u'Fall back on numerical integration', 3, None, '___sec18'),
              (u'Plotting the approximation', 3, None, '___sec19'),
              (u'Perfect approximation',
               2,
               u'fem:approx:global:exact1',
               u'fem:approx:global:exact1'),
              (u'The regression method',
               2,
               u'fem:approx:global:regression',
               u'fem:approx:global:regression'),
              (u'Overdetermined equation system', 3, None, '___sec22'),
              (u'The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              (u'Implementation', 3, None, '___sec24'),
              (u'Example', 3, None, '___sec25'),
              (u'Orthogonal basis functions', 1, None, '___sec26'),
              (u'Ill-conditioning',
               2,
               u'fem:approx:global:illconditioning',
               u'fem:approx:global:illconditioning'),
              (u'Fourier series',
               2,
               u'fem:approx:global:Fourier',
               u'fem:approx:global:Fourier'),
              (u'Orthogonal basis functions',
               2,
               u'fem:approx:global:orth',
               u'fem:approx:global:orth'),
              (u'Numerical computations', 2, None, '___sec30'),
              (u'Interpolation', 1, None, '___sec31'),
              (u'The interpolation (or collocation) principle',
               2,
               u'fem:approx:global:interp',
               u'fem:approx:global:interp'),
              (u'Example', 3, None, '___sec33'),
              (u'Lagrange polynomials',
               2,
               u'fem:approx:global:Lagrange',
               u'fem:approx:global:Lagrange'),
              (u'Approximation of a polynomial', 3, None, '___sec35'),
              (u'Successful example', 3, None, '___sec36'),
              (u'Less successful example', 3, None, '___sec37'),
              (u'Remedy for strong oscillations', 3, None, '___sec38'),
              (u'Bernstein polynomials',
               2,
               u'fem:approx:global:Bernstein',
               u'fem:approx:global:Bernstein'),
              (u'Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              (u'Approximation of functions in higher dimensions',
               1,
               u'fem:approx:2D',
               u'fem:approx:2D'),
              (u'2D basis functions as tensor products of 1D functions',
               2,
               u'fem:approx:2D:global',
               u'fem:approx:2D:global'),
              (u'Example on polynomial basis in 2D', 2, None, '___sec43'),
              (u'Implementation',
               2,
               u'fem:approx:2D:global:code',
               u'fem:approx:2D:global:code'),
              (u'Extension to 3D',
               2,
               u'fem:approx:3D:global',
               u'fem:approx:3D:global'),
              (u'Exercises', 1, None, '___sec46'),
              (u'Problem 1: Linear algebra refresher',
               2,
               u'fem:approx:exer:linalg1',
               u'fem:approx:exer:linalg1'),
              (u'Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               u'fem:approx:exer:vec:3Dby2D',
               u'fem:approx:exer:vec:3Dby2D'),
              (u'Problem 3: Approximate a parabola by a sine',
               2,
               u'fem:approx:exer:parabola_sine',
               u'fem:approx:exer:parabola_sine'),
              (u'Problem 4: Approximate the exponential function by power functions',
               2,
               u'fem:approx:exer:exp:powers',
               u'fem:approx:exer:exp:powers'),
              (u'Problem 5: Approximate the sine function by power functions',
               2,
               u'fem:approx:exer:sin:powers',
               u'fem:approx:exer:sin:powers'),
              (u'Problem 6: Approximate a steep function by sines',
               2,
               u'fem:approx:exer:tanh:sine1',
               u'fem:approx:exer:tanh:sine1'),
              (u'Remarks', 3, None, '___sec53'),
              (u'Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               u'fem:approx:exer:tanh:sine3',
               u'fem:approx:exer:tanh:sine3'),
              (u'Remarks', 3, None, '___sec55'),
              (u'Exercise 8: Fourier series as a least squares approximation',
               2,
               u'fem:approx:exer:Fourier',
               u'fem:approx:exer:Fourier'),
              (u'Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               u'fem:approx:exer:tanh:Lagrange',
               u'fem:approx:exer:tanh:Lagrange'),
              (u'Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               u'fem:approx:exer:tanh:Lagrange:regression',
               u'fem:approx:exer:tanh:Lagrange:regression'),
              (u'Function approximation by finite elements',
               0,
               u'ch:approx:fe',
               u'ch:approx:fe'),
              (u'Finite element basis functions',
               1,
               u'fem:approx:fe',
               u'fem:approx:fe'),
              (u'Elements and nodes',
               2,
               u'fem:approx:fe:def:elements:nodes',
               u'fem:approx:fe:def:elements:nodes'),
              (u'Example', 3, None, '___sec62'),
              (u'The basis functions', 2, None, '___sec63'),
              (u'Construction principles', 3, None, '___sec64'),
              (u'Properties of $\\basphi_i$', 3, None, '___sec65'),
              (u'Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              (u'Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              (u'Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              (u'Calculating the linear system',
               2,
               u'fem:approx:global:linearsystem',
               u'fem:approx:global:linearsystem'),
              (u'Calculating specific matrix entries', 3, None, '___sec70'),
              (u'Calculating a general row in the matrix',
               3,
               None,
               '___sec71'),
              (u'Assembly of elementwise computations',
               2,
               u'fem:approx:fe:elementwise',
               u'fem:approx:fe:elementwise'),
              (u'The element matrix', 3, None, '___sec73'),
              (u'Assembly of element matrices', 3, None, '___sec74'),
              (u'Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              (u'The element vector', 3, None, '___sec76'),
              (u'Mapping to a reference element',
               2,
               u'fem:approx:fe:mapping',
               u'fem:approx:fe:mapping'),
              (u'The coordinate transformation', 3, None, '___sec78'),
              (u'Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              (u'Formulas for local basis functions', 3, None, '___sec80'),
              (u'Example on integration over a reference element',
               2,
               u'fem:approx:fe:intg:ref',
               u'fem:approx:fe:intg:ref'),
              (u'Implementation',
               1,
               u'fem:approx:fe:impl',
               u'fem:approx:fe:impl'),
              (u'Integration',
               2,
               u'fem:approx:fe:impl:intg',
               u'fem:approx:fe:impl:intg'),
              (u'Linear system assembly and solution',
               2,
               u'fem:approx:fe:impl:linsys',
               u'fem:approx:fe:impl:linsys'),
              (u'Example on computing symbolic approximations',
               2,
               u'fem:approx:fe:impl:ex1:symbolic',
               u'fem:approx:fe:impl:ex1:symbolic'),
              (u'Using interpolation instead of least squares',
               2,
               u'fem:approx:fe:impl:ex1:collocation',
               u'fem:approx:fe:impl:ex1:collocation'),
              (u'Example on computing numerical approximations',
               2,
               u'fem:approx:fe:impl:ex1:numeric',
               u'fem:approx:fe:impl:ex1:numeric'),
              (u'The structure of the coefficient matrix',
               2,
               u'fem:approx:fe:A:structure',
               u'fem:approx:fe:A:structure'),
              (u'Applications',
               2,
               u'fem:approx:fe:impl:ex2',
               u'fem:approx:fe:impl:ex2'),
              (u'Sparse matrix storage and solution',
               2,
               u'fem:approx:fe:impl:sparse',
               u'fem:approx:fe:impl:sparse'),
              (u'Comparison of finite elements and finite differences',
               1,
               u'fem:approx:fe:fd',
               u'fem:approx:fe:fd'),
              (u'Finite difference approximation of given functions',
               2,
               u'fem:approx:fe:fd:fdproj',
               u'fem:approx:fe:fd:fdproj'),
              (u'Interpretation of a finite element approximation in terms of finite difference operators',
               2,
               u'fem:approx:fe:fd:feproj',
               u'fem:approx:fe:fd:feproj'),
              (u'Making finite elements behave as finite differences',
               2,
               u'fem:deq:1D:approx:fem_vs_fdm',
               u'fem:deq:1D:approx:fem_vs_fdm'),
              (u'Computations in physical space', 3, None, '___sec95'),
              (u'Elementwise computations', 3, None, '___sec96'),
              (u'Terminology', 3, None, '___sec97'),
              (u'A generalized element concept',
               1,
               u'fem:approx:fe:element',
               u'fem:approx:fe:element'),
              (u'Cells, vertices, and degrees of freedom',
               2,
               u'fem:approx:fe:element:terminology',
               u'fem:approx:fe:element:terminology'),
              (u'Extended finite element concept',
               2,
               u'fem:approx:fe:element:def',
               u'fem:approx:fe:element:def'),
              (u'Implementation',
               2,
               u'fem:approx:fe:element:impl',
               u'fem:approx:fe:element:impl'),
              (u'Computing the error of the approximation',
               2,
               u'fem:approx:fe:error',
               u'fem:approx:fe:error'),
              (u'Example on cubic Hermite polynomials',
               2,
               u'fem:approx:fe:element:impl:Hermite',
               u'fem:approx:fe:element:impl:Hermite'),
              (u'Numerical integration', 1, None, '___sec104'),
              (u'Newton-Cotes rules',
               2,
               u'fem:approx:fe:numint1',
               u'fem:approx:fe:numint1'),
              (u'Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              (u'Finite elements in 2D and 3D', 1, None, '___sec107'),
              (u'Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              (u'Element matrices and vectors', 3, None, '___sec109'),
              (u'Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              (u'Affine mapping of the reference cell', 2, None, '___sec111'),
              (u'Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              (u'Computing integrals', 2, None, '___sec113'),
              (u'Implementation',
               1,
               u'fe:approx:fenics',
               u'fe:approx:fenics'),
              (u'Example on approximation in 2D using FEniCS',
               2,
               u'fem:approx:fenics:2D',
               u'fem:approx:fenics:2D'),
              (u'Mathematical problem', 3, None, '___sec116'),
              (u'The code', 3, None, '___sec117'),
              (u'Dissection of the code', 3, None, '___sec118'),
              (u'Integrating SymPy and FEniCS', 3, None, '___sec119'),
              (u'Refined code with curve plotting',
               2,
               u'fem:approx:fenics:2D:2',
               u'fem:approx:fenics:2D:2'),
              (u'Interpolation and projection', 3, None, '___sec121'),
              (u'Plotting the solution along a line', 3, None, '___sec122'),
              (u'Integrating plotting and computations',
               3,
               None,
               '___sec123'),
              (u'Exercises', 1, None, '___sec124'),
              (u'Problem 11: Define nodes and elements',
               2,
               u'fem:approx:fe:exer:mesh1',
               u'fem:approx:fe:exer:mesh1'),
              (u'Problem 12: Define vertices, cells, and dof maps',
               2,
               u'fem:approx:fe:exer:mesh2',
               u'fem:approx:fe:exer:mesh2'),
              (u'Problem 13: Construct matrix sparsity patterns',
               2,
               u'fem:approx:fe:exer:defmesh:sparsity',
               u'fem:approx:fe:exer:defmesh:sparsity'),
              (u'Problem 14: Perform symbolic finite element computations',
               2,
               u'fem:approx:fe:exer:Asinwt:symbolic',
               u'fem:approx:fe:exer:Asinwt:symbolic'),
              (u'Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               u'fem:approx:exer:tanh:P1P2',
               u'fem:approx:exer:tanh:P1P2'),
              (u'Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               u'fem:approx:exer:tanh:P3P4',
               u'fem:approx:exer:tanh:P3P4'),
              (u'Exercise 17: Investigate the approximation error in finite elements',
               2,
               u'fem:approx:fe:exer:Asinwt:interpol:error',
               u'fem:approx:fe:exer:Asinwt:interpol:error'),
              (u'Problem 18: Approximate a step function by finite elements',
               2,
               u'fem:approx:fe:exer:Heaviside',
               u'fem:approx:fe:exer:Heaviside'),
              (u'Exercise 19: 2D approximation with orthogonal functions',
               2,
               u'fem:approx:fe:exer:2Dsines:symbolic',
               u'fem:approx:fe:exer:2Dsines:symbolic'),
              (u'Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               u'fem:approx:fe:exer:1D:trapez',
               u'fem:approx:fe:exer:1D:trapez'),
              (u'Exercise 21: Compare P1 elements and interpolation',
               2,
               u'fem:approx:fe:exer:1D:P1:vs:interp',
               u'fem:approx:fe:exer:1D:P1:vs:interp'),
              (u'Exercise 22: Implement 3D computations with global basis functions',
               2,
               u'fem:approx:fe:exer:3D:approx3D',
               u'fem:approx:fe:exer:3D:approx3D'),
              (u"Exercise 23: Use Simpson's rule and P2 elements",
               2,
               u'fem:approx:fe:exer:1D:simpson',
               u'fem:approx:fe:exer:1D:simpson'),
              (u'Exercise 24: Make a 3D code for Lagrange elements of arbitrary order',
               2,
               None,
               '___sec138'),
              (u'Variational formulations with global basis functions',
               0,
               u'ch:varform:global',
               u'ch:varform:global'),
              (u'Basic principles for approximating differential equations',
               1,
               u'fem:deq:1D:principles',
               u'fem:deq:1D:principles'),
              (u'Differential equation models',
               2,
               u'fem:deq:1D:models',
               u'fem:deq:1D:models'),
              (u'Simple model problems and their solutions',
               2,
               u'fem:deq:1D:models:simple',
               u'fem:deq:1D:models:simple'),
              (u'Forming the residual',
               2,
               u'fem:deq:1D:residual:min',
               u'fem:deq:1D:residual:min'),
              (u'The least squares method', 2, None, '___sec144'),
              (u'The Galerkin method', 2, None, '___sec145'),
              (u'The method of weighted residuals', 2, None, '___sec146'),
              (u'Test and trial functions', 2, None, '___sec147'),
              (u'The collocation method', 2, None, '___sec148'),
              (u'The subdomain collocation method', 3, None, '___sec149'),
              (u'Examples on using the principles',
               2,
               u'fem:deq:1D:ex:sines',
               u'fem:deq:1D:ex:sines'),
              (u'The model problem', 3, None, '___sec151'),
              (u'Basis functions', 3, None, '___sec152'),
              (u'The residual', 3, None, '___sec153'),
              (u'The least squares method', 3, None, '___sec154'),
              (u'The Galerkin method', 3, None, '___sec155'),
              (u'The collocation method', 3, None, '___sec156'),
              (u'Comparison', 3, None, '___sec157'),
              (u'Integration by parts',
               2,
               u'fem:deq:1D:varform',
               u'fem:deq:1D:varform'),
              (u'Weak form', 3, None, '___sec159'),
              (u'Boundary function',
               2,
               u'fem:deq:1D:essBC:Bfunc',
               u'fem:deq:1D:essBC:Bfunc'),
              (u'Computing with global polynomials', 1, None, '___sec161'),
              (u'Computing with Dirichlet and Neumann conditions',
               2,
               u'fem:deq:1D:varform:ex:DN:case',
               u'fem:deq:1D:varform:ex:DN:case'),
              (u'When the numerical method is exact', 2, None, '___sec163'),
              (u'Abstract notation for variational formulations',
               2,
               u'fem:deq:1D:varform:abstract',
               u'fem:deq:1D:varform:abstract'),
              (u'Variational problems and minimization of functionals',
               2,
               u'fem:deq:1D:optimization',
               u'fem:deq:1D:optimization'),
              (u'Example', 3, None, '___sec166'),
              (u'The general minimization problem', 3, None, '___sec167'),
              (u'Derivation', 3, None, '___sec168'),
              (u'Minimization of the discretized functional',
               3,
               None,
               '___sec169'),
              (u'Calculus of variations', 3, None, '___sec170'),
              (u'Examples on variational formulations',
               1,
               u'fem:deq:1D:varform:ex',
               u'fem:deq:1D:varform:ex'),
              (u'Variable coefficient', 2, None, '___sec172'),
              (u'First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec173'),
              (u'Nonlinear coefficient', 2, None, '___sec174'),
              (u'Implementation of the algorithms',
               1,
               u'fem:global:deq:1D:code',
               u'fem:global:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:global',
               u'fem:deq:1D:code:global'),
              (u'Fallback on numerical methods', 2, None, '___sec177'),
              (u'Example with constant right-hand side',
               2,
               None,
               '___sec178'),
              (u'Approximations may fail: convection-diffusion',
               1,
               u'ch:convdiff',
               u'ch:convdiff'),
              (u'Exercises', 1, None, '___sec180'),
              (u'Exercise 25: Refactor functions into a more general class',
               2,
               u'fem:deq:exer:BVP1D:class',
               u'fem:deq:exer:BVP1D:class'),
              (u'Exercise 26: Compute the deflection of a cable with sine functions',
               2,
               u'fem:deq:exer:tension:cable',
               u'fem:deq:exer:tension:cable'),
              (u'Exercise 27: Compute the deflection of a cable with power functions',
               2,
               u'fem:deq:exer:tension:cable_xn',
               u'fem:deq:exer:tension:cable_xn'),
              (u'Exercise 28: Check integration by parts',
               2,
               u'fem:deq:exer:intg:parts',
               u'fem:deq:exer:intg:parts'),
              (u'Variational formulations with finite elements',
               0,
               u'ch:varform:fe',
               u'ch:varform:fe'),
              (u'Computing with finite elements',
               1,
               u'fem:deq:1D:fem1',
               u'fem:deq:1D:fem1'),
              (u'Finite element mesh and basis functions',
               2,
               None,
               '___sec187'),
              (u'Computation in the global physical domain',
               2,
               u'fem:deq:1D:comp:global',
               u'fem:deq:1D:comp:global'),
              (u'Comparison with a finite difference discretization',
               2,
               u'fem:deq:1D:fdm_vs_fem',
               u'fem:deq:1D:fdm_vs_fem'),
              (u'Cellwise computations',
               2,
               u'fem:deq:1D:comp:elmwise',
               u'fem:deq:1D:comp:elmwise'),
              (u'The integral for the element matrix', 3, None, '___sec191'),
              (u'The integral for the element vector', 3, None, '___sec192'),
              (u'Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec193'),
              (u'Contributions from the first and last cell',
               3,
               None,
               '___sec194'),
              (u'Assembly', 3, None, '___sec195'),
              (u'Boundary conditions: specified nonzero value',
               1,
               u'fem:deq:1D:essBC',
               u'fem:deq:1D:essBC'),
              (u'General construction of a boundary function',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc',
               u'fem:deq:1D:fem:essBC:Bfunc'),
              (u'Example on computing with a finite element-based boundary function',
               2,
               None,
               '___sec198'),
              (u'Computations in physical coordinates', 3, None, '___sec199'),
              (u'Cellwise computations on the reference element',
               3,
               None,
               '___sec200'),
              (u'Modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (u'Computations in the physical system', 3, None, '___sec202'),
              (u'Symmetric modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (u'Modification of the element matrix and vector',
               2,
               None,
               '___sec204'),
              (u'Boundary conditions: specified derivative',
               1,
               u'fem:deq:1D:BC:nat',
               u'fem:deq:1D:BC:nat'),
              (u'The variational formulation', 2, None, '___sec206'),
              (u'Boundary term vanishes because of the test functions',
               2,
               u'fem:deq:1D:BC:nat:uLtest',
               u'fem:deq:1D:BC:nat:uLtest'),
              (u'Boundary term vanishes because of linear system modifications',
               2,
               u'fem:deq:1D:BC:nat:uLmod',
               u'fem:deq:1D:BC:nat:uLmod'),
              (u'Direct computation of the global linear system',
               2,
               u'fem:deq:1D:BC:nat:Aub',
               u'fem:deq:1D:BC:nat:Aub'),
              (u'Cellwise computations', 2, None, '___sec210'),
              (u'Implementation of finite element algorithms',
               1,
               u'fem:deq:1D:code',
               u'fem:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:fe',
               u'fem:deq:1D:code:fe'),
              (u'Utilizing a sparse matrix',
               2,
               u'fem:deq:1D:code:fe_sparse',
               u'fem:deq:1D:code:fe_sparse'),
              (u'Application to our model problem', 2, None, '___sec214'),
              (u'Variational formulations in 2D and 3D',
               1,
               u'fem:deq:2D:varform',
               u'fem:deq:2D:varform'),
              (u'Integration by parts', 2, None, '___sec216'),
              (u'Example on a multi-dimensional variational problem',
               2,
               u'sec:varform:general:convdiff',
               u'sec:varform:general:convdiff'),
              (u'Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec218'),
              (u'Numerical integration', 2, None, '___sec219'),
              (u'Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec220'),
              (u'A glimpse of the mathematical theory of the finite element method',
               2,
               None,
               '___sec221'),
              (u'Abstract variational forms', 3, None, '___sec222'),
              (u'Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec223'),
              (u'Assumptions', 3, None, '___sec224'),
              (u'Existence and uniqueness', 3, None, '___sec225'),
              (u'Stability', 3, None, '___sec226'),
              (u'Equivalent minimization problem', 3, None, '___sec227'),
              (u'Best approximation principle', 3, None, '___sec228'),
              (u'Best approximation property in the norm of the space',
               3,
               None,
               '___sec229'),
              (u'Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec230'),
              (u'Equivalent matrix minimization problem',
               3,
               None,
               '___sec231'),
              (u'A priori error estimate for the derivative',
               3,
               None,
               '___sec232'),
              (u'A priori error estimate for the solution',
               3,
               None,
               '___sec233'),
              (u'Implementation in 2D and 3D via FEniCS',
               1,
               u'fem:varform:fenics',
               u'fem:varform:fenics'),
              (u'Mathematical problem',
               2,
               u'fem:varform:fenics:problem',
               u'fem:varform:fenics:problem'),
              (u'Symmetry', 3, None, '___sec236'),
              (u'Variational formulation',
               2,
               u'fem:varform:fenics:varform',
               u'fem:varform:fenics:varform'),
              (u'The FEniCS solver', 2, None, '___sec238'),
              (u'Making the mesh', 2, None, '___sec239'),
              (u'Solving a problem', 2, None, '___sec240'),
              (u'Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec241'),
              (u'Summary', 1, None, '___sec242'),
              (u'Exercises', 1, None, '___sec243'),
              (u'Exercise 29: Compute the deflection of a cable with 2 P1 elements',
               2,
               u'fem:deq:exer:cable:2P1',
               u'fem:deq:exer:cable:2P1'),
              (u'Exercise 30: Compute the deflection of a cable with 1 P2 element',
               2,
               u'fem:deq:exer:cable:1P2',
               u'fem:deq:exer:cable:1P2'),
              (u'Exercise 31: Compute the deflection of a cable with a step load',
               2,
               u'fem:deq:exer:cable:stepload',
               u'fem:deq:exer:cable:stepload'),
              (u'Exercise 32: Compute with a non-uniform mesh',
               2,
               u'fem:deq:exer:1D:mesh:nonuniform',
               u'fem:deq:exer:1D:mesh:nonuniform'),
              (u'Problem 33: Solve a 1D finite element problem by hand',
               2,
               u'fem:deq:exer:1D:gen:problem1',
               u'fem:deq:exer:1D:gen:problem1'),
              (u'Exercise 34: Investigate exact finite element solutions',
               2,
               u'fem:deq:exer:1D:exact_numerics',
               u'fem:deq:exer:1D:exact_numerics'),
              (u'Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               u'fem:deq:exer:1D:Poisson:polar',
               u'fem:deq:exer:1D:Poisson:polar'),
              (u'Exercise 36: Compute with variable coefficients and P1 elements by hand',
               2,
               u'fem:deq:exer:1D:gen:problem2',
               u'fem:deq:exer:1D:gen:problem2'),
              (u'Exercise 37: Solve a 2D Poisson equation using polynomials and sines',
               2,
               u'fem:deq:exer:2D:torsion:xy:sin',
               u'fem:deq:exer:2D:torsion:xy:sin'),
              (u'Time-dependent variational forms',
               0,
               u'ch:femtime',
               u'ch:femtime'),
              (u'Discretization in time by a Forward Euler scheme',
               1,
               u'fem:deq:diffu:FE',
               u'fem:deq:diffu:FE'),
              (u'Time discretization', 2, None, '___sec255'),
              (u'Space discretization', 2, None, '___sec256'),
              (u'Variational forms', 2, None, '___sec257'),
              (u'Notation for the solution at recent time levels',
               2,
               None,
               '___sec258'),
              (u'Deriving the linear systems', 2, None, '___sec259'),
              (u'Computational algorithm', 2, None, '___sec260'),
              (u'Example using sinusoidal basis functions',
               2,
               u'fem:deq:diffu:FE:cosex',
               u'fem:deq:diffu:FE:cosex'),
              (u'Comparing P1 elements with the finite difference method',
               2,
               u'fem:deq:diffu:FE:fdvsP1fe',
               u'fem:deq:diffu:FE:fdvsP1fe'),
              (u'Lumping the mass matrix', 3, None, '___sec263'),
              (u'Discretization in time by a Backward Euler scheme',
               1,
               u'fem:deq:diffu:BE',
               u'fem:deq:diffu:BE'),
              (u'Time discretization', 2, None, '___sec265'),
              (u'Variational forms', 2, None, '___sec266'),
              (u'Linear systems', 2, None, '___sec267'),
              (u'Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec268'),
              (u'Dirichlet boundary conditions',
               1,
               u'fem:deq:diffu:Dirichlet',
               u'fem:deq:diffu:Dirichlet'),
              (u'Boundary function', 2, None, '___sec270'),
              (u'Finite element basis functions', 2, None, '___sec271'),
              (u'Modification of the linear system', 2, None, '___sec272'),
              (u'Example: Oscillating Dirichlet boundary condition',
               2,
               u'fem:deq:diffu:Dirichlet:ex',
               u'fem:deq:diffu:Dirichlet:ex'),
              (u'Accuracy of the finite element solution',
               1,
               u'fem:deq:diffu:anal',
               u'fem:deq:diffu:anal'),
              (u'Illustrating example', 2, None, '___sec275'),
              (u'Methods of analysis', 2, None, '___sec276'),
              (u'Fourier components and dispersion relations',
               2,
               None,
               '___sec277'),
              (u'Forward Euler discretization', 2, None, '___sec278'),
              (u'Backward Euler discretization', 2, None, '___sec279'),
              (u'Comparing amplification factors', 2, None, '___sec280'),
              (u'Exercises', 1, None, '___sec281'),
              (u'Exercise 38: Analyze a Crank-Nicolson scheme for the diffusion equation',
               2,
               u'fem:deq:exer:diffu:analysis:CN',
               u'fem:deq:exer:diffu:analysis:CN'),
              (u'Variational forms for systems of PDEs',
               0,
               u'ch:femsys',
               u'ch:femsys'),
              (u'Variational forms', 1, u'fem:sys:vform', u'fem:sys:vform'),
              (u'Sequence of scalar PDEs formulation', 2, None, '___sec285'),
              (u'Vector PDE formulation', 2, None, '___sec286'),
              (u'A worked example', 1, u'fem:sys:uT:ex', u'fem:sys:uT:ex'),
              (u'Identical function spaces for the unknowns',
               1,
               None,
               '___sec288'),
              (u'Variational form of each individual PDE',
               2,
               None,
               '___sec289'),
              (u'Compound scalar variational form', 2, None, '___sec290'),
              (u'Decoupled linear systems', 2, None, '___sec291'),
              (u'Coupled linear systems', 2, None, '___sec292'),
              (u'Different function spaces for the unknowns',
               1,
               None,
               '___sec293'),
              (u'Computations in 1D',
               1,
               u'femsys:cooling:1D',
               u'femsys:cooling:1D'),
              (u'Another example in 1D',
               2,
               u'fem:sys:up:1D',
               u'fem:sys:up:1D'),
              (u'Exercises', 1, None, '___sec296'),
              (u'Problem 39: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:1',
               u'femsys:exer:cooling:1'),
              (u'Problem 40: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:2',
               u'femsys:exer:cooling:2'),
              (u'Flexible implementations of boundary conditions',
               0,
               u'ch:nitsche',
               u'ch:nitsche'),
              (u'Optimization with constraint',
               1,
               u'nitsche:fxy:opt',
               u'nitsche:fxy:opt'),
              (u'Elimination of variables', 2, None, '___sec301'),
              (u'Lagrange multiplier method',
               2,
               u'nitsche:fxy:opt:Lagrange',
               u'nitsche:fxy:opt:Lagrange'),
              (u'Penalty method',
               2,
               u'nitsche:fxy:opt:penalty',
               u'nitsche:fxy:opt:penalty'),
              (u'Optimization of functionals',
               1,
               u'nitsche:pde:opt',
               u'nitsche:pde:opt'),
              (u'Classical calculus of variations',
               2,
               u'nitsche:pde:opt:varcalculus',
               u'nitsche:pde:opt:varcalculus'),
              (u'Penalty method for optimization with constraints',
               2,
               u'nitsche:pde:opt:penalty',
               u'nitsche:pde:opt:penalty'),
              (u'Lagrange multiplier method for optimization with constraints',
               2,
               u'nitsche:pde:opt:Lagrange',
               u'nitsche:pde:opt:Lagrange'),
              (u'Example: 1D problem',
               2,
               u'nitsche:pde:opt:1Dex',
               u'nitsche:pde:opt:1Dex'),
              (u'Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec309'),
              (u'Nonlinear problems', 0, u'ch:nonlin', u'ch:nonlin'),
              (u'Introduction of basic concepts',
               1,
               u'nonlin:timediscrete:logistic',
               u'nonlin:timediscrete:logistic'),
              (u'Linear versus nonlinear equations', 2, None, '___sec312'),
              (u'Algebraic equations', 3, None, '___sec313'),
              (u'Differential equations', 3, None, '___sec314'),
              (u'A simple model problem', 2, None, '___sec315'),
              (u'Linearization by explicit time discretization',
               2,
               u'nonlin:timediscrete:logistic:FE',
               u'nonlin:timediscrete:logistic:FE'),
              (u'Exact solution of nonlinear algebraic equations',
               2,
               u'nonlin:timediscrete:logistic:roots',
               u'nonlin:timediscrete:logistic:roots'),
              (u'Linearization', 2, None, '___sec318'),
              (u'Picard iteration',
               2,
               u'nonlin:timediscrete:logistic:Picard',
               u'nonlin:timediscrete:logistic:Picard'),
              (u'Stopping criteria', 3, None, '___sec320'),
              (u'A single Picard iteration', 3, None, '___sec321'),
              (u'Linearization by a geometric mean',
               2,
               u'nonlin:timediscrete:logistic:geometric:mean',
               u'nonlin:timediscrete:logistic:geometric:mean'),
              (u"Newton's method",
               2,
               u'nonlin:timediscrete:logistic:Newton',
               u'nonlin:timediscrete:logistic:Newton'),
              (u'Relaxation',
               2,
               u'nonlin:timediscrete:logistic:relaxation',
               u'nonlin:timediscrete:logistic:relaxation'),
              (u'Implementation and experiments',
               2,
               u'nonlin:timediscrete:logistic:impl',
               u'nonlin:timediscrete:logistic:impl'),
              (u'Generalization to a general nonlinear ODE',
               2,
               u'nonlin:ode:generic',
               u'nonlin:ode:generic'),
              (u'Explicit time discretization', 3, None, '___sec327'),
              (u'Backward Euler discretization', 3, None, '___sec328'),
              (u'Crank-Nicolson discretization', 3, None, '___sec329'),
              (u'Systems of ODEs',
               2,
               u'nonlin:ode:generic:sys:pendulum',
               u'nonlin:ode:generic:sys:pendulum'),
              (u'Example', 3, None, '___sec331'),
              (u'Systems of nonlinear algebraic equations',
               1,
               u'nonlin:systems:alg',
               u'nonlin:systems:alg'),
              (u'Picard iteration',
               2,
               u'nonlin:systems:alg:Picard',
               u'nonlin:systems:alg:Picard'),
              (u"Newton's method",
               2,
               u'nonlin:systems:alg:Newton',
               u'nonlin:systems:alg:Newton'),
              (u'Stopping criteria',
               2,
               u'nonlin:systems:alg:terminate',
               u'nonlin:systems:alg:terminate'),
              (u'Example: A nonlinear ODE model from epidemiology',
               2,
               u'nonlin:systems:alg:SI',
               u'nonlin:systems:alg:SI'),
              (u'Implicit time discretization', 3, None, '___sec337'),
              (u'A Picard iteration', 3, None, '___sec338'),
              (u"Newton's method", 3, None, '___sec339'),
              (u'Linearization at the differential equation level',
               1,
               u'nonlin:pdelevel',
               u'nonlin:pdelevel'),
              (u'Explicit time integration',
               2,
               u'nonlin:pdelevel:explicit',
               u'nonlin:pdelevel:explicit'),
              (u'Backward Euler scheme and Picard iteration',
               2,
               u'nonlin:pdelevel:Picard',
               u'nonlin:pdelevel:Picard'),
              (u"Backward Euler scheme and Newton's method",
               2,
               u'nonlin:pdelevel:Newton',
               u'nonlin:pdelevel:Newton'),
              (u'Linearization via Taylor expansions', 3, None, '___sec344'),
              (u'Similarity with Picard iteration', 3, None, '___sec345'),
              (u'Implementation', 3, None, '___sec346'),
              (u'Derivation with alternative notation', 3, None, '___sec347'),
              (u'Crank-Nicolson discretization',
               2,
               u'nonlin:pdelevel:Picard:CN',
               u'nonlin:pdelevel:Picard:CN'),
              (u'1D stationary nonlinear differential equations',
               1,
               u'nonlin:alglevel:1D',
               u'nonlin:alglevel:1D'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:1D:fd',
               u'nonlin:alglevel:1D:fd'),
              (u'Solution of algebraic equations', 2, None, '___sec351'),
              (u'The structure of the equation system', 3, None, '___sec352'),
              (u'Picard iteration', 3, None, '___sec353'),
              (u'Mesh with two cells', 3, None, '___sec354'),
              (u"Newton's method", 3, None, '___sec355'),
              (u'Multi-dimensional PDE problems', 1, None, '___sec356'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:dD:fd',
               u'nonlin:alglevel:dD:fd'),
              (u'Picard iteration', 3, None, '___sec358'),
              (u"Newton's method", 3, None, '___sec359'),
              (u'Continuation methods', 2, None, '___sec360'),
              (u'Exercises', 1, u'nonlin:exer', u'nonlin:exer'),
              (u'Problem 41: Determine if equations are nonlinear or not',
               2,
               u'nonlin:exer:lin:vs:nonlin',
               u'nonlin:exer:lin:vs:nonlin'),
              (u'Exercise 42: Derive and investigate a generalized logistic model',
               2,
               u'nonlin:exer:logistic:gen',
               u'nonlin:exer:logistic:gen'),
              (u"Problem 43: Experience the behavior of Newton's method",
               2,
               u'nonlin:exer:Newton:problems1',
               u'nonlin:exer:Newton:problems1'),
              (u'Problem 44: Compute the Jacobian of a $2\\times 2$ system',
               2,
               u'nonlin:exer:vib:Jacobian',
               u'nonlin:exer:vib:Jacobian'),
              (u'Problem 45: Solve nonlinear equations arising from a vibration ODE',
               2,
               u'nonlin:exer:vib:geometric:mean',
               u'nonlin:exer:vib:geometric:mean'),
              (u'Exercise 46: Find the truncation error of arithmetic mean of products',
               2,
               u'nonlin:exer:products:arith:mean',
               u'nonlin:exer:products:arith:mean'),
              (u"Problem 47: Newton's method for linear problems",
               2,
               u'nonlin:exer:Newton:linear',
               u'nonlin:exer:Newton:linear'),
              (u'Exercise 48: Discretize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:fem',
               u'nonlin:exer:1D:1pu2:fem'),
              (u'Exercise 49: Linearize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:PicardNewton',
               u'nonlin:exer:1D:1pu2:PicardNewton'),
              (u'Problem 50: Finite differences for the 1D Bratu problem',
               2,
               u'nonlin:exer:1D:fu:discretize:fd',
               u'nonlin:exer:1D:fu:discretize:fd'),
              (u'Exercise 51: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               u'nonlin:exer:1D:heat:nonlinear:fdm',
               u'nonlin:exer:1D:heat:nonlinear:fdm'),
              (u'Exercise 52: Differentiate a highly nonlinear term',
               2,
               u'nonlin:exer:grad:pow:term',
               u'nonlin:exer:grad:pow:term'),
              (u'Exercise 53: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               u'nonlin:exer:2D:heat:nonlinear:fd',
               u'nonlin:exer:2D:heat:nonlinear:fd'),
              (u'Exercise 54: Find the sparsity of the Jacobian',
               2,
               u'nonlin:exer:sparsity:Jacobian',
               u'nonlin:exer:sparsity:Jacobian'),
              (u'Problem 55: Investigate a 1D problem with a continuation method',
               2,
               u'nonlin:exer:continuation:1DnNflow',
               u'nonlin:exer:continuation:1DnNflow'),
              (u'Symbolic nonlinear finite element equations',
               1,
               u'nonlin:app:fem_vs_fdm',
               u'nonlin:app:fem_vs_fdm'),
              (u'Finite element basis functions',
               2,
               u'nonlin:alglevel:1D:fe_basis',
               u'nonlin:alglevel:1D:fe_basis'),
              (u'The group finite element method',
               2,
               u'nonlin:alglevel:1D:fe:group',
               u'nonlin:alglevel:1D:fe:group'),
              (u'Finite element approximation of functions of $u$',
               3,
               None,
               '___sec380'),
              (u'Simplified problem', 3, None, '___sec381'),
              (u'Integrating nonlinear functions', 3, None, '___sec382'),
              (u'Application of the group finite element method',
               3,
               None,
               '___sec383'),
              (u'Numerical integration of nonlinear terms by hand',
               2,
               u'nonlin:alglevel:1D:fe:f',
               u'nonlin:alglevel:1D:fe:f'),
              (u'Discretization of a variable coefficient Laplace term',
               2,
               u'nonlin:alglevel:1D:fe:Laplace',
               u'nonlin:alglevel:1D:fe:Laplace'),
              (u'Group finite element method', 3, None, '___sec386'),
              (u'Numerical integration at the nodes', 3, None, '___sec387'),
              (u'Uncertainty quantification and polynomial chaos expansions',
               0,
               u'ch:pc',
               u'ch:pc'),
              (u'Sample problems', 1, None, '___sec389'),
              (u'ODE for decay processes', 2, None, '___sec390'),
              (u'The stochastic Poisson equation', 2, None, '___sec391'),
              (u'Basic principles', 1, None, '___sec392'),
              (u'Basic statistical results', 2, None, '___sec393'),
              (u'Least-squares methods', 2, None, '___sec394'),
              (u'Example: Least squares applied to the decay ODE',
               2,
               None,
               '___sec395'),
              (u'Modeling the response', 2, None, '___sec396'),
              (u'Numerical integration', 2, None, '___sec397'),
              (u'Stochastic collocation', 2, None, '___sec398'),
              (u'The Chaospy software', 1, u'pc:chaospy', u'pc:chaospy'),
              (u'Intrusive polynomial chaos methods',
               1,
               u'pc:intrusive',
               u'pc:intrusive'),
              (u'Variational methods for linear systems',
               0,
               u'ch:cg',
               u'ch:cg'),
              (u'Conjugate gradient-like iterative methods',
               1,
               u'ch:linalg:CGmethods',
               u'ch:linalg:CGmethods'),
              (u'The Galerkin method', 2, None, '___sec403'),
              (u'The least squares method', 2, None, '___sec404'),
              (u'Krylov subspaces', 2, None, '___sec405'),
              (u'Computation of the basis vectors', 2, None, '___sec406'),
              (u'Computation of a new solution vector', 2, None, '___sec407'),
              (u'Summary of the least squares method', 2, None, '___sec408'),
              (u'Remark', 3, None, '___sec409'),
              (u'Truncation and restart', 2, None, '___sec410'),
              (u'Summary of the Galerkin method', 2, None, '___sec411'),
              (u'A framework based on the error', 2, None, '___sec412'),
              (u'Preconditioning',
               1,
               u'ch:linalg2:preconditioning',
               u'ch:linalg2:preconditioning'),
              (u'Motivation and Basic Principles', 2, None, '___sec414'),
              (u'Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec415'),
              (u'Classical iterative methods as preconditioners',
               2,
               u'ch:linalg:SORprecond',
               u'ch:linalg:SORprecond'),
              (u'Incomplete factorization preconditioners',
               2,
               u'linalg:ILU',
               u'linalg:ILU'),
              (u'Appendix: Useful formulas',
               0,
               u'ch:formulas',
               u'ch:formulas'),
              (u'Finite difference operator notation',
               1,
               u'sec:form:fdop',
               u'sec:form:fdop'),
              (u'Truncation errors of finite difference approximations',
               1,
               u'sec:form:truncerr',
               u'sec:form:truncerr'),
              (u'Finite differences of exponential functions',
               1,
               u'sec:form:fdexp',
               u'sec:form:fdexp'),
              (u'Complex exponentials', 3, None, '___sec422'),
              (u'Real exponentials', 3, None, '___sec423'),
              (u'Finite differences of $t^n$',
               1,
               u'sec:form:fdtn',
               u'sec:form:fdtn'),
              (u'Software', 2, None, '___sec425'),
              (u'References', 1, None, '___sec426')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0024"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized023.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized025.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:deq:2D:varform">Variational formulations in 2D and 3D</h1>

<p>
The major difference between deriving variational formulations in 2D
and 3D compared to 1D is the rule for integrating by parts.  The cells
have shapes different from an interval, so basis functions look a bit
different, and there is a technical difference in actually calculating
the integrals over cells. Otherwise, going to 2D and 3D is not a big
step from 1D. All the fundamental ideas still apply.

<h2 id="___sec216">Integration by parts </h2>

<p>
A typical second-order term in a PDE may be written in dimension-independent
notation as

$$ \nabla^2 u \quad\hbox{or}\quad \nabla\cdot\left( \dfc(\x)\nabla u\right)
\tp
$$

The explicit forms in a 2D problem become
$$ \nabla^2 u = \nabla\cdot\nabla u =
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2},
$$

and
$$
\nabla\cdot\left( a(\x)\nabla u\right) =
\frac{\partial}{\partial x}\left( \dfc(x,y)\frac{\partial u}{\partial x}\right) +
\frac{\partial}{\partial y}\left( \dfc(x,y)\frac{\partial u}{\partial y}\right)
\tp
$$

We shall continue with the latter operator as the former arises from
just setting \( \dfc =1 \).

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>The integration by parts formula for \( \int\nabla\cdot(\dfc\nabla) \).</b>
<p>
The general rule for integrating by parts is often referred to as
<a href="http://en.wikipedia.org/wiki/Green's_identities" target="_self">Green's first identity</a>:

$$
\begin{equation}
-\int_{\Omega} \nabla\cdot (\dfc(\x)\nabla u) v\dx =
\int_{\Omega} \dfc(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds,
\tag{225}
\end{equation}
$$

where \( \partial\Omega \) is the boundary of \( \Omega \) and
\( \partial u/\partial n = \normalvec\cdot\nabla u \) is the derivative
of \( u \) in the outward normal direction, \( \normalvec \) being an outward
unit normal to \( \partial\Omega \). The integrals \( \int_\Omega ()\dx \) are
area integrals in 2D and volume integrals in 3D, while
\( \int_{\partial\Omega} ()\ds \) is a line integral in 2D and a surface
integral in 3D.
</div>


<p>
It will be convenient to divide the boundary into two parts:

<ul>
 <li> \( \partial\Omega_N \), where we have Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \), and</li>
 <li> \( \partial\Omega_D \), where we have Dirichlet conditions
   \( u = u_0 \).</li>
</ul>

The test functions \( v \) are (as usual) required to vanish on
\( \partial\Omega_D \).

<h2 id="sec:varform:general:convdiff">Example on a multi-dimensional variational problem</h2>

<p>
Here is a quite general, stationary, linear PDE arising in many problems:

$$
\begin{align}
\tag{226}
\v\cdot\nabla u + \beta u &= \nabla\cdot\left( \dfc\nabla u\right) + f,
\quad\x\in\Omega,\\ 
\tag{227}
u &= u_0,\quad\x\in\partial\Omega_D,\\ 
\tag{228}
-\dfc\frac{\partial u}{\partial n} &= g,\quad\x\in\partial\Omega_N
\tp
\end{align}
$$

The vector field \( \v \) and the scalar functions \( a \), \( \alpha \), \( f \), \( u_0 \), and
\( g \) may vary with the spatial coordinate \( \x \) and must be known.

<p>
Such a second-order PDE needs exactly one boundary condition at each
point of the boundary, so \( \partial\Omega_N\cup\partial\Omega_D \)
must be the complete boundary \( \partial\Omega \).

<p>
Assume that the boundary function \( u_0(\x) \) is defined for all \( \x\in\Omega \).
The unknown function can then be expanded as

$$ u = B + \sum_{j\in\If} c_j\baspsi_j,\quad B = u_0 \tp $$

As long as any \( \baspsi_j=0 \) on \( \partial\Omega_D \), we realize that \( u=u_0 \)
on \( \partial\Omega_D \).

<p>
The variational formula is obtained from Galerkin's method, which
technically means multiplying the PDE by a test
function \( v \) and integrating over \( \Omega \):

$$
\int_{\Omega} (\v\cdot\nabla u + \beta u)v\dx =
\int_{\Omega} \nabla\cdot\left( \dfc\nabla u\right)\dx + \int_{\Omega}fv \dx
\tp
$$

The second-order term is integrated by parts, according to the formula
<a href="#mjx-eqn-225">(225)</a>:

$$
\int_{\Omega} \nabla\cdot\left( \dfc\nabla u\right)v \dx =
-\int_{\Omega} \dfc\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} \dfc\frac{\partial u}{\partial n} v\ds
\tp
$$

Galerkin's method therefore leads to

$$
\int_{\Omega} (\v\cdot\nabla u + \beta u)v\dx =
-\int_{\Omega} \dfc\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} \dfc\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
\tp
$$

The boundary term can be developed further by noticing that \( v\neq 0 \)
only on \( \partial\Omega_N \),

$$ \int_{\partial\Omega} \dfc\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} \dfc\frac{\partial u}{\partial n} v\ds,
$$

and that on \( \partial\Omega_N \), we have the condition
\( a\frac{\partial u}{\partial n}=-g \), so the term becomes

$$
-\int_{\partial\Omega_N} gv\ds\tp
$$

The final variational form is then

$$
\int_{\Omega} (\v\cdot\nabla u + \beta u)v\dx =
-\int_{\Omega} \dfc\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega_N} g v\ds
+ \int_{\Omega} fv \dx
\tp
$$

<p>
Instead of using the integral signs, we may use the inner product
notation:

$$
(\v\cdot\nabla u, v) + (\beta u,v) =
- (\dfc\nabla u,\nabla v) - (g,v)_{N} + (f,v)
\tp
$$

The subscript \( \,{}_N \) in \( (g,v)_{N} \) is a notation for a line or surface
integral over \( \partial\Omega_N \), while \( (\cdot,\cdot) \) is the area/volume
integral over \( \Omega \).

<p>
We can derive explicit expressions for the linear system for \( \sequencej{c} \)
that arises from the variational formulation.
Inserting the \( u \) expansion results in

$$
\begin{align*}
\sum_{j\in\If} ((\v\cdot\nabla \baspsi_j, \baspsi_i) &+ (\beta \baspsi_j ,\baspsi_i) + (\dfc\nabla \baspsi_j,\nabla \baspsi_i))c_j = \\ 
& (g,\baspsi_i)_{N} + (f,\baspsi_i) -
(\v\cdot\nabla u_0, \baspsi_i) + (\beta u_0 ,\baspsi_i) +
(\dfc\nabla u_0,\nabla \baspsi_i)
\tp
\end{align*}
$$

This is a linear system with matrix entries

$$
A_{i,j} = (\v\cdot\nabla \baspsi_j, \baspsi_i) + (\beta \baspsi_j ,\baspsi_i) + (\dfc\nabla \baspsi_j,\nabla \baspsi_i)
$$

and right-hand side entries

$$
b_i = (g,\baspsi_i)_{N} + (f,\baspsi_i) -
(\v\cdot\nabla u_0, \baspsi_i) + (\beta u_0 ,\baspsi_i) +
(\dfc\nabla u_0,\nabla \baspsi_i),
$$

for \( i,j\in\If \).

<p>
In the finite element method, we usually express \( u_0 \) in terms of
basis functions and restrict \( i \) and \( j \) to run over the degrees of
freedom that are not prescribed as Dirichlet conditions.
However, we can also keep all the \( \sequencej{c} \) as unknowns,
drop the \( u_0 \) in the expansion for \( u \), and incorporate all the
known \( c_j \) values in the linear system. This has been explained
in detail in the 1D case, and the technique is the same for 2D and
3D problems.

<h2 id="___sec218">Transformation to a reference cell in 2D and 3D </h2>

<p>
The real power of the finite element method first becomes evident when
we want to solve partial differential equations posed on two- and
three-dimensional domains of non-trivial geometric shape.  As in 1D,
the domain \( \Omega \) is divided into \( N_e \) non-overlapping cells. The
elements have simple shapes: triangles and quadrilaterals are popular
in 2D, while tetrahedra and box-shapes elements dominate in 3D.  The
finite element basis functions \( \basphi_i \) are, as in 1D, polynomials
over each cell.  The integrals in the variational formulation are, as
in 1D, split into contributions from each cell, and these
contributions are calculated by mapping a physical cell, expressed in
physical coordinates \( \x \), to a reference cell in a local coordinate
system \( \X \). This mapping will now be explained in detail.

<p>
We consider an integral of the type

$$
\begin{equation}
\int_{{\Omega}^{(e)}} \dfc(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx,
\tag{229}
\end{equation}
$$

where the \( \basphi_i \) functions are finite element basis functions in
2D or 3D, defined in the physical domain.
Suppose we want to calculate this integral over a reference cell,
denoted by \( \tilde\Omega^r \), in a coordinate system with coordinates
\( \X = (X_0, X_1) \) (2D) or \( \X = (X_0, X_1, X_2) \) (3D).
The mapping between a point \( \X \) in the reference coordinate system  and
the corresponding point \( \x \) in the physical coordinate system is
given by a vector relation \( \x(\X) \).
The corresponding Jacobian, \( J \), of this mapping has entries
$$ J_{i,j}=\frac{\partial x_j}{\partial X_i}\tp $$

<p>
The change of variables requires \( \dx \) to be replaced by \( \det J\dX \).
The derivatives in the \( \nabla \) operator in the variational form are
with respect to \( \x \), which we may denote by \( \nabla_{\x} \).
The \( \basphi_i(\x) \) functions in the integral
are replaced by local basis functions \( \refphi_r(\X) \) so
the integral features \( \nabla_{\x}\refphi_r(\X) \). We readily have
\( \nabla_{\X}\refphi_r(\X) \) from formulas for the basis functions in
the reference cell, but
the desired quantity \( \nabla_{\x}\refphi_r(\X) \) requires some efforts
to compute. All the details are provided below.

<p>
Let \( i=q(e,r) \) and consider two space dimensions. By the chain rule,

$$
\frac{\partial \refphi_r}{\partial X} =
\frac{\partial \basphi_i}{\partial X} =
\frac{\partial \basphi_i}{\partial x}\frac{\partial x}{\partial X} +
\frac{\partial \basphi_i}{\partial y}\frac{\partial y}{\partial X},
$$

and
$$
\frac{\partial \refphi_r}{\partial Y} =
\frac{\partial \basphi_i}{\partial Y} =
\frac{\partial \basphi_i}{\partial x}\frac{\partial x}{\partial Y} +
\frac{\partial \basphi_i}{\partial y}\frac{\partial y}{\partial Y}
\tp
$$

We can write these two equations as a vector equation
$$
\left[\begin{array}{c}
\frac{\partial \refphi_r}{\partial X}\\ 
\frac{\partial \refphi_r}{\partial Y}
\end{array}\right]
=
\left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial y}{\partial X}\\ 
\frac{\partial x}{\partial Y} & \frac{\partial y}{\partial Y}
\end{array}\right]
\left[\begin{array}{c}
\frac{\partial \basphi_i}{\partial x}\\ 
\frac{\partial \basphi_i}{\partial y}
\end{array}\right]
$$

Identifying
$$ \nabla_{\X}\refphi_r = \left[\begin{array}{c}
\frac{\partial \refphi_r}{\partial X}\\ 
\frac{\partial \refphi_r}{\partial Y}
\end{array}\right],
\quad
J =
\left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial y}{\partial X}\\ 
\frac{\partial x}{\partial Y} & \frac{\partial y}{\partial Y}
\end{array}\right],
\quad
\nabla_{\x}\basphi_r =
\left[\begin{array}{c}
\frac{\partial \basphi_i}{\partial x}\\ 
\frac{\partial \basphi_i}{\partial y}
\end{array}\right],
$$

we have the relation

$$ \nabla_{\X}\refphi_r = J\cdot\nabla_{\x}\basphi_i,$$

which we can solve with respect to \( \nabla_{\x}\basphi_i \):

$$
\begin{equation}
\nabla_{\x}\basphi_i = J^{-1}\cdot\nabla_{\X}\refphi_r\tp
\tag{230}
\end{equation}
$$

On the reference cell, \( \basphi_i(\x) = \refphi_r(\X) \), so

$$
\begin{equation}
\nabla_{\x}\refphi_r(\X) = J^{-1}(\X)\cdot\nabla_{\X}\refphi_r(\X)\tp
\tag{231}
\end{equation}
$$

<p>
This means that we have the following transformation of the
integral in the physical domain to its counterpart over the reference cell:

$$
\begin{equation}
\int_{\Omega^{(e)}} \dfc(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx =
\int_{\tilde\Omega^r} \dfc(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\tag{232}
\end{equation}
$$

<h2 id="___sec219">Numerical integration </h2>

<p>
Integrals are normally computed by numerical integration rules.
For multi-dimensional cells, various families of rules exist.
All of them are similar to what is shown in 1D:
\( \int f \dx\approx \sum_jw_if(\x_j) \), where \( w_j \) are weights and
\( \x_j \) are corresponding points.

<p>
The file <a href="http://tinyurl.com/znpudbt/numint.py" target="_self"><tt>numint.py</tt></a> contains the functions
<code>quadrature_for_triangles(n)</code> and <code>quadrature_for_tetrahedra(n)</code>,
which returns lists of points and weights corresponding to integration
rules with <code>n</code> points over the reference triangle
with vertices \( (0,0) \), \( (1,0) \), \( (0,1) \), and the reference tetrahedron
with vertices \( (0,0,0) \), \( (1,0,0) \), \( (0,1,0) \), \( (0,0,1) \),
respectively. For example, the first two rules for integration over
a triangle have 1 and 3 points:

<p>
<!-- begin verbatim block  ipy-->
<pre><code>&gt;&gt;&gt; import numint
&gt;&gt;&gt; x, w = numint.quadrature_for_triangles(num_points=1)
&gt;&gt;&gt; x
[(0.3333333333333333, 0.3333333333333333)]
&gt;&gt;&gt; w
[0.5]
&gt;&gt;&gt; x, w = numint.quadrature_for_triangles(num_points=3)
&gt;&gt;&gt; x
[(0.16666666666666666, 0.16666666666666666),
 (0.66666666666666666, 0.16666666666666666),
 (0.16666666666666666, 0.66666666666666666)]
&gt;&gt;&gt; w
[0.16666666666666666, 0.16666666666666666, 0.16666666666666666]
</code></pre>
<!-- end verbatim block -->
Rules with 1, 3, 4, and 7 points over the triangle will exactly integrate
polynomials of degree 1, 2, 3, and 4, respectively.
In 3D, rules with 1, 4, 5, and 11 points over the tetrahedron will
exactly integrate polynomials of degree 1, 2, 3, and 4, respectively.

<h2 id="___sec220">Convenient formulas for P1 elements in 2D </h2>

<p>
We shall now provide some formulas for piecewise linear \( \basphi_i \) functions
and their integrals <em>in the physical coordinate system</em>.
These formulas make it convenient to compute with P1 elements without
the need to work in the reference coordinate system and deal with mappings
and Jacobians.
A lot of computational and algorithmic details are hidden by this approach.

<p>
Let \( \Omega^{(e)} \) be cell number \( e \), and let the three vertices
have global vertex numbers \( I \), \( J \), and \( K \).
The corresponding coordinates are
\( (\xno{I},\yno{I}) \), \( (\xno{J},\yno{J}) \), and \( (\xno{K},\yno{K}) \).
The basis function \( \basphi_I \) over \( \Omega^{(e)} \) have the explicit
formula

$$
\begin{equation}
\basphi_I (x,y) = \half\Delta \left( \alpha_I + \beta_Ix
+ \gamma_Iy\right),
\tag{233}
\end{equation}
$$

where
<!-- must split align in two because we need an array with &amp; and \\ -->
<!-- (sphinx, ipynb, pandoc requires splitting of align and &amp; in the -->
<!-- array confuses the splitting) -->

$$
\begin{align}
\alpha_I &= \xno{J}\yno{K} - \xno{K}\yno{J},
\tag{234}\\ 
\beta_I &= \yno{J} - \yno{K},
\tag{235}\\ 
\gamma_I &= \xno{K} - \xno{J},
\tag{236},
\end{align}
$$

and

$$
\begin{equation}
2\Delta = \det\left(\begin{array}{rrr}
1 & \xno{I} & \yno{I} \\ 
1 & \xno{J} & \yno{J} \\ 
1 & \xno{K} & \yno{K} \end{array}\right)
\tp
\tag{237}
\end{equation}
$$

The quantity \( \Delta \) is the area of the cell.

<p>
The following formula is often convenient when computing element matrices
and vectors:

$$
\begin{equation}
\int_{\Omega^{(e)}} \basphi_I^{p}\basphi_J^{q}\basphi_K^{r} dx dy =
{p!q!r!\over (p+q+r+2)!}2\Delta
\tag{238}
\tp
\end{equation}
$$

(Note that the \( q \) in this formula is not to be mixed with the \( q(e,r) \)
mapping of degrees of freedom.)

<p>
As an example, the element matrix entry
\( \int_{\Omega^{(e)}} \basphi_I\basphi_J\dx \)
can be computed by setting
\( p=q=1 \) and \( r=0 \), when \( I\neq J \), yielding \( \Delta/12 \), and
\( p=2 \) and \( q=r=0 \), when \( I=J \), resulting in \( \Delta/6 \).
We collect these numbers in a local element matrix:

$$
\frac{\Delta}{12}
\left[\begin{array}{ccc}
2 & 1 & 1\\ 
1 & 2 & 1\\ 
1 & 1 & 2
\end{array}\right]
$$

<p>
The common element matrix entry \( \int_{\Omega^{(e)}} \nabla\basphi_I\cdot\nabla\basphi_J\dx \), arising from a Laplace term \( \nabla^2u \), can also easily be
computed by the formulas above. We have

$$ \nabla\basphi_I\cdot\nabla\basphi_J =
\frac{\Delta^2}{4}(\beta_I\beta_J + \gamma_I\gamma_J) = \hbox{const},$$

so that the element matrix entry becomes
\( \frac{1}{4}\Delta^3(\beta_I\beta_J + \gamma_I\gamma_J) \).

<p>
From an implementational point of view, one will work with local vertex
numbers \( r=0,1,2 \), parameterize the coefficients in the basis
functions by \( r \), and look up vertex coordinates through \( q(e,r) \).

<p>
Similar formulas exist for integration of P1 elements in 3D.

<h2 id="___sec221">A glimpse of the mathematical theory of the finite element method </h2>

<p>
Almost all books on the finite element method that introduces the
abstract variational problem \( a(u,v)=L(v) \) spend considerable pages on
deriving error estimates and other properties of the approximate
solution. The machinery with function spaces and bilinear and linear
forms has the great advantage that a very large class of PDE problems
can be analyzed in a unified way.  This feature is often taken as an
advantage of finite element methods over finite difference and volume
methods.  Since there are so many excellent textbooks on the
mathematical properties of finite element methods
<a href="._fem-book-solarized037.html#Larson_2013">[6]</a> <a href="._fem-book-solarized037.html#Braess">[4]</a> <a href="._fem-book-solarized037.html#Brenner_Scott">[3]</a> <a href="._fem-book-solarized037.html#JohnsonFEM87">[1]</a> <a href="._fem-book-solarized037.html#JohnsonCDE96">[9]</a> <a href="._fem-book-solarized037.html#Quarteroni_Valli">[2]</a>, this text
will not repeat the theory, but give a glimpse of typical assumptions
and general results for elliptic PDEs.

<p>
<b>Remark.</b>
The mathematical theory of finite element methods is primarily
developed for to stationary PDE problems of elliptic nature whose
solutions are smooth. However, such problems can be solved with the
desired accuracy by most numerical methods and pose no difficulties.
Time-dependent problems, on the other hand, easily lead to
non-physical features in the numerical solutions and therefore
requires more care and knowledge by the user.  Our focus on the
accuracy of the finite element method will of this reason be centered
around time-dependent problems, but then we need a different set of
tools for the analysis. These tools are based on converting finite
element equations to finite difference form and studying Fourier wave
components.

<p>

<!-- begin inline comment -->
<font color="red">(<b>kam 15</b>: This is really two remarks in one and we can split and put them in more appropriate place. Time is dealt with later.)</font>
<!-- end inline comment -->

<h3 id="___sec222">Abstract variational forms </h3>

<p>
To list the main results from the mathematical theory of finite elements,
we consider linear PDEs with an abstract variational form

$$ a(u,v) = L(v)\quad\forall v\in V\tp$$

This is the discretized problem (as usual in this book) where we
seek \( u\in V \).
The weak formulation of the corresponding continuous problem,
fulfilled by the exact solution \( \uex\in\Vex \) is here written as

$$ a(\uex, v) = L(v)\quad\forall v\in\Vex\tp$$

The space \( V \) is finite dimensional (with dimension \( N+1 \)),
while \( \Vex \) is infinite dimensional.
Normally
The hope is that \( u\rightarrow\uex \) as \( N\rightarrow\infty \) and
\( V\rightarrow\Vex \).

<h3 id="___sec223">Example on an abstract variational form and associated spaces </h3>

<p>
Consider the problem \( -u''(x)=f(x) \) on \( \Omega=[0,1] \), with \( u(0)=0 \) and
\( u'(1)=\beta \). The weak form is

$$ a(u,v) = \int_0^1 u'v'dx,\quad L(v)=\int_0^1fvdx + \beta v(1)\tp$$

The space \( V \) for the approximate solution \( u \) can be chosen in many
ways as previously described.
The exact solution \( \uex \) fulfills \( a(u,v)=L(v) \) for all \( v \) in \( \Vex \),
and to specify what \( \Vex \) is, we need to introduce <em>Hilbert spaces</em>.
The Hilbert
space \( L^2(\Omega) \) consists of all functions that are square-integrable
on \( \Omega \):

$$ L^2(\Omega) = \left\lbrace\int_\Omega v^2dx < \infty\right\rbrace\tp$$

The space \( \Vex \) is the space of all functions whose first-order
derivative is also square-integrable:

$$ \Vex = H^1_0(\Omega) = \left\lbrace v\in L^2(\Omega)\,\vert\,
\frac{dv}{dx}\in L^2(\Omega),\hbox{ and }v(0)=0\right\rbrace\tp$$

The requirements of square-integrable zeroth- and first-order derivatives
are motivated from the formula for \( a(u,v) \) where products of the
first-order derivatives are to be integrated on \( \Omega \).
We remark that it is common that  \( H^1_0 \) denote the
space of \( H^1 \) functions that are zero everywhere on the boundary, but
here we use it for functions that are zero only at \( x=0 \).

<p>
The Sobolev space \( H^1_0(\Omega) \) has an inner product

$$ (u,v)_{H^1} = \int_\Omega (uv + \frac{du}{dx}\frac{dv}{dx})dx,$$

and associated norm

$$ ||v||_{H^1} = \sqrt{(v,v)_{H^1}}\tp$$

<h3 id="___sec224">Assumptions </h3>

<p>
A set of general results builds on the following
assumptions. Let \( \Vex \) be an infinite-dimensional inner-product space
such that \( \uex\in\Vex \). The space has an associated norm \( ||v|| \)
(e.g., \( ||v||_{H^1} \) in the example above with \( \Vex=H^1_0(\Omega) \)).

<ol>
<li> \( L(v) \) is linear in its argument.</li>
<li> \( a(u,v) \) is a bilinear in its arguments.</li>
<li> \( L(v) \) is bounded (also called continuous) if there exists a positive
   constant \( c_0 \) such that \( |L(v)|\leq c_0||v|| \) $\forall v\in \Vex$.</li>
<li> \( a(u,v) \) is bounded (or continuous) if there exists a positive constant
   \( c_1 \) such that \( |a(u,v)|\leq c_1||u|| ||v||\ \forall u,v\in\Vex \).</li>
<li> \( a(u,v \)) is elliptic (or coercive) if there exists a positive
   constant \( c_2 \) such that \( a(v,v)\geq c_2||v||^2\ \forall v\in\Vex \).</li>
<li> \( a(u,v) \) is symmetric: \( a(u,v)=a(v,u) \).</li>
</ol>

Based on the above assumptions, which must be verified in each specific
problem, one can derive some general results that are listed below.

<h3 id="___sec225">Existence and uniqueness </h3>

<p>
There exists a unique solution of the problem: find \( \uex\in\Vex \)
such that

$$ a(\uex,v)=L(v)\quad\forall v\in\Vex\tp$$

(This result is known as the Lax-Milgram Theorem.
We remark that symmetry is not strictly needed for this theorem.)

<h3 id="___sec226">Stability </h3>

<p>
The solution \( \uex\in\Vex \) obeys the stability estimate

$$ ||u||\leq \frac{c_0}{c_2}\tp$$

<h3 id="___sec227">Equivalent minimization problem </h3>

<p>
The solution \( \uex\in\Vex \) also fulfills the minimization problem

$$ \min_{v\in\Vex} F(v),\quad F(v)=\frac{1}{2}a(v,v) - L(v)\tp$$

<h3 id="___sec228">Best approximation principle </h3>

<p>
The <em>energy norm</em> is defined as

$$ ||v||_a = \sqrt{a(v,v)}\tp$$

The discrete solution \( u\in V \) is the best approximation in energy norm,

$$ ||\uex -  u||_a \leq ||\uex - v||_a\quad\forall v\in V\tp$$

This is quite remarkable: once we have \( V \) (i.e., a mesh and a finite element), the Galerkin
method finds the best approximation in this space.
In the example above, we have \( ||v||_a=\int_0^1 (v')^2dx \), so
the derivative \( u' \) is closer to \( \uex' \) than any other possible
function in \( V \):

$$ \int_0^1 (\uex' - u')^2dx \leq \int_0^1(u' - v')dx\quad\forall v\in V\tp$$

<h3 id="___sec229">Best approximation property in the norm of the space </h3>

<p>
If \( ||v|| \) is the norm associated with \( \Vex \), we have another
best approximation property:

$$ ||\uex - u||\leq\left(\frac{c_1}{c_2}\right)^{\half}||\uex - v||\quad\forall v\in\V\tp$$

<h3 id="___sec230">Symmetric, positive definite coefficient matrix </h3>

<p>
The discrete problem \( a(u,v)=L(v) \) $\forall v\in V$ leads to a linear
system \( Ac=b \), where the coefficient matrix \( A \) is symmetric (\( A^T=A \))
and positive definite (\( x^TAx > 0 \) for all vectors \( x\neq 0 \)).  One
can then use solution methods that demand less storage and that are
faster and more reliable than solvers for general linear systems. One
is also guaranteed the existence and uniqueness of the discrete
solution \( u \).

<h3 id="___sec231">Equivalent matrix minimization problem </h3>

<p>
The solution \( c \) of the linear system \( Ac=b \) also solves the minimization
problem \( \min_w(\half w^TAw - b^Tw \) in the vector space \( \Real^{N+1} \).

<h3 id="___sec232">A priori error estimate for the derivative </h3>

<p>
In our sample problem, \( -u''=f \) on \( \Omega=[0,1] \), \( u(0)=0 \), \( u'(1)=\beta \),
one can derive the following error estimate for Lagrange finite element
approximations of degree \( s \):

$$
\left(\int_0^1 (\uex' - u')^2dx\right)^{\half} \leq Ch^s||\uex||_{H^{s+1}},\\ 
$$

where \( ||u||_{H^{s+1}} \) is a norm that integrates the sum of the square of all
derivatives up to order \( s+1 \),
\( C \) is a constant, and \( h \) is the maximum
cell length.
The estimate shows that choosing
elements with higher-degree polynomials (large \( s \)) requires more
smoothness in \( \uex \) since higher-order derivatives need to be square-integrable.

<p>
A consequence of the error estimate is that \( u'\rightarrow \uex' \)
as \( h\rightarrow 0 \), i.e., the approximate solution converges to
the exact one.

<p>
The constant \( C \) in  depends on the shape
of triangles in 2D and tetrahedra in 3D: squeezed elements with a
small angle lead to a large \( C \), and such deformed elements are
not favorable for the accuracy.

<p>
One can generalize the above estimate to the general problem class
\( a(u,v)=L(v) \): the error in the derivative is proportional
to \( h^s \). Note that the expression \( ||\uex - u|| \) in the example
is \( ||\uex - u||_{H^1} \) so it involves the sum of the zeroth and
first derivative. The appearance of the derivative makes the error
proportional to \( h^s \) - if we only look at the solution it
converges as \( h^{s+1} \) (see below).

<p>
The above estimate is called an <em>a priori</em> estimate because the bound
contains the exact solution, which is not computable. There are also
<em>a posteriori</em> estimates where the bound involves the approximation
\( u \), which is available in computations.

<h3 id="___sec233">A priori error estimate for the solution </h3>

<p>
The finite element solution of our sample problem  fulfills

$$
||\uex - u|| \leq Ch^{s+1} ||\uex||_{H^{s+1}},
$$

This estimate shows that the error converges as \( h^2 \) for P1 elements.
An equivalent finite difference method, see the section <a href="._fem-book-solarized020.html#fem:deq:1D:fdm_vs_fem">Comparison with a finite difference discretization</a>, is known to have an error proportional to \( h^2 \), so the above estimate
is expected.
In general, the convergence is \( h^{s+1} \) for elements with polynomials
of degree \( s \). Note that the estimate for \( u' \) is proportional to
\( h \) raised to one power less.
We remark that the second estimate strictly speaking requires extra smoothness (regularity).

<h1 id="fem:varform:fenics">Implementation in 2D and 3D via FEniCS</h1>

<p>
From a principle of view, we have seen that variational forms of the
type: find \( a(u,v)=L\ \forall v\in V \) (and even general nonlinear problems
\( F(u;v)=0 \)), can apply the computational machinery of introduced for
the approximation problem \( u=f \). We actually need two extensions only:

<ol>
<li> specify Dirichlet boundary conditions as part of \( V \)</li>
<li> incorporate Neumann flux boundary conditions in the variational form</li>
</ol>

The algorithms are all the same in any space dimension, we only need to
choose the element type and associated integration rule. Once we know
how to compute things in 1D, and made the computer code sufficiently
flexible, the method and code should work for any variational form in
any number of space dimensions! This fact is exactly the idea behind
the <a href="http://fenicsproject.org" target="_self">FEniCS</a> finite element software.

<p>
Therefore, if we know how to set up an approximation problem in any
dimension in FEniCS, and know how to derive variational forms in higher
dimensions, we are (in principle!) very close to solving a
PDE problem in FEniCS. Building on the the section <a href="._fem-book-solarized015.html#fe:approx:fenics">Implementation</a>,
we shall now solve a quite general 1D/2D/3D Poisson problem in FEniCS.
There is very much more FEniCS programming than this example, but it
illustrates our fact that when we go beyond 1D, there is exists
software which leverage the full power of the finite element method as
a method for solving &quot;any&quot; problem in any number of
space dimensions.

<h2 id="fem:varform:fenics:problem">Mathematical problem</h2>

<p>
The following model describes the pressure \( u \) in the flow around a
bore hole of radius \( a \) in a porous medium. If the hole is long in the
vertical direction, we can model it by a 2D domain in the cross section.

$$
\begin{alignat}{2}
\nabla\cdot \left( \dfc\nabla u\right) &= 0, & \quad a < ||\x|| < b,
\tag{239}\\ 
u(\x) &= U_a, \quad &  ||\x|| = a,
\tag{240}\\ 
u(\x) &= U_b  \quad &  ||\x|| = b\tp
\tag{241}
\end{alignat}
$$

That is, we have a hollow circular 2D domain with inner radius \( a \) and
outer radius \( b \). The pressure is known on these two boundaries, so
this is a pure Dirichlet problem.

<h3 id="___sec236">Symmetry </h3>

<p>
The first thing we should observe is that the problem is radially
symmetric, so we can change to polar coordinates and obtain a 1D
problem in the radial direction:

$$ (r\dfc u')' = 0,\quad u(a)=U_a, u(b)=U_b\tp$$

This is not very exciting beyond being able to find an analytical solution
and compute the true error of a finite element approximation.

<p>
However, many software packages solve problems in Cartesian coordinates, and
FEniCS basically do this, so we want to take advantage of symmetry in
Cartesian coordinates and reformulate the problem in a smaller
domain.

<p>
Looking at the domain as a cake with a hole, any piece of the
cake will be a candidate for a reduced-size domain.  The solution is
symmetric about any line \( \theta = \hbox{const} \) in polar coordinates,
so at such lines we have the symmetry boundary condition \( \partial
u/\partial n=0 \), i.e., a homogeneous Neumann condition.  In Figure
<a href="#fem:varform:fenics:problem:meshfig">67</a> we have plotted a possible
mesh of cells as triangles, here with dense refinement toward the bore
hole, because we know the solution will decay most rapidly toward the
origin.  This mesh is a piece of the cake with four sides: Dirichlet
conditions on the inner and outer boundary, named \( \Gamma_{D_a} \) and
\( \Gamma_{D_b} \), and \( \partial u/\partial n=0 \)
on the two other sides, named \( \Gamma_N \).
In this particular example, the arc of the piece
of the cake is 45 degrees, but any value of the arc will work.

<p>
<center> <!-- figure label: --> <div id="fem:varform:fenics:problem:meshfig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 67:  Mesh of a hollow cylinder, with refinement and utilizing symmetry.  <!-- caption label: fem:varform:fenics:problem:meshfig --> </p></center>
<p><img src="fig/borehole_mesh1.png" align="bottom" width=700></p>
</center>

<p>
The boundary problem can then be expressed as

$$
\begin{alignat}{2}
\nabla\cdot \left( \dfc\nabla u\right) &= 0, & \quad \x\in\Omega,
\tag{242}\\ 
u(\x) &= U_a,  \quad  & \x\in\Gamma_{D_a},
\tag{243}\\ 
u(\x) &= U_b,  \quad  & \x\in\Gamma_{D_b},
\tag{244}\\ 
\frac{\partial u}{\partial n} &=0,\quad & \x\in\Gamma_N\tp
\tag{245}
\end{alignat}
$$

<h2 id="fem:varform:fenics:varform">Variational formulation</h2>

<p>
To obtain the variational formulation, we multiply the PDE by a test
function \( v \) and integrate the second-order derivatives by part:

$$
\begin{align*}
\int_\Omega \nabla\cdot (\dfc\nabla u) v \dx &= 0,\quad \forall v\in V\\ 
&= -\int_\Omega \dfc\nabla u\cdot\nabla v\dx + \int_{\Gamma_N}\dfc
\frac{\partial u}{\partial n}v\ds\\ 
&= -\int_\Omega \dfc\nabla u\cdot\nabla v\dx\tp
\end{align*}
$$

We are left with a problem of the form: find \( u \) such that
\( a(u,v)=L(v)\ \forall v\in V \), with

$$
\begin{align}
a(u,v) &= \int_\Omega \dfc\nabla u\cdot\nabla v\dx,
\tag{246}\\ 
L(v) &= \int_\Omega 0v\dx \tp
\tag{247}
\end{align}
$$

We write the integrand as \( 0v\dx \) even though \( L=0 \), because it is necessary
in FEniCS to specify \( L \) as a linear form and not the number zero.
The Dirichlet conditions make a nonzero solution.

<h2 id="___sec238">The FEniCS solver </h2>

<p>
Suppose we have a function <code>make_mesh</code> that can make the mesh for us.
All we need to do in the solver and that has not been exemplified
before, is to define \( V \) with proper Dirichlet conditions.
It is easy to do so as long as the Neumann conditions are zero. Otherwise,
we will have to do a line integral along the boundary and that brings in
quite some concepts in FEniCS about how to mark boundaries <a href="._fem-book-solarized037.html#ftut1">[7]</a>.
Fortunately, a lot of problems have homogeneous Neumann conditions (thanks
to symmetries!), so the example here can be extended and become useful
in many contexts.

<p>
We have to write functions for testing whether a point is on a Dirichlet
boundary or not:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>V = FunctionSpace(mesh, 'P', degree)

# Define Dirichlet boundary conditions
from math import sqrt
def inner(x, on_boundary):
    &quot;&quot;&quot;Return True if x on r=a with tolerance.&quot;&quot;&quot;
    r = on_boundary and \ 
        abs(sqrt(x[0]**2 + x[1]**2) - x_a) &lt; 1E-2
    print 'XXXa', r, x[0], x[1], abs(sqrt(x[0]**2 + x[1]**2) - x_a), on_boundary
    return r

def outer(x, on_boundary):
    &quot;&quot;&quot;Return True if x on r=b with tolerance.&quot;&quot;&quot;
    r = on_boundary and \ 
        abs(sqrt(x[0]**2 + x[1]**2) - x_b) &lt; 1E-2
    print 'XXXb', r, x[0], x[1], abs(sqrt(x[0]**2 + x[1]**2) - x_b), on_boundary
    return r
</code></pre>
<!-- end verbatim block -->
Note here that we test with a tolerance since the points on the boundary
may be subject to rounding errors when making the mesh coordinates.

<p>
We then use the <code>DirichletBC</code> object to make different kinds of
Dirichlet conditions, here two, and collect them in a list `bcs:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>bc_inner = DirichletBC(V, u_a, inner)
bc_outer = DirichletBC(V, u_b, outer)
bcs = [bc_inner, bc_outer]
</code></pre>
<!-- end verbatim block -->

<p>
The next step is to define the variational problem and solve it:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># Define variational problem
u = TrialFunction(V)
v = TestFunction(V)
a = alpha*dot(grad(u), grad(v))*dx
L = Constant(0)*v*dx  # L = 0*v*dx = 0 does not work...

# Compute solution
u = Function(V)
solve(a == L, u, bcs)

f = File(&quot;mesh.xml&quot;)
f &lt;&lt; mesh
</code></pre>
<!-- end verbatim block -->
In order to avoid <code>L=0</code> (<code>L</code> equal to the float zero), we have to
tell FEniCS that is a linear form, so zero must be specified as <code>Constant(0)</code>.

<p>
Note that everything is the same as for the approximation problem,
except for the Dirichlet conditions and the formulas for <code>a</code> and
<code>L</code>. FEniCS has, of course, access to very efficient solution methods,
so we could add arguments to the <code>solve</code> call to apply
state-of-the-art iterative methods and preconditioners for large-scale
problems. However, for this little 2D case a standard sparse Gaussian
elimination, as implied by <code>solve(a = L, u, bcs)</code> is the most
efficient and reliable approach.

<p>
Finally, we can save the solution to file for using professional
visualization software and, if desired, add a quick plotting using the
built-in FEniCS tool <code>plot</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code># Save solution to file in VTK format
vtkfile = File(filename + '.pvd')
vtkfile &lt;&lt; u

u.rename('u', 'u'); plot(u); plot(mesh)
interactive()
</code></pre>
<!-- end verbatim block -->
(The <code>u.rename</code> call is just for getting a more readable title in the plot.)

<p>
The above statements are collected in a function <code>solver</code> in the
file <a href="http://tinyurl.com/znpudbt/borehole_fenics.py" target="_self"><tt>borehole_fenics.py</tt></a>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(alpha,    # Diffusion coefficient
           u_a,      # Inner pressure
           u_b,      # Outer pressure
           Theta,    # Arc size
           x_a,      # Inner boundary
           x_b,      # Outer boundary
           nr,       # Resolution r direction
           nt,       # Resolution azimuthal direction
           degree,   # Element polynomial degree
           filename, # Name of VTK file
           ):
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Be careful with name clashes!</b>
<p>
It is easy when coding mathematics to use variable names that correspond
to one-letter names in the mathematics. For example, in the mathematics
of this problem there are to \( a \) variables: the radius of the inner
boundary and the bilinear form in the variational formulation.
Using <code>a</code> for the inner boundary in <code>solver</code> does not work: it is
quickly overwritten by the bilinear form. We therefore have to introduce
<code>x_a</code>. Long variable names are to be preferred for safe programming,
though short names corresponding to the mathematics are nicer...
</div>


<h2 id="___sec239">Making the mesh </h2>

<p>
The hardest part of a finite element problem is very often to make the mesh.
Here the idea is to first make a rectangle, then make the denser toward the
left end, and then bend it to get the form of the part of a hole.

<p>
Let \( x \) and \( y \) be the coordinates of a vertex in the mesh that is
a rectangle \( (0,a)\times (0,b) \).
The stretching towards \( x=a \) is done by mapping

$$
\begin{equation}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^s\tp
\tag{248}
\end{equation}
$$

A stretching towards \( x=b \) is given by

$$
\begin{equation}
\bar x = a + (b-a)\left({x-a\over b-a}\right)^{1/s}\tp
\tag{249}
\end{equation}
$$

The parameter \( s \) controls the amount of stretching.
The code below shows the details of mapping the coordinates of FEniCS mesh.

<p>
Mapping of a rectangle onto a our geometry is done by

$$
\begin{equation*}
\hat x = \bar x\cos (\Theta \bar y),\quad \hat y = \bar x\sin (\Theta \bar y)\tp
\end{equation*}
$$

<p>
We are now ready for the Python code that codes these formulas and manipulates
the FEniCS mesh:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def make_mesh(Theta, a, b, nr, nt):
    mesh = RectangleMesh(Point(a, 0), Point(b, 1), nr, nt, 'crossed')

    # First make a denser mesh towards r=a
    x = mesh.coordinates()[:,0]
    y = mesh.coordinates()[:,1]
    s = 3.5

    def denser(x, y):
        return [a + (b-a)*((x-a)/(b-a))**s, y]

    x_bar, y_bar = denser(x, y)
    xy_bar_coor = np.array([x_bar, y_bar]).transpose()
    mesh.coordinates()[:] = xy_bar_coor

    # Map onto to a &quot;piece of cake&quot;

    def cylinder(r, s):
        return [r*np.cos(Theta*s), r*np.sin(Theta*s)]

    x_hat, y_hat = cylinder(x_bar, y_bar)
    xy_hat_coor = np.array([x_hat, y_hat]).transpose()
    mesh.coordinates()[:] = xy_hat_coor
    return mesh
</code></pre>
<!-- end verbatim block -->

<p>
We could also have used the mesh tool <code>mshr</code> in FEniCS, but with our
approach here we have full control of the refinement towards the hole.

<h2 id="___sec240">Solving a problem </h2>

<p>
We assume that \( \dfc \) is constant.
Before solving such
a specific problem, it can be wise to scale the problem since
it often reduces the amount of input data in the model. Here, the variation
in \( u \) is typically \( |u_a-u_b| \) so we use that as characteristic
pressure. The coordinates may be naturally scaled by the bore hole radius,
so we have new, scaled variables

$$ \bar u = \frac{u-u_a}{u_a-u_b},\quad \bar x = \frac{x}{a},\quad
\bar y = \frac{y}{a}\tp$$

Now, we expect \( \bar u\in [0,1] \), which is a goal of scaling.
Inserting this in the problem gives the PDE

$$ \nabla^2 \bar u = 0 $$

in a domain with inner radius 1 and \( \bar u=0 \), and outer radius

$$ \beta = \frac{a}{b},$$

with \( \bar u = 1 \). Our solver can solve this problem by setting
<code>alpha=1</code>, <code>u_a=0</code>, <code>u_b=0</code>, <code>x_a=1</code>, <code>x_b=beta</code>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 16</b>: Show plots from paraview.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 17</b>: Do 3D automatically.)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 18</b>: Do 1D Dirichlet model problem from previous sections (exercise!).)</font>
<!-- end inline comment -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized023.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized025.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

