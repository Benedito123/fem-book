<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:64px;      /* fixed header height for style bootswatch_readable */
  margin:-64px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              ('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Contents', 3, None, '___sec1'),
              ('Supplementary materials', 3, None, '___sec2'),
              ('Quick overview of the finite element method',
               0,
               'ch:overview',
               'ch:overview'),
              ('Function approximation by global functions',
               0,
               'ch:approx:global',
               'ch:approx:global'),
              ('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec7'),
              ('The projection method', 3, None, '___sec8'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec10'),
              ('The Galerkin or projection method', 3, None, '___sec11'),
              ('Approximation principles',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method', 2, 'fem:approx:LS', 'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec14'),
              ('Example on linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec17'),
              ('Fall back on numerical integration', 3, None, '___sec18'),
              ('Plotting the approximation', 3, None, '___sec19'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact1',
               'fem:approx:global:exact1'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec22'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              ('Implementation', 3, None, '___sec24'),
              ('Example', 3, None, '___sec25'),
              ('Orthogonal basis functions', 1, None, '___sec26'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec30'),
              ('Interpolation', 1, None, '___sec31'),
              ('The interpolation (or collocation) principle',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec33'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec35'),
              ('Successful example', 3, None, '___sec36'),
              ('Less successful example', 3, None, '___sec37'),
              ('Remedy for strong oscillations', 3, None, '___sec38'),
              ('Bernstein polynomials',
               2,
               'fem:approx:global:Bernstein',
               'fem:approx:global:Bernstein'),
              ('Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              ('Approximation of functions in higher dimensions',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example on polynomial basis in 2D', 2, None, '___sec43'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Exercises', 1, None, '___sec46'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power '
               'functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec53'),
              ('Problem 7: Approximate a steep function by sines with boundary '
               'adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec55'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange '
               'polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange '
               'polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Function approximation by finite elements',
               0,
               'ch:approx:fe',
               'ch:approx:fe'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec62'),
              ('The basis functions', 2, None, '___sec63'),
              ('Construction principles', 3, None, '___sec64'),
              ('Properties of $\\basphi_i$', 3, None, '___sec65'),
              ('Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              ('Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              ('Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec70'),
              ('Calculating a general row in the matrix', 3, None, '___sec71'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec73'),
              ('Assembly of element matrices', 3, None, '___sec74'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              ('The element vector', 3, None, '___sec76'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec78'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              ('Formulas for local basis functions', 3, None, '___sec80'),
              ('Example on integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation', 1, 'fem:approx:fe:impl', 'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite elements and finite differences',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Interpretation of a finite element approximation in terms of '
               'finite difference operators',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fdm',
               'fem:deq:1D:approx:fem_vs_fdm'),
              ('Computations in physical space', 3, None, '___sec95'),
              ('Elementwise computations', 3, None, '___sec96'),
              ('Terminology', 3, None, '___sec97'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example on cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec104'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              ('Finite elements in 2D and 3D', 1, None, '___sec107'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              ('Element matrices and vectors', 3, None, '___sec109'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              ('Affine mapping of the reference cell', 2, None, '___sec111'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              ('Computing integrals', 2, None, '___sec113'),
              ('Implementation', 1, 'fe:approx:fenics', 'fe:approx:fenics'),
              ('Example on approximation in 2D using FEniCS',
               2,
               'fem:approx:fenics:2D',
               'fem:approx:fenics:2D'),
              ('Mathematical problem', 3, None, '___sec116'),
              ('The code', 3, None, '___sec117'),
              ('Dissection of the code', 3, None, '___sec118'),
              ('Integrating SymPy and FEniCS', 3, None, '___sec119'),
              ('Refined code with curve plotting',
               2,
               'fem:approx:fenics:2D:2',
               'fem:approx:fenics:2D:2'),
              ('Interpolation and projection', 3, None, '___sec121'),
              ('Plotting the solution along a line', 3, None, '___sec122'),
              ('Integrating plotting and computations', 3, None, '___sec123'),
              ('Exercises', 1, None, '___sec124'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite '
               'elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis '
               'functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Exercise 24: Make a 3D code for Lagrange elements of arbitrary '
               'order',
               2,
               None,
               '___sec138'),
              ('Variational formulations with global basis functions',
               0,
               'ch:varform:global',
               'ch:varform:global'),
              ('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('Differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Simple model problems and their solutions',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              ('Forming the residual',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec144'),
              ('The Galerkin method', 2, None, '___sec145'),
              ('The method of weighted residuals', 2, None, '___sec146'),
              ('The method of weighted residual and the truncation error',
               2,
               'varform:trunc',
               'varform:trunc'),
              ('Test and trial functions', 2, None, '___sec148'),
              ('The collocation method', 2, None, '___sec149'),
              ('The subdomain collocation method', 3, None, '___sec150'),
              ('Examples on using the principles',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The model problem', 3, None, '___sec152'),
              ('Basis functions', 3, None, '___sec153'),
              ('The residual', 3, None, '___sec154'),
              ('The least squares method', 3, None, '___sec155'),
              ('The Galerkin method', 3, None, '___sec156'),
              ('The collocation method', 3, None, '___sec157'),
              ('Comparison', 3, None, '___sec158'),
              ('Integration by parts',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('Weak form', 3, None, '___sec160'),
              ('Boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Computing with global polynomials', 1, None, '___sec162'),
              ('Computing with Dirichlet and Neumann conditions',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              ('When the numerical method is exact', 2, None, '___sec164'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Variational problems and minimization of functionals',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              ('Example', 3, None, '___sec167'),
              ('The general minimization problem', 3, None, '___sec168'),
              ('Derivation', 3, None, '___sec169'),
              ('Minimization of the discretized functional',
               3,
               None,
               '___sec170'),
              ('Calculus of variations', 3, None, '___sec171'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient', 2, None, '___sec173'),
              ('First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec174'),
              ('Nonlinear coefficient', 2, None, '___sec175'),
              ('Implementation of the algorithms',
               1,
               'fem:global:deq:1D:code',
               'fem:global:deq:1D:code'),
              ('Extensions of the code for approximation',
               2,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              ('Fallback to numerical methods', 2, None, '___sec178'),
              ('Example with constant right-hand side', 2, None, '___sec179'),
              ('Approximations may fail: convection-diffusion',
               1,
               'ch:convdiff',
               'ch:convdiff'),
              ('Exercises', 1, None, '___sec181'),
              ('Exercise 25: Refactor functions into a more general class',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              ('Exercise 26: Compute the deflection of a cable with sine '
               'functions',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              ('Exercise 27: Compute the deflection of a cable with power '
               'functions',
               2,
               'fem:deq:exer:tension:cable_xn',
               'fem:deq:exer:tension:cable_xn'),
              ('Exercise 28: Check integration by parts',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Variational formulations with finite elements',
               0,
               'ch:varform:fe',
               'ch:varform:fe'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Finite element mesh and basis functions', 2, None, '___sec188'),
              ('Computation in the global physical domain',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              ('Comparison with a finite difference discretization',
               2,
               'fem:deq:1D:fdm_vs_fem',
               'fem:deq:1D:fdm_vs_fem'),
              ('Cellwise computations',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('The integral for the element matrix', 3, None, '___sec192'),
              ('The integral for the element vector', 3, None, '___sec193'),
              ('Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec194'),
              ('Contributions from the first and last cell',
               3,
               None,
               '___sec195'),
              ('Assembly', 3, None, '___sec196'),
              ('Boundary conditions: specified nonzero value',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              ('Example on computing with a finite element-based boundary '
               'function',
               2,
               None,
               '___sec199'),
              ('Computations in physical coordinates', 3, None, '___sec200'),
              ('Cellwise computations on the reference element',
               3,
               None,
               '___sec201'),
              ('Modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Computations in the physical system', 3, None, '___sec203'),
              ('Symmetric modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              ('Modification of the element matrix and vector',
               2,
               'fem:bc:elmat:mod',
               'fem:bc:elmat:mod'),
              ('Boundary conditions: specified derivative',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec207'),
              ('Boundary term vanishes because of the test functions',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              ('Boundary term vanishes because of linear system modifications',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              ('Direct computation of the global linear system',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              ('Cellwise computations', 2, None, '___sec211'),
              ('Implementation of finite element algorithms',
               1,
               'fem:deq:1D:code',
               'fem:deq:1D:code'),
              ('Extensions of the code for approximation',
               2,
               'fem:deq:1D:code:fe',
               'fem:deq:1D:code:fe'),
              ('Utilizing a sparse matrix',
               2,
               'fem:deq:1D:code:fe_sparse',
               'fem:deq:1D:code:fe_sparse'),
              ('Application to our model problem', 2, None, '___sec215'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Integration by parts', 2, None, '___sec217'),
              ('Example on a multi-dimensional variational problem',
               2,
               'sec:varform:general:convdiff',
               'sec:varform:general:convdiff'),
              ('Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec219'),
              ('Numerical integration', 2, None, '___sec220'),
              ('Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec221'),
              ('A glimpse of the mathematical theory of the finite element '
               'method',
               2,
               None,
               '___sec222'),
              ('Abstract variational forms', 3, None, '___sec223'),
              ('Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec224'),
              ('Assumptions', 3, None, '___sec225'),
              ('Existence and uniqueness', 3, None, '___sec226'),
              ('Stability', 3, None, '___sec227'),
              ('Equivalent minimization problem', 3, None, '___sec228'),
              ('Best approximation principle', 3, None, '___sec229'),
              ('Best approximation property in the norm of the space',
               3,
               None,
               '___sec230'),
              ('Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec231'),
              ('Equivalent matrix minimization problem', 3, None, '___sec232'),
              ('A priori error estimate for the derivative',
               3,
               None,
               '___sec233'),
              ('A priori error estimate for the solution',
               3,
               None,
               '___sec234'),
              ('Implementation in 2D and 3D via FEniCS',
               1,
               'fem:varform:fenics',
               'fem:varform:fenics'),
              ('Mathematical problem',
               2,
               'fem:varform:fenics:problem',
               'fem:varform:fenics:problem'),
              ('Symmetry', 3, None, '___sec237'),
              ('Variational formulation',
               2,
               'fem:varform:fenics:varform',
               'fem:varform:fenics:varform'),
              ('The FEniCS solver', 2, None, '___sec239'),
              ('Making the mesh', 2, None, '___sec240'),
              ('Solving a problem', 2, None, '___sec241'),
              ('Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec242'),
              ('Summary', 1, None, '___sec243'),
              ('Exercises', 1, None, '___sec244'),
              ('Exercise 29: Compute the deflection of a cable with 2 P1 '
               'elements',
               2,
               'fem:deq:exer:cable:2P1',
               'fem:deq:exer:cable:2P1'),
              ('Exercise 30: Compute the deflection of a cable with 1 P2 '
               'element',
               2,
               'fem:deq:exer:cable:1P2',
               'fem:deq:exer:cable:1P2'),
              ('Exercise 31: Compute the deflection of a cable with a step '
               'load',
               2,
               'fem:deq:exer:cable:stepload',
               'fem:deq:exer:cable:stepload'),
              ('Exercise 32: Compute with a non-uniform mesh',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              ('Problem 33: Solve a 1D finite element problem by hand',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              ('Exercise 34: Investigate exact finite element solutions',
               2,
               'fem:deq:exer:1D:exact_numerics',
               'fem:deq:exer:1D:exact_numerics'),
              ('Exercise 35: Compare finite elements and differences for a '
               'radially symmetric Poisson equation',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              ('Exercise 36: Compute with variable coefficients and P1 '
               'elements by hand',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              ('Exercise 37: Solve a 2D Poisson equation using polynomials and '
               'sines',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              ('Exercise 38: Solve a 3D Laplace problem with FEniCS',
               2,
               'fem:fenics:borehole:exer:3D',
               'fem:fenics:borehole:exer:3D'),
              ('Exercise 39: Solve a 1D Laplace problem with FEniCS',
               2,
               'fem:fenics:borehole:exer:1D',
               'fem:fenics:borehole:exer:1D'),
              ('Time-dependent variational forms',
               0,
               'ch:femtime',
               'ch:femtime'),
              ('Discretization in time by a Forward Euler scheme',
               1,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              ('Time discretization', 2, None, '___sec258'),
              ('Space discretization', 2, None, '___sec259'),
              ('Variational forms', 2, None, '___sec260'),
              ('Notation for the solution at recent time levels',
               2,
               None,
               '___sec261'),
              ('Deriving the linear systems', 2, None, '___sec262'),
              ('Computational algorithm', 2, None, '___sec263'),
              ('Example using cosinusoidal basis functions',
               2,
               'fem:deq:diffu:FE:cosex',
               'fem:deq:diffu:FE:cosex'),
              ('Comparing P1 elements with the finite difference method',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              ('Lumping the mass matrix', 3, None, '___sec266'),
              ('Discretization in time by a Backward Euler scheme',
               1,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              ('Time discretization', 2, None, '___sec268'),
              ('Variational forms', 2, None, '___sec269'),
              ('Linear systems', 2, None, '___sec270'),
              ('Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec271'),
              ('Dirichlet boundary conditions',
               1,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              ('Boundary function', 2, None, '___sec273'),
              ('Finite element basis functions', 2, None, '___sec274'),
              ('Modification of the linear system', 2, None, '___sec275'),
              ('Example: Oscillating Dirichlet boundary condition',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              ('Accuracy of the finite element solution',
               1,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              ('Methods of analysis', 2, None, '___sec278'),
              ('Fourier components and dispersion relations',
               2,
               None,
               '___sec279'),
              ('Forward Euler discretization', 2, None, '___sec280'),
              ('Backward Euler discretization', 2, None, '___sec281'),
              ('Comparing amplification factors', 2, None, '___sec282'),
              ('Exercises', 1, None, '___sec283'),
              ('Exercise 40: Analyze a Crank-Nicolson scheme for the diffusion '
               'equation',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              ('Variational forms for systems of PDEs',
               0,
               'ch:femsys',
               'ch:femsys'),
              ('Variational forms', 1, 'fem:sys:vform', 'fem:sys:vform'),
              ('Sequence of scalar PDEs formulation', 2, None, '___sec287'),
              ('Vector PDE formulation', 2, None, '___sec288'),
              ('A worked example', 1, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              ('Identical function spaces for the unknowns',
               1,
               None,
               '___sec290'),
              ('Variational form of each individual PDE', 2, None, '___sec291'),
              ('Compound scalar variational form', 2, None, '___sec292'),
              ('Decoupled linear systems', 2, None, '___sec293'),
              ('Coupled linear systems', 2, None, '___sec294'),
              ('Different function spaces for the unknowns',
               1,
               None,
               '___sec295'),
              ('Computations in 1D',
               1,
               'femsys:cooling:1D',
               'femsys:cooling:1D'),
              ('Another example in 1D', 2, 'fem:sys:up:1D', 'fem:sys:up:1D'),
              ('Exercises', 1, None, '___sec298'),
              ('Problem 41: Estimate order of convergence for the Cooling law',
               2,
               'femsys:exer:cooling:1',
               'femsys:exer:cooling:1'),
              ('Problem 42: Estimate order of convergence for the Cooling law',
               2,
               'femsys:exer:cooling:2',
               'femsys:exer:cooling:2'),
              ('Flexible implementations of boundary conditions',
               0,
               'ch:nitsche',
               'ch:nitsche'),
              ('Optimization with constraint',
               1,
               'nitsche:fxy:opt',
               'nitsche:fxy:opt'),
              ('Elimination of variables', 2, None, '___sec303'),
              ('Lagrange multiplier method',
               2,
               'nitsche:fxy:opt:Lagrange',
               'nitsche:fxy:opt:Lagrange'),
              ('Penalty method',
               2,
               'nitsche:fxy:opt:penalty',
               'nitsche:fxy:opt:penalty'),
              ('Optimization of functionals',
               1,
               'nitsche:pde:opt',
               'nitsche:pde:opt'),
              ('Classical calculus of variations',
               2,
               'nitsche:pde:opt:varcalculus',
               'nitsche:pde:opt:varcalculus'),
              ("Penalty and Nitsche's methods for optimization with "
               'constraints',
               2,
               'nitsche:pde:opt:penalty',
               'nitsche:pde:opt:penalty'),
              ('Lagrange multiplier method for optimization with constraints',
               2,
               'nitsche:pde:opt:Lagrange',
               'nitsche:pde:opt:Lagrange'),
              ('Example: 1D problem',
               2,
               'nitsche:pde:opt:1Dex',
               'nitsche:pde:opt:1Dex'),
              ('Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec311'),
              ('Nonlinear problems', 0, 'ch:nonlin', 'ch:nonlin'),
              ('Introduction of basic concepts',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              ('Linear versus nonlinear equations', 2, None, '___sec314'),
              ('Algebraic equations', 3, None, '___sec315'),
              ('Differential equations', 3, None, '___sec316'),
              ('A simple model problem', 2, None, '___sec317'),
              ('Linearization by explicit time discretization',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              ('Exact solution of nonlinear algebraic equations',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              ('Linearization', 2, None, '___sec320'),
              ('Picard iteration',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              ('Stopping criteria', 3, None, '___sec322'),
              ('A single Picard iteration', 3, None, '___sec323'),
              ('Linearization by a geometric mean',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              ("Newton's method",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              ('Relaxation',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              ('Implementation and experiments',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              ('Generalization to a general nonlinear ODE',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              ('Explicit time discretization', 3, None, '___sec329'),
              ('Backward Euler discretization', 3, None, '___sec330'),
              ('Crank-Nicolson discretization', 3, None, '___sec331'),
              ('Systems of ODEs',
               2,
               'nonlin:ode:generic:sys:pendulum',
               'nonlin:ode:generic:sys:pendulum'),
              ('Example', 3, None, '___sec333'),
              ('Systems of nonlinear algebraic equations',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              ('Picard iteration',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              ("Newton's method",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              ('Stopping criteria',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              ('Example: A nonlinear ODE model from epidemiology',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              ('Implicit time discretization', 3, None, '___sec339'),
              ('A Picard iteration', 3, None, '___sec340'),
              ("Newton's method", 3, None, '___sec341'),
              ('Linearization at the differential equation level',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              ('Explicit time integration',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              ('Backward Euler scheme and Picard iteration',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              ("Backward Euler scheme and Newton's method",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              ('Linearization via Taylor expansions', 3, None, '___sec346'),
              ('Similarity with Picard iteration', 3, None, '___sec347'),
              ('Implementation', 3, None, '___sec348'),
              ('Derivation with alternative notation', 3, None, '___sec349'),
              ('Crank-Nicolson discretization',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              ('1D stationary nonlinear differential equations',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              ('Solution of algebraic equations', 2, None, '___sec353'),
              ('The structure of the equation system', 3, None, '___sec354'),
              ('Picard iteration', 3, None, '___sec355'),
              ('Mesh with two cells', 3, None, '___sec356'),
              ("Newton's method", 3, None, '___sec357'),
              ('Multi-dimensional PDE problems', 1, None, '___sec358'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:dD:fd',
               'nonlin:alglevel:dD:fd'),
              ('Picard iteration', 3, None, '___sec360'),
              ("Newton's method", 3, None, '___sec361'),
              ('Continuation methods', 2, None, '___sec362'),
              ('Exercises', 1, 'nonlin:exer', 'nonlin:exer'),
              ('Problem 43: Determine if equations are nonlinear or not',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              ('Exercise 44: Derive and investigate a generalized logistic '
               'model',
               2,
               'nonlin:exer:logistic:gen',
               'nonlin:exer:logistic:gen'),
              ("Problem 45: Experience the behavior of Newton's method",
               2,
               'nonlin:exer:Newton:problems1',
               'nonlin:exer:Newton:problems1'),
              ('Problem 46: Compute the Jacobian of a $2\\times 2$ system',
               2,
               'nonlin:exer:vib:Jacobian',
               'nonlin:exer:vib:Jacobian'),
              ('Problem 47: Solve nonlinear equations arising from a vibration '
               'ODE',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              ('Exercise 48: Find the truncation error of arithmetic mean of '
               'products',
               2,
               'nonlin:exer:products:arith:mean',
               'nonlin:exer:products:arith:mean'),
              ("Problem 49: Newton's method for linear problems",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              ('Exercise 50: Discretize a 1D problem with a nonlinear '
               'coefficient',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              ('Exercise 51: Linearize a 1D problem with a nonlinear '
               'coefficient',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              ('Problem 52: Finite differences for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              ('Exercise 53: Discretize a nonlinear 1D heat conduction PDE by '
               'finite differences',
               2,
               'nonlin:exer:1D:heat:nonlinear:fdm',
               'nonlin:exer:1D:heat:nonlinear:fdm'),
              ('Exercise 54: Differentiate a highly nonlinear term',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              ('Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion '
               'equation',
               2,
               'nonlin:exer:2D:heat:nonlinear:fd',
               'nonlin:exer:2D:heat:nonlinear:fd'),
              ('Exercise 56: Find the sparsity of the Jacobian',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              ('Problem 57: Investigate a 1D problem with a continuation '
               'method',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              ('Symbolic nonlinear finite element equations',
               1,
               'nonlin:app:fem_vs_fdm',
               'nonlin:app:fem_vs_fdm'),
              ('Finite element basis functions',
               2,
               'nonlin:alglevel:1D:fe_basis',
               'nonlin:alglevel:1D:fe_basis'),
              ('The group finite element method',
               2,
               'nonlin:alglevel:1D:fe:group',
               'nonlin:alglevel:1D:fe:group'),
              ('Finite element approximation of functions of $u$',
               3,
               None,
               '___sec382'),
              ('Simplified problem', 3, None, '___sec383'),
              ('Integrating nonlinear functions', 3, None, '___sec384'),
              ('Application of the group finite element method',
               3,
               None,
               '___sec385'),
              ('Numerical integration of nonlinear terms by hand',
               2,
               'nonlin:alglevel:1D:fe:f',
               'nonlin:alglevel:1D:fe:f'),
              ('Discretization of a variable coefficient Laplace term',
               2,
               'nonlin:alglevel:1D:fe:Laplace',
               'nonlin:alglevel:1D:fe:Laplace'),
              ('Group finite element method', 3, None, '___sec388'),
              ('Numerical integration at the nodes', 3, None, '___sec389'),
              ('Variational methods for linear systems', 0, 'ch:cg', 'ch:cg'),
              ('Conjugate gradient-like iterative methods',
               1,
               'ch:linalg:CGmethods',
               'ch:linalg:CGmethods'),
              ('The Galerkin method', 2, None, '___sec392'),
              ('The least squares method', 2, None, '___sec393'),
              ('Krylov subspaces', 2, None, '___sec394'),
              ('Computation of the basis vectors', 2, None, '___sec395'),
              ('Computation of a new solution vector', 2, None, '___sec396'),
              ('Summary of the least squares method', 2, None, '___sec397'),
              ('Remark', 3, None, '___sec398'),
              ('Truncation and restart', 2, None, '___sec399'),
              ('Summary of the Galerkin method', 2, None, '___sec400'),
              ('A framework based on the error', 2, None, '___sec401'),
              ('Preconditioning',
               1,
               'ch:linalg2:preconditioning',
               'ch:linalg2:preconditioning'),
              ('Motivation and Basic Principles', 2, None, '___sec403'),
              ('Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec404'),
              ('Classical iterative methods as preconditioners',
               2,
               'ch:linalg:SORprecond',
               'ch:linalg:SORprecond'),
              ('Incomplete factorization preconditioners',
               2,
               'linalg:ILU',
               'linalg:ILU'),
              ('Preconditioners developed for solving PDE problems',
               2,
               None,
               '___sec407'),
              ('Appendix: Useful formulas', 0, 'ch:formulas', 'ch:formulas'),
              ('Finite difference operator notation',
               1,
               'sec:form:fdop',
               'sec:form:fdop'),
              ('Truncation errors of finite difference approximations',
               1,
               'sec:form:truncerr',
               'sec:form:truncerr'),
              ('Finite differences of exponential functions',
               1,
               'sec:form:fdexp',
               'sec:form:fdexp'),
              ('Complex exponentials', 3, None, '___sec412'),
              ('Real exponentials', 3, None, '___sec413'),
              ('Finite differences of $t^n$',
               1,
               'sec:form:fdtn',
               'sec:form:fdtn'),
              ('Software', 2, None, '___sec415'),
              ('References', 1, None, '___sec416')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="fem-book-sol.html">Introduction to Numerical Methods for Variational Problems</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._fem-book-sol002.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#ch:preface" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplementary materials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol003.html#ch:overview" style="font-size: 80%;"><b>Quick overview of the finite element method</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol003.html#ch:approx:global" style="font-size: 80%;"><b>Function approximation by global functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec:plane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of planar vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec:Np1dim" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of general vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin or projection method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:LS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection (or Galerkin) method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on linear approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:LS:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbolic integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fall back on numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:exact1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perfect approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The regression method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overdetermined equation system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The normal equations derived from a least squares principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:illconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ill-conditioning</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fourier series</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:orth" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The interpolation (or collocation) principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of a polynomial</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Successful example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less successful example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remedy for strong oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:Bernstein" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bernstein polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation properties and convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of functions in higher dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D basis functions as tensor products of 1D functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on polynomial basis in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D:global:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:3D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension to 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:linalg1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 1: Linear algebra refresher</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:vec:3Dby2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2: Approximate a three-dimensional vector in a plane</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:parabola_sine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 3: Approximate a parabola by a sine</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:exp:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 4: Approximate the exponential function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:sin:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 5: Approximate the sine function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:sine1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6: Approximate a steep function by sines</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:sine3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 7: Approximate a steep function by sines with boundary adjustment</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 8: Fourier series as a least squares approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 9: Approximate a steep function by Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:Lagrange:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 10: Approximate a steep function by Lagrange polynomials and regression</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#ch:approx:fe" style="font-size: 80%;"><b>Function approximation by finite elements</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:def:elements:nodes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construction principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties of \( \basphi_i \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on quadratic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on linear finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on cubic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:global:linearsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating specific matrix entries</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating a general row in the matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:elementwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of element matrices</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of irregularly numbered elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:mapping" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mapping to a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The coordinate transformation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for the element matrix and vector entries</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for local basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:intg:ref" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on integration over a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:intg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:linsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear system assembly and solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing symbolic approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:collocation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using interpolation instead of least squares</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:numeric" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing numerical approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:A:structure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applications</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sparse matrix storage and solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Comparison of finite elements and finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd:fdproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximation of given functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd:feproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpretation of a finite element approximation in terms of finite difference operators</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:deq:1D:approx:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making finite elements behave as finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical space</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminology</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:terminology" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cells, vertices, and degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:def" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended finite element concept</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error of the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:impl:Hermite" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on cubic Hermite polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#fem:approx:fe:numint1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton-Cotes rules</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gauss-Legendre rules with optimized points</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions over triangles in the physical domain</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element matrices and vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions over triangles in the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Affine mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Isoparametric mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing integrals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fe:approx:fenics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fenics:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on approximation in 2D using FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the code</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating SymPy and FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fenics:2D:2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refined code with curve plotting</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpolation and projection</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution along a line</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating plotting and computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:mesh1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 11: Define nodes and elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:mesh2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 12: Define vertices, cells, and dof maps</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:defmesh:sparsity" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 13: Construct matrix sparsity patterns</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:Asinwt:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 14: Perform symbolic finite element computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:exer:tanh:P1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 15: Approximate a steep function by P1 and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:exer:tanh:P3P4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 16: Approximate a steep function by P3 and P4 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:Asinwt:interpol:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 17: Investigate the approximation error in finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:Heaviside" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 18: Approximate a step function by finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:2Dsines:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 19: 2D approximation with orthogonal functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:1D:trapez" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 20: Use the Trapezoidal rule and P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:1D:P1:vs:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 21: Compare P1 elements and interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:3D:approx3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 22: Implement 3D computations with global basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:1D:simpson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 23: Use Simpson's rule and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 24: Make a 3D code for Lagrange elements of arbitrary order</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#ch:varform:global" style="font-size: 80%;"><b>Variational formulations with global basis functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:principles" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basic principles for approximating differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:models" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equation models</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:models:simple" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple model problems and their solutions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:residual:min" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming the residual</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method of weighted residuals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#varform:trunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method of weighted residual and the truncation error</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The subdomain collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:ex:sines" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples on using the principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The residual</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec156" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec157" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec158" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Weak form</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:essBC:Bfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec162" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing with global polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:varform:ex:DN:case" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing with Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec164" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the numerical method is exact</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#fem:deq:1D:varform:abstract" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract notation for variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#fem:deq:1D:optimization" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational problems and minimization of functionals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec167" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec168" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The general minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec169" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec170" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimization of the discretized functional</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculus of variations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:deq:1D:varform:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Examples on variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variable coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First-order derivative in the equation and boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:global:deq:1D:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of the algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:deq:1D:code:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extensions of the code for approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fallback to numerical methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example with constant right-hand side</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#ch:convdiff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximations may fail: convection-diffusion</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:BVP1D:class" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 25: Refactor functions into a more general class</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:tension:cable" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 26: Compute the deflection of a cable with sine functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:tension:cable_xn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 27: Compute the deflection of a cable with power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:intg:parts" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 28: Check integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#ch:varform:fe" style="font-size: 80%;"><b>Variational formulations with finite elements</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:fem1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing with finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element mesh and basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:comp:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation in the global physical domain</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:fdm_vs_fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison with a finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:comp:elmwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The integral for the element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The integral for the element vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec194" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Detailed calculations of the element matrix and vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec195" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contributions from the first and last cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec196" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:essBC" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Boundary conditions: specified nonzero value</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;General construction of a boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec199" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing with a finite element-based boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec200" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec201" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations on the reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc:modsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec203" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in the physical system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc:modsys:symm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetric modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:bc:elmat:mod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the element matrix and vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Boundary conditions: specified derivative</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#___sec207" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:uLtest" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary term vanishes because of the test functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:uLmod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary term vanishes because of linear system modifications</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:Aub" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct computation of the global linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#___sec211" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of finite element algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extensions of the code for approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code:fe_sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utilizing a sparse matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#___sec215" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application to our model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:deq:2D:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational formulations in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec217" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#sec:varform:general:convdiff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on a multi-dimensional variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec219" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation to a reference cell in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec220" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec221" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenient formulas for P1 elements in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec222" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A glimpse of the mathematical theory of the finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec223" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec224" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on an abstract variational form and associated spaces</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec225" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assumptions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec226" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Existence and uniqueness</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec227" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec228" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec229" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Best approximation principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec230" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Best approximation property in the norm of the space</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec231" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetric, positive definite coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec232" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent matrix minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec233" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A priori error estimate for the derivative</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec234" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A priori error estimate for the solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation in 2D and 3D via FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec237" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetry</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec239" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The FEniCS solver</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec240" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec241" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving a problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol025.html#___sec242" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Convection-diffusion and Petrov-Galerkin methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol025.html#___sec243" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Summary</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#___sec244" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:2P1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 29: Compute the deflection of a cable with 2 P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 30: Compute the deflection of a cable with 1 P2 element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:stepload" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 31: Compute the deflection of a cable with a step load</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:mesh:nonuniform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 32: Compute with a non-uniform mesh</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:gen:problem1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 33: Solve a 1D finite element problem by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:exact_numerics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 34: Investigate exact finite element solutions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:Poisson:polar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:gen:problem2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 36: Compute with variable coefficients and P1 elements by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:2D:torsion:xy:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 37: Solve a 2D Poisson equation using polynomials and sines</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:fenics:borehole:exer:3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 38: Solve a 3D Laplace problem with FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:fenics:borehole:exer:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 39: Solve a 1D Laplace problem with FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#ch:femtime" style="font-size: 80%;"><b>Time-dependent variational forms</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization in time by a Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec258" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec259" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Space discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec260" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec261" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notation for the solution at recent time levels</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec262" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving the linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec263" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computational algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE:cosex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example using cosinusoidal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE:fdvsP1fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing P1 elements with the finite difference method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec266" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lumping the mass matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization in time by a Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec268" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec269" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec270" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec271" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference operators corresponding to P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dirichlet boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec273" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec274" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec275" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:Dirichlet:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: Oscillating Dirichlet boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:anal" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Accuracy of the finite element solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec278" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methods of analysis</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec279" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fourier components and dispersion relations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec280" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec281" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec282" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing amplification factors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec283" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:exer:diffu:analysis:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 40: Analyze a Crank-Nicolson scheme for the diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#ch:femsys" style="font-size: 80%;"><b>Variational forms for systems of PDEs</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#fem:sys:vform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec287" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence of scalar PDEs formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec288" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector PDE formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#fem:sys:uT:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A worked example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec290" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Identical function spaces for the unknowns</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec291" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form of each individual PDE</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec292" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compound scalar variational form</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec293" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decoupled linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec294" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coupled linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec295" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Different function spaces for the unknowns</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#femsys:cooling:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computations in 1D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#fem:sys:up:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Another example in 1D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec298" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#femsys:exer:cooling:1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 41: Estimate order of convergence for the Cooling law</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#femsys:exer:cooling:2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 42: Estimate order of convergence for the Cooling law</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#ch:nitsche" style="font-size: 80%;"><b>Flexible implementations of boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:fxy:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization with constraint</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec303" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elimination of variables</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:fxy:opt:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange multiplier method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:fxy:opt:penalty" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Penalty method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of functionals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:varcalculus" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classical calculus of variations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:penalty" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Penalty and Nitsche's methods for optimization with constraints</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange multiplier method for optimization with constraints</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:1Dex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: 1D problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec311" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: adding a constraint in a Neumann problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#ch:nonlin" style="font-size: 80%;"><b>Nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Introduction of basic concepts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec314" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear versus nonlinear equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec315" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec316" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec317" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:roots" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact solution of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec320" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec322" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec323" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A single Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by a geometric mean</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:relaxation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation and experiments</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:ode:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization to a general nonlinear ODE</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec329" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec330" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec331" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:ode:generic:sys:pendulum" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Systems of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec333" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Systems of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:terminate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:SI" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: A nonlinear ODE model from epidemiology</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec339" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec340" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec341" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization at the differential equation level</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:explicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec346" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization via Taylor expansions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec347" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity with Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec348" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec349" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation with alternative notation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Picard:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#nonlin:alglevel:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;1D stationary nonlinear differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#nonlin:alglevel:1D:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec353" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution of algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec354" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the equation system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec355" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec356" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh with two cells</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec357" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec358" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multi-dimensional PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#nonlin:alglevel:dD:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec360" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec361" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec362" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continuation methods</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:lin:vs:nonlin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 43: Determine if equations are nonlinear or not</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:logistic:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 44: Derive and investigate a generalized logistic model</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:Newton:problems1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 45: Experience the behavior of Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:vib:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 46: Compute the Jacobian of a \( 2\times 2 \) system</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:vib:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 47: Solve nonlinear equations arising from a vibration ODE</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:products:arith:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 48: Find the truncation error of arithmetic mean of products</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:Newton:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 49: Newton's method for linear problems</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:1pu2:fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 50: Discretize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:1pu2:PicardNewton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 51: Linearize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:fu:discretize:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 52: Finite differences for the 1D Bratu problem</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:heat:nonlinear:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 53: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:grad:pow:term" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 54: Differentiate a highly nonlinear term</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:2D:heat:nonlinear:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:sparsity:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 56: Find the sparsity of the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:continuation:1DnNflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 57: Investigate a 1D problem with a continuation method</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:app:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Symbolic nonlinear finite element equations</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:alglevel:1D:fe_basis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:alglevel:1D:fe:group" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec382" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element approximation of functions of \( u \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec383" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec384" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating nonlinear functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec385" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application of the group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:alglevel:1D:fe:f" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration of nonlinear terms by hand</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:alglevel:1D:fe:Laplace" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization of a variable coefficient Laplace term</a></li>
     <!-- navigation toc: --> <li><a href="#___sec388" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec389" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration at the nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:cg" style="font-size: 80%;"><b>Variational methods for linear systems</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg:CGmethods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Conjugate gradient-like iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec392" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec393" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec394" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Krylov subspaces</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec395" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation of the basis vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec396" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation of a new solution vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec397" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec398" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec399" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation and restart</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec400" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of the Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec401" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A framework based on the error</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg2:preconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Preconditioning</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec403" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motivation and Basic Principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec404" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use of the preconditioning matrix in the iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg:SORprecond" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classical iterative methods as preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#linalg:ILU" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incomplete factorization preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec407" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preconditioners developed for solving PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#ch:formulas" style="font-size: 80%;"><b>Appendix: Useful formulas</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdop" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference operator notation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:truncerr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors of finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdexp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of exponential functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec412" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complex exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec413" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Real exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdtn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of \( t^n \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec415" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol037.html#___sec416" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0033"></a>
<!-- !split -->

<h1 id="nonlin:exer" class="anchor">Exercises</h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:lin:vs:nonlin" class="anchor">Problem 43: Determine if equations are nonlinear or not</h2>

<p>
Classify each term in the following equations as linear or nonlinear.
Assume that \( u \), \( \u \), and \( p \) are unknown functions and that
all other symbols are known quantities.

<ol>
<li> \( mu^{\prime\prime} + \beta |u^{\prime}|u^{\prime} + cu = F(t) \)</li>
<li> \( u_t = \dfc u_{xx} \)</li>
<li> \( u_{tt} = c^2\nabla^2 u \)</li>
<li> \( u_t = \nabla\cdot(\dfc(u)\nabla u) + f(x,y) \)</li>
<li> \( u_t + f(u)_x = 0 \)</li>
<li> \( \u_t + \u\cdot\nabla \u = -\nabla p + r\nabla^2\u \), \( \nabla\cdot\u = 0 \)
   (\( \u \) is a vector field)</li>
<li> \( u^{\prime} = f(u,t) \)</li>
<li> \( \nabla^2 u = \lambda e^u \)</li>
</ol>

<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_43_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_43_1">

<ol>
<li> \( mu^{\prime\prime} \) is linear; \( \beta |u^{\prime}|u^{\prime} \) is
   nonlinear; \( cu \) is linear; \( F(t) \) does not contain the unknown \( u \)
   and is hence constant in \( u \), so the term is linear.</li>
<li> \( u_t \) is linear; \( \dfc u_{xx} \) is linear.</li>
<li> \( u_{tt} \) is linear; \( c^2\nabla^2 u \) is linear.</li>
<li> \( u_t \) is linear; \( \nabla\cdot(\dfc(u)\nabla u) \) is nonlinear;
   \( f(x,y) \) is constant in \( u \) and hence linear.</li>
<li> \( u_t \) is linear;  \( f(u)_x \) is nonlinear if \( f \) is nonlinear in \( u \).</li>
<li> \( \u_t \) is linear; \( \u\cdot\nabla \u \) is nonlinear;
   \( -\nabla p \) is linear (in \( p \));  \( r\nabla^2\u \) is linear;
   \( \nabla\cdot\u \) is linear.</li>
<li> \( u^{\prime} \) is linear;  \( f(u,t) \) is nonlinear if \( f \) is nonlinear in \( u \).</li>
<li> \( \nabla^2 u \) is linear; \( \lambda e^u \) is nonlinear.</li>
</ol>

</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>nonlinear_vs_linear</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:logistic:gen" class="anchor">Exercise 44: Derive and investigate a generalized logistic model</h2>

<p>
The logistic model for population growth is derived by assuming
a nonlinear growth rate,

$$
\begin{equation}
u^{\prime} = a(u)u,\quad u(0)=I,
\tag{9.71}
\end{equation}
$$

and the logistic model arises from the simplest possible choice of
\( a(u) \): \( r(u)=\varrho(1 - u/M) \), where \( M \) is the maximum value of \( u \) that
the environment can sustain, and \( \varrho \) is the growth under
unlimited access to resources (as in the beginning when \( u \) is small).
The idea is that \( a(u)\sim\varrho \) when \( u \) is small and that
\( a(t)\rightarrow 0 \) as \( u\rightarrow M \).

<p>
An \( a(u) \) that generalizes the linear choice is the polynomial form

$$
\begin{equation}
a(u) = \varrho(1-u/M)^p,
\tag{9.72}
\end{equation}
$$

where \( p>0 \) is some real number.

<p>
<b>a)</b>
Formulate a Forward Euler, Backward Euler, and a Crank-Nicolson
scheme for <a href="#mjx-eqn-9.71">(9.71)</a>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_1">

<p>
Use a geometric mean approximation in the Crank-Nicolson scheme:
\( [a(u)u]^{n+1/2}\approx a(u^n)u^{n+1} \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_3">

<p>
The Forward Euler scheme reads

$$ [D^+_t u = a(u)u]^n, $$

or written out,

$$ \frac{u^{n+1}-u^n}{\Delta t} = a(u^n)u^n\tp$$

The scheme is linear in the unknown \( u^{n+1} \):

$$ u^{n+1} = u^n + {\Delta t}a(u^n)u^n\tp$$

<p>
The Backward Euler scheme,

$$ [D^-_t u = a(u)u]^n, $$

becomes

$$ \frac{u^{n}-u^{n-1}}{\Delta t} = a(u^n)u^n,$$

which is a nonlinear equation in the unknown \( u \), here expressed as
\( u^{n+1} \):

$$ u^{n+1} - \Delta t a(u^{n+1})u^{n+1} = u^n\tp$$

<p>
The standard Crank-Nicolson scheme,

$$ D_t u = \overline{a(u)u}^t]^{n+\half},$$

takes the form

$$ \frac{u^{n+1}-u^n}{\Delta t} = \half a(u^n)u^n + \half a(u^{n+1})u^{n+1}\tp$$

This is a nonlinear equation in the unknown \( u^{n+1} \),

$$ u^{n+1} - \half {\Delta t} a(u^{n+1})u^{n+1}
= u^n + \half {\Delta t} a(u^n)u^n\tp$$

However, with the suggested geometric mean, the \( a(u)u \) term is
linearized:

$$ \frac{u^{n+1}-u^n}{\Delta t} = a(u^n)u^{n+1},$$

leading to a linear equation in \( u^{n+1} \):

$$ (1 - \Delta t a(u^n))u^{n+1} = u^n\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Formulate Picard and Newton iteration for the Backward Euler scheme in a).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_4">

<p>
A Picard iteration for

$$ u^{n+1} - \Delta t a(u^{n+1})u^{n+1} = u^n\tp$$

applies old values in for \( u^{n+1} \) in \( a(u^{n+1}) \). If \( u^- \) is the
most recently computed approximation to \( u^{n+1} \), we can write the Picard
linearization as

$$ (1 - \Delta t a(u^-))u^{n+1} = u^n\tp$$

Alternatively, with an iteration index \( k \),

$$ (1 - \Delta t a(u^{n+1,k}))u^{n+1,k+1} = u^n\tp$$

<p>
Newton's method starts with identifying the nonlinear equation as
\( F(u)=0 \), and here

$$ F(u) = u - \Delta t a(u)u - u^n\tp$$

The Jacobian is

$$ J(u) = \frac{d F(u)}{du} = 1 - \Delta t(a'(u)u + a(u))\tp$$

The key equation in Newton's method is then

$$ J(u^-)\delta u = - F(u^-),\quad u\leftarrow u - \delta u\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Implement the numerical solution methods from a) and b).
Use <a href="http://tinyurl.com/znpudbt/logistic.py" target="_self"><tt>logistic.py</tt></a> to compare the case
\( p=1 \) and the choice <a href="#mjx-eqn-9.72">(9.72)</a>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_5" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_5">

<p>
We specialize the code for \( a(u) \) to <a href="#mjx-eqn-9.72">(9.72)</a>
since the code was developed from <code>logistic.py</code>. It is convenient to
work with a dimensionless form of the problem.
Choosing a time scale \( t_c = 1\varrho \) and a scale for \( u \),
\( u_c=M \), leads to

$$ u^{\prime} = \varrho (1-u)^p u,\quad u(0)=\alpha,$$

where \( \alpha \) is a dimensionless number

$$ \alpha = \frac{I}{M}\tp$$

<p>
The three schemes can be implemented as follows.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">FE_logistic</span>(p, u0, dt, Nt):
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> u[n])<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">BE_logistic</span>(p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
                eps_r<span style="color: #666666">=1E-3</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>):
    <span style="color: #408080; font-style: italic"># u[n] = u[n-1] + dt*(1-u[n])**p*u[n]</span>
    <span style="color: #408080; font-style: italic"># -dt*(1-u[n])**p*u[n] + u[n] = u[n-1]</span>
    <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard1&#39;</span>:
        choice <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Picard&#39;</span>
        max_iter <span style="color: #666666">=</span> <span style="color: #666666">1</span>

    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    iterations <span style="color: #666666">=</span> []
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt<span style="color: #666666">+1</span>):
        c <span style="color: #666666">=</span> <span style="color: #666666">-</span>u[n<span style="color: #666666">-1</span>]
        <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard&#39;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u <span style="color: #666666">+</span> u <span style="color: #666666">+</span> c

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                <span style="color: #408080; font-style: italic"># u*(1-dt*(1-u_)**p) + c = 0</span>
                u_ <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>(<span style="color: #666666">-</span>c<span style="color: #666666">/</span>(<span style="color: #666666">1-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u_)<span style="color: #666666">**</span>p)) <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)

        <span style="color: #008000; font-weight: bold">elif</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Newton&#39;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u <span style="color: #666666">+</span> u <span style="color: #666666">+</span> c

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dF</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> dt<span style="color: #666666">*</span>p<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>(p<span style="color: #666666">-1</span>)<span style="color: #666666">*</span>u <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p <span style="color: #666666">+</span> <span style="color: #666666">1</span>

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                u_ <span style="color: #666666">=</span> u_ <span style="color: #666666">-</span> F(u_)<span style="color: #666666">/</span>dF(u_)
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)
    <span style="color: #008000; font-weight: bold">return</span> u, iterations

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">CN_logistic</span>(p, u0, dt, Nt):
    <span style="color: #408080; font-style: italic"># u[n+1] = u[n] + dt*(1-u[n])**p*u[n+1]</span>
    <span style="color: #408080; font-style: italic"># (1 - dt*(1-u[n])**p)*u[n+1] = u[n]</span>
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n]<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> u[n])<span style="color: #666666">**</span>p)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
A first verification is to choose \( p=1 \) and compare the results with
those from <code>logistic.py</code>. The number of iterations and the final
numerical answers should be identical.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
Implement unit tests that check the asymptotic limit of the solutions:
\( u\rightarrow M \) as \( t\rightarrow\infty \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_2" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_2">

<p>
You need to experiment to find what &quot;infinite time&quot; is
(increases substantially with \( p \)) and what the
appropriate tolerance is for testing the asymptotic limit.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_6" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_6">

<p>
The test function may look like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_asymptotic_value</span>():
    T <span style="color: #666666">=</span> <span style="color: #666666">100</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    u0 <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    p <span style="color: #666666">=</span> <span style="color: #666666">1.8</span>

    u_CN <span style="color: #666666">=</span> CN_logistic(p, u0, dt, Nt)
    u_BE_Picard, iter_Picard <span style="color: #666666">=</span> BE_logistic(
        p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
        eps_r<span style="color: #666666">=1E-5</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>)
    u_BE_Newton, iter_Newton <span style="color: #666666">=</span> BE_logistic(
        p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>,
        eps_r<span style="color: #666666">=1E-5</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>)
    u_FE <span style="color: #666666">=</span> FE_logistic(p, u0, dt, Nt)

    <span style="color: #008000; font-weight: bold">for</span> arr <span style="color: #AA22FF; font-weight: bold">in</span> u_CN, u_BE_Picard, u_BE_Newton, u_FE:
        expected <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        computed <span style="color: #666666">=</span> arr[<span style="color: #666666">-1</span>]
        tol <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;expected=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, computed=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (expected, computed)
        <span style="color: #008000; font-weight: bold">print</span>(msg)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
It is important with a sufficiently small <code>eps_r</code> tolerance for the
asymptotic value to be accurate (using <code>eps_r=1E-3</code> leads to a value
0.92 at \( t=T \) instead of 0.994 when <code>eps_r=1E-5</code>).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>e)</b>
Perform experiments with Newton and Picard iteration for
the model <a href="#mjx-eqn-9.72">(9.72)</a>.
See how sensitive
the number of iterations is to \( \Delta t \) and \( p \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_44_7" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_44_7">

<p>
Appropriate code is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">FE_logistic</span>(p, u0, dt, Nt):
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> u[n])<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">BE_logistic</span>(p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
                eps_r<span style="color: #666666">=1E-3</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>):
    <span style="color: #408080; font-style: italic"># u[n] = u[n-1] + dt*(1-u[n])**p*u[n]</span>
    <span style="color: #408080; font-style: italic"># -dt*(1-u[n])**p*u[n] + u[n] = u[n-1]</span>
    <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard1&#39;</span>:
        choice <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Picard&#39;</span>
        max_iter <span style="color: #666666">=</span> <span style="color: #666666">1</span>

    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    iterations <span style="color: #666666">=</span> []
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt<span style="color: #666666">+1</span>):
        c <span style="color: #666666">=</span> <span style="color: #666666">-</span>u[n<span style="color: #666666">-1</span>]
        <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard&#39;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u <span style="color: #666666">+</span> u <span style="color: #666666">+</span> c

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                <span style="color: #408080; font-style: italic"># u*(1-dt*(1-u_)**p) + c = 0</span>
                u_ <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>(<span style="color: #666666">-</span>c<span style="color: #666666">/</span>(<span style="color: #666666">1-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u_)<span style="color: #666666">**</span>p)) <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)

        <span style="color: #008000; font-weight: bold">elif</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Newton&#39;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u <span style="color: #666666">+</span> u <span style="color: #666666">+</span> c

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dF</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> dt<span style="color: #666666">*</span>p<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>(p<span style="color: #666666">-1</span>)<span style="color: #666666">*</span>u <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p <span style="color: #666666">+</span> <span style="color: #666666">1</span>

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                u_ <span style="color: #666666">=</span> u_ <span style="color: #666666">-</span> F(u_)<span style="color: #666666">/</span>dF(u_)
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)
    <span style="color: #008000; font-weight: bold">return</span> u, iterations

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">CN_logistic</span>(p, u0, dt, Nt):
    <span style="color: #408080; font-style: italic"># u[n+1] = u[n] + dt*(1-u[n])**p*u[n+1]</span>
    <span style="color: #408080; font-style: italic"># (1 - dt*(1-u[n])**p)*u[n+1] = u[n]</span>
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n]<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> u[n])<span style="color: #666666">**</span>p)
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_asymptotic_value</span>():
    T <span style="color: #666666">=</span> <span style="color: #666666">100</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    u0 <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    p <span style="color: #666666">=</span> <span style="color: #666666">1.8</span>

    u_CN <span style="color: #666666">=</span> CN_logistic(p, u0, dt, Nt)
    u_BE_Picard, iter_Picard <span style="color: #666666">=</span> BE_logistic(
        p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
        eps_r<span style="color: #666666">=1E-5</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>)
    u_BE_Newton, iter_Newton <span style="color: #666666">=</span> BE_logistic(
        p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>,
        eps_r<span style="color: #666666">=1E-5</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>)
    u_FE <span style="color: #666666">=</span> FE_logistic(p, u0, dt, Nt)

    <span style="color: #008000; font-weight: bold">for</span> arr <span style="color: #AA22FF; font-weight: bold">in</span> u_CN, u_BE_Picard, u_BE_Newton, u_FE:
        expected <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        computed <span style="color: #666666">=</span> arr[<span style="color: #666666">-1</span>]
        tol <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;expected=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, computed=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (expected, computed)
        <span style="color: #008000; font-weight: bold">print</span>(msg)
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed) <span style="color: #666666">&lt;</span> tol

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo</span>():
    T <span style="color: #666666">=</span> <span style="color: #666666">12</span>
    p <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
    <span style="color: #008000; font-weight: bold">try</span>:
        dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
        eps_r <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>])
        omega <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
    <span style="color: #008000; font-weight: bold">except</span>:
        dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
        eps_r <span style="color: #666666">=</span> <span style="color: #666666">1E-3</span>
        omega <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    N <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))

    u_FE <span style="color: #666666">=</span> FE_logistic(p, <span style="color: #666666">0.1</span>, dt, N)
    u_BE31, iter_BE31 <span style="color: #666666">=</span> BE_logistic(p, <span style="color: #666666">0.1</span>, dt, N,
                                    <span style="color: #BA2121">&#39;Picard1&#39;</span>, eps_r, omega)
    u_BE3, iter_BE3 <span style="color: #666666">=</span> BE_logistic(p, <span style="color: #666666">0.1</span>, dt, N,
                                  <span style="color: #BA2121">&#39;Picard&#39;</span>, eps_r, omega)
    u_BE4, iter_BE4 <span style="color: #666666">=</span> BE_logistic(p, <span style="color: #666666">0.1</span>, dt, N,
                                  <span style="color: #BA2121">&#39;Newton&#39;</span>, eps_r, omega)
    u_CN <span style="color: #666666">=</span> CN_logistic(p, <span style="color: #666666">0.1</span>, dt, N)

    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Picard mean no of iterations (dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">):&#39;</span> <span style="color: #666666">%</span> dt, \ 
          <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(np<span style="color: #666666">.</span>mean(iter_BE3))))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Newton mean no of iterations (dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">):&#39;</span> <span style="color: #666666">%</span> dt, \ 
          <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(np<span style="color: #666666">.</span>mean(iter_BE4))))

    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, dt<span style="color: #666666">*</span>N, N<span style="color: #666666">+1</span>)
    plt<span style="color: #666666">.</span>plot(t, u_FE, t, u_BE3, t, u_BE31, t, u_BE4, t, u_CN)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #BA2121">&#39;BE Picard&#39;</span>, <span style="color: #BA2121">&#39;BE Picard1&#39;</span>, <span style="color: #BA2121">&#39;BE Newton&#39;</span>, <span style="color: #BA2121">&#39;CN gm&#39;</span>])
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, eps=</span><span style="color: #BB6688; font-weight: bold">%.0E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dt, eps_r))
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
    plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    filestem <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;logistic_N</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_eps</span><span style="color: #BB6688; font-weight: bold">%03d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (N, np<span style="color: #666666">.</span>log10(eps_r))
    plt<span style="color: #666666">.</span>savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_u.png&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_u.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(<span style="color: #008000">list</span>(<span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(iter_BE3)<span style="color: #666666">+1</span>)), iter_BE3, <span style="color: #BA2121">&#39;r-o&#39;</span>,
             <span style="color: #008000">list</span>(<span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(iter_BE4)<span style="color: #666666">+1</span>)), iter_BE4, <span style="color: #BA2121">&#39;b-o&#39;</span>)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;Picard&#39;</span>, <span style="color: #BA2121">&#39;Newton&#39;</span>])
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, eps=</span><span style="color: #BB6688; font-weight: bold">%.0E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dt, eps_r))
    plt<span style="color: #666666">.</span>axis([<span style="color: #666666">1</span>, N<span style="color: #666666">+1</span>, <span style="color: #666666">0</span>, <span style="color: #008000">max</span>(iter_BE3 <span style="color: #666666">+</span> iter_BE4)<span style="color: #666666">+1</span>])
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;Time level&#39;</span>)
    plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;No of iterations&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_iter.png&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_iter.pdf&#39;</span>)
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- ===== Exercise: Derive a relaxation formula ===== -->

<p>
Filename: <code>logistic_p</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:Newton:problems1" class="anchor">Problem 45: Experience the behavior of Newton's method</h2>

<p>
The program <a href="http://tinyurl.com/znpudbt/Newton_demo.py" target="_self"><tt>Newton_demo.py</tt></a> illustrates
graphically each step in Newton's method and is run like

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Terminal&gt; python Newton_demo.py f dfdx x0 xmin xmax
</pre></div>
<p>
Use this program to investigate potential
problems with Newton's method when solving \( e^{-0.5x^2}\cos (\pi x)=0 \).
Try a starting point \( x_0=0.8 \) and \( x_0=0.85 \) and watch the different
behavior. Just run

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Terminal&gt;  python Newton_demo.py &#39;0.2 + exp(-0.5*x**2)*cos(pi*x)&#39; \ 
           &#39;-x*exp(-x**2)*cos(pi*x) - pi*exp(-x**2)*sin(pi*x)&#39; \ 
           0.85 -3 3
</pre></div>
<p>
and repeat with 0.85 replaced by 0.8.
Zoom in to see the details. 
The program reads

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sys</span> <span style="color: #008000; font-weight: bold">import</span> argv
<span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">len</span>(argv) <span style="color: #666666">==</span> <span style="color: #666666">6</span>:
  <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;usage: &gt; Newton_demo.py f dfx x0 xmin xmax &quot;</span>)
  sys<span style="color: #666666">.</span>exit(<span style="color: #666666">0</span>)

f_str <span style="color: #666666">=</span> argv[<span style="color: #666666">1</span>]
dfdx_str <span style="color: #666666">=</span> argv[<span style="color: #666666">2</span>]
x0 <span style="color: #666666">=</span> <span style="color: #008000">float</span>(argv[<span style="color: #666666">3</span>])
xmin <span style="color: #666666">=</span> <span style="color: #008000">float</span>(argv[<span style="color: #666666">4</span>])
xmax <span style="color: #666666">=</span> <span style="color: #008000">float</span>(argv[<span style="color: #666666">5</span>])

i <span style="color: #666666">=</span> <span style="color: #666666">0</span>
tol <span style="color: #666666">=</span> <span style="color: #666666">1.0e-9</span>
maxit <span style="color: #666666">=</span> <span style="color: #666666">100</span>
x <span style="color: #666666">=</span> x0
f <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(f_str, <span style="color: #008000">vars</span>())
dfdx <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(dfdx_str, <span style="color: #008000">vars</span>())
xs <span style="color: #666666">=</span> []
fs <span style="color: #666666">=</span> []
xs<span style="color: #666666">.</span>append(x)
fs<span style="color: #666666">.</span>append(f)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;x=</span><span style="color: #BB6688; font-weight: bold">%.3e</span><span style="color: #BA2121">   f=</span><span style="color: #BB6688; font-weight: bold">%.3e</span><span style="color: #BA2121">   dfdx=</span><span style="color: #BB6688; font-weight: bold">%.3e</span><span style="color: #BA2121"> &quot;</span> <span style="color: #666666">%</span>  (x, f, dfdx))
<span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(f) <span style="color: #666666">&gt;</span> tol <span style="color: #AA22FF; font-weight: bold">and</span> i <span style="color: #666666">&lt;=</span> maxit <span style="color: #AA22FF; font-weight: bold">and</span> x <span style="color: #666666">&gt;</span> xmin <span style="color: #AA22FF; font-weight: bold">and</span> x <span style="color: #666666">&lt;</span> xmax :
  x <span style="color: #666666">=</span> x0 <span style="color: #666666">-</span> f<span style="color: #666666">/</span>dfdx
  f <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(f_str, <span style="color: #008000">vars</span>())
  dfdx <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(dfdx_str, <span style="color: #008000">vars</span>())
  x0 <span style="color: #666666">=</span> x
  xs<span style="color: #666666">.</span>append(x0)
  fs<span style="color: #666666">.</span>append(f)
  i <span style="color: #666666">=</span> i<span style="color: #666666">+1</span>
  <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;x=</span><span style="color: #BB6688; font-weight: bold">%.3e</span><span style="color: #BA2121">   f=</span><span style="color: #BB6688; font-weight: bold">%.3e</span><span style="color: #BA2121">   dfdx=</span><span style="color: #BB6688; font-weight: bold">%.3e</span><span style="color: #BA2121"> &quot;</span> <span style="color: #666666">%</span>  (x, f, dfdx))

x <span style="color: #666666">=</span> arange(xmin, xmax, (xmax<span style="color: #666666">-</span>xmin)<span style="color: #666666">/100.0</span>)
f <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(f_str, <span style="color: #008000">vars</span>())

plt<span style="color: #666666">.</span>plot(x, f, <span style="color: #BA2121">&quot;g&quot;</span>)
plt<span style="color: #666666">.</span>plot(xs, fs, <span style="color: #BA2121">&quot;bo&quot;</span>)
plt<span style="color: #666666">.</span>plot(xs, fs, <span style="color: #BA2121">&quot;b&quot;</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:vib:Jacobian" class="anchor">Problem 46: Compute the Jacobian of a \( 2\times 2 \) system</h2>

<p>
Write up the system <a href="._fem-book-sol028.html#mjx-eqn-9.18">(9.18)</a>-<a href="._fem-book-sol028.html#mjx-eqn-9.19">(9.19)</a> in the form \( F(u)=0 \), \( F=(F_0,F_1) \), \( u=(u_0,u_1) \),
and compute the Jacobian \( J_{i,j}=\partial F_i/\partial u_j \).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:vib:geometric:mean" class="anchor">Problem 47: Solve nonlinear equations arising from a vibration ODE</h2>

<p>
Consider a nonlinear vibration problem

$$
\begin{equation}
mu^{\prime\prime} + bu^{\prime}|u^{\prime}| + s(u) = F(t),
\tag{9.73}
\end{equation}
$$

where \( m>0 \) is a constant, \( b\geq 0 \) is a constant, \( s(u) \) a possibly
nonlinear function of \( u \), and \( F(t) \) is a prescribed function. Such
models arise from Newton's second law of motion in mechanical
vibration problems where \( s(u) \) is a spring or restoring force,
\( mu^{\prime\prime} \) is mass times acceleration, and
\( bu^{\prime}|u^{\prime}| \) models water or air drag.

<p>
<b>a)</b>
Rewrite the equation for \( u \) as a system of two first-order ODEs, and
discretize this system by a Crank-Nicolson (centered difference)
method. With \( v=u^\prime \), we get a nonlinear term
\( v^{n+\frac{1}{2}}|v^{n+\frac{1}{2}}| \). Use a geometric
average for \( v^{n+\frac{1}{2}} \).

<p>
<b>b)</b>
Formulate a Picard iteration method to solve the system of nonlinear
algebraic equations.

<p>
<b>c)</b>
Explain how to apply Newton's method to solve the nonlinear equations
at each time level. Derive expressions for the Jacobian and the
right-hand side in each Newton iteration.

<p>
<!-- 2DO: b) Newmark scheme -->
<!-- derive it logically and connect it to the centered diff scheme -->
<!-- ma + bv|v| + s(u) = F(t), v'=a, u'=v (staggered is natural, -->
<!-- v at n+1/2 and a and u at n). Should be in vib first -->

<p>
Filename: <code>nonlin_vib</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:products:arith:mean" class="anchor">Exercise 48: Find the truncation error of arithmetic mean of products</h2>

<p>
In the section <a href="._fem-book-sol030.html#nonlin:pdelevel:Picard:CN">Crank-Nicolson discretization</a> we introduce alternative
arithmetic means of a product. Say the product is \( P(t)Q(t) \) evaluated
at \( t=t_{n+\frac{1}{2}} \). The exact value is

$$ [PQ]^{n+\frac{1}{2}} = P^{n+\frac{1}{2}}Q^{n+\frac{1}{2}} $$

There are two obvious candidates for evaluating \( [PQ]^{n+\frac{1}{2}} \)
as a mean of values of \( P \) and \( Q \) at \( t_n \) and \( t_{n+1} \). Either
we can take the arithmetic mean of each factor \( P \) and \( Q \),

$$
\begin{equation}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^n + P^{n+1})\frac{1}{2}(Q^n + Q^{n+1}),
\tag{9.74}
\end{equation}
$$

or we can take the arithmetic mean of the product \( PQ \):

$$
\begin{equation}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^nQ^n + P^{n+1}Q^{n+1})\tp
\tag{9.75}
\end{equation}
$$

<p>
The arithmetic average
of \( P(t_{n+\frac{1}{2}}) \) is \( \Oof{\Delta t^2} \):

$$ P(t_{n+\frac{1}{2}}) = \frac{1}{2}(P^n + P^{n+1}) +\Oof{\Delta t^2}\tp$$

A fundamental question is whether <a href="#mjx-eqn-9.74">(9.74)</a>
and <a href="#mjx-eqn-9.75">(9.75)</a> have different
orders of accuracy in \( \Delta t = t_{n+1}-t_n \). To investigate
this question, expand quantities at \( t_{n+1} \) and \( t_n \) in
Taylor series around \( t_{n+\frac{1}{2}} \), and subtract the true
value \( [PQ]^{n+\frac{1}{2}} \) from the approximations
<a href="#mjx-eqn-9.74">(9.74)</a> and
<a href="#mjx-eqn-9.75">(9.75)</a> to see what the
order of the error terms are.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_48_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_48_1">

<p>
You may explore <code>sympy</code> for carrying out the tedious calculations.
A general Taylor series expansion of \( P(t+\frac{1}{2}\Delta t) \) around \( t \)
involving just a general function \( P(t) \) can be
created as follows:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t, dt <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t dt&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> P <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #008000">cls</span><span style="color: #666666">=</span>Function)
<span style="color: #666666">&gt;&gt;&gt;</span> P(t)<span style="color: #666666">.</span>series(t, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)
P(<span style="color: #666666">0</span>) <span style="color: #666666">+</span> t<span style="color: #666666">*</span>Subs(Derivative(P(_x), _x), (_x,), (<span style="color: #666666">0</span>,)) <span style="color: #666666">+</span>
t<span style="color: #666666">**2*</span>Subs(Derivative(P(_x), _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/2</span> <span style="color: #666666">+</span>
t<span style="color: #666666">**3*</span>Subs(Derivative(P(_x), _x, _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/6</span> <span style="color: #666666">+</span> O(t<span style="color: #666666">**4</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> P_p <span style="color: #666666">=</span> P(t)<span style="color: #666666">.</span>series(t, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)<span style="color: #666666">.</span>subs(t, dt<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> P_p
P(<span style="color: #666666">0</span>) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>Subs(Derivative(P(_x), _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/2</span> <span style="color: #666666">+</span>
dt<span style="color: #666666">**2*</span>Subs(Derivative(P(_x), _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/8</span> <span style="color: #666666">+</span>
dt<span style="color: #666666">**3*</span>Subs(Derivative(P(_x), _x, _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/48</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**4</span>)
</pre></div>
<p>
The error of the arithmetic mean, \( \frac{1}{2}(P(-\frac{1}{2}\Delta t)
+ P(-\frac{1}{2}\Delta t)) \) for \( t=0 \) is then

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> P_m <span style="color: #666666">=</span> P(t)<span style="color: #666666">.</span>series(t, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)<span style="color: #666666">.</span>subs(t, <span style="color: #666666">-</span>dt<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> mean <span style="color: #666666">=</span> Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>)<span style="color: #666666">*</span>(P_m <span style="color: #666666">+</span> P_p)
<span style="color: #666666">&gt;&gt;&gt;</span> error <span style="color: #666666">=</span> simplify(expand(mean) <span style="color: #666666">-</span> P(<span style="color: #666666">0</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> error
dt<span style="color: #666666">**2*</span>Subs(Derivative(P(_x), _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/8</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**4</span>)
</pre></div>
<p>
Use these examples to investigate the error of
<a href="#mjx-eqn-9.74">(9.74)</a> and
<a href="#mjx-eqn-9.75">(9.75)</a> for \( n=0 \). (Choosing \( n=0 \)
is necessary for not making the expressions too complicated for <code>sympy</code>,
but there is of course no lack of generality by using \( n=0 \) rather
than an arbitrary \( n \) - the main point is the product and addition
of Taylor series.)

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>product_arith_mean</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:Newton:linear" class="anchor">Problem 49: Newton's method for linear problems</h2>

<p>
Suppose we have a linear system \( F(u) = Au- b=0 \). Apply Newton's method
to this system, and show that the method converges in one iteration.
Filename: <code>Newton_linear</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:1pu2:fem" class="anchor">Exercise 50: Discretize a 1D problem with a nonlinear coefficient</h2>

<p>
We consider the problem

$$
\begin{equation}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0\tp
\tag{9.76}
\end{equation}
$$

<p>
Discretize <a href="#mjx-eqn-9.76">(9.76)</a> by a centered
finite difference method on a uniform mesh.
Filename: <code>nonlin_1D_coeff_discretize</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:1pu2:PicardNewton" class="anchor">Exercise 51: Linearize a 1D problem with a nonlinear coefficient</h2>

<p>
We have a two-point boundary value problem

$$
\begin{equation}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0\tp
\tag{9.77}
\end{equation}
$$

<p>
<b>a)</b>
Construct a Picard iteration method for <a href="#mjx-eqn-9.77">(9.77)</a>
without discretizing in space.

<p>
<b>b)</b>
Apply Newton's method to <a href="#mjx-eqn-9.77">(9.77)</a>
without discretizing in space.

<p>
<b>c)</b>
Discretize <a href="#mjx-eqn-9.77">(9.77)</a> by a centered finite
difference scheme. Construct a Picard method for the resulting
system of nonlinear algebraic equations.

<p>
<b>d)</b>
Discretize <a href="#mjx-eqn-9.77">(9.77)</a> by a centered finite
difference scheme. Define the system of nonlinear algebraic equations,
calculate the Jacobian, and set up Newton's method for solving the system.

<p>
Filename: <code>nonlin_1D_coeff_linearize</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:fu:discretize:fd" class="anchor">Problem 52: Finite differences for the 1D Bratu problem</h2>

<p>
We address the so-called Bratu problem

$$
\begin{equation}
u^{\prime\prime} + \lambda e^u=0,\quad x\in (0,1),\quad u(0)=u(1)=0,
\tag{9.78}
\end{equation}
$$

where \( \lambda \) is a given parameter and \( u \) is a function of \( x \).
This is a widely used model problem for studying numerical
methods for nonlinear differential equations.
The problem <a href="#mjx-eqn-9.78">(9.78)</a> has an
exact solution

$$ \uex(x) = -2\ln\left(\frac{\cosh((x-\half)\theta/2)}{\cosh(\theta/4)}\right),$$

where \( \theta \) solves

$$ \theta = \sqrt{2\lambda}\cosh(\theta/4)\tp$$

There are two solutions of <a href="#mjx-eqn-9.78">(9.78)</a> for
\( 0 < \lambda < \lambda_c \) and no solution for \( \lambda >\lambda_c \).
For \( \lambda = \lambda_c \) there is one unique solution. The critical
value \( \lambda_c \) solves

$$ 1 = \sqrt{2\lambda_c}\frac{1}{4}\sinh(\theta(\lambda_c)/4)\tp$$

A numerical value is \( \lambda_c = 3.513830719 \).

<p>
<b>a)</b>
Discretize <a href="#mjx-eqn-9.78">(9.78)</a> by a
centered finite difference method.

<p>
<b>b)</b>
Set up the nonlinear equations \( F_i(u_0,u_1,\ldots,u_{N_x})=0 \)
from a). Calculate the associated Jacobian.

<p>
<b>c)</b>
Implement a solver that can compute \( u(x) \) using Newton's method.
Plot the error as a function of \( x \) in each iteration.

<p>
<b>d)</b>
Investigate whether Newton's method gives second-order convergence
by computing
\( || \uex - u||/||\uex - u^{-}||^2 \)
in each iteration, where \( u \) is solution in the current iteration and
\( u^{-} \) is the solution in the previous iteration.

<p>
Filename: <code>nonlin_1D_Bratu_fd</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:heat:nonlinear:fdm" class="anchor">Exercise 53: Discretize a nonlinear 1D heat conduction PDE by finite differences</h2>

<p>
We address the 1D heat conduction PDE

$$ \varrho c(T) T_t = (k(T)T_x)_x,$$

for \( x\in [0,L] \),
where \( \varrho \) is the density of the solid material, \( c(T) \) is
the heat capacity, \( T \) is the temperature, and \( k(T) \) is the
heat conduction coefficient. \( T(x,0)=I(x) \), and ends are
subject to a cooling law:

$$ k(T)T_x|_{x=0} = h(T)(T-T_s),\quad -k(T)T_x|_{x=L}=h(T)(T-T_s),$$

where \( h(T) \) is a heat transfer coefficient and \( T_s \) is the
given surrounding temperature.

<p>
<b>a)</b>
Discretize this PDE in time using either a
Backward Euler or Crank-Nicolson scheme.

<p>
<b>b)</b>
Formulate a Picard iteration method for the time-discrete problem
(i.e., an iteration method before discretizing in space).

<p>
<b>c)</b>
Formulate a Newton method for the time-discrete problem in b).

<p>
<b>d)</b>
Discretize the PDE by a finite difference method in space.
Derive the matrix and right-hand side of a Picard iteration method applied
to the space-time discretized PDE.

<p>
<b>e)</b>
Derive the matrix and right-hand side of a Newton method applied
to the discretized PDE in d).

<p>
Filename: <code>nonlin_1D_heat_FD</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:grad:pow:term" class="anchor">Exercise 54: Differentiate a highly nonlinear term</h2>

<p>
The operator \( \nabla\cdot(\dfc(u)\nabla u) \) with
\( \dfc(u) = |\nabla u|^q \) appears in several physical problems,
especially flow of Non-Newtonian fluids. The expression \( |\nabla u| \)
is defined as the Euclidean norm of a vector:
\( |\nabla u|^2 = \nabla u \cdot \nabla u \).
In a Newton method one
has to carry out the differentiation \( \partial\dfc(u)/\partial c_j \),
for \( u=\sum_kc_k\baspsi_k \). Show that

$$ {\partial\over\partial u_j} |\nabla u|^q =
q|\nabla  u|^{q-2}\nabla u\cdot
\nabla\baspsi_j\tp $$

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_54_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_54_1">

$$
\begin{align*}
\frac{\partial }{\partial c_j}|\nabla u |^q &=
\frac{\partial }{\partial c_j}(\nabla u\cdot \nabla u )^{\tfrac{q}{2}}
= \frac{q}{2} (\nabla u\cdot \nabla u )^{\tfrac{q}{2}-1}
\frac{\partial }{\partial c_j}(\nabla u\cdot \nabla u )\\ 
&=\frac{q}{2} |\nabla u |^{q-2}(\frac{\partial }{\partial c_j}(\nabla u)
\cdot \nabla u + \nabla u \cdot\frac{\partial }{\partial c_j}(\nabla u))\\ 
&=q|\nabla u |^{q-2}(\nabla u \cdot \nabla \frac{\partial u}{\partial c_j})
=q|\nabla u |^{q-2}(\nabla u \cdot \nabla\psi_j)
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>nonlin_differentiate</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:2D:heat:nonlinear:fd" class="anchor">Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion equation</h2>

<p>
Redo the section <a href="._fem-book-sol032.html#nonlin:alglevel:dD:fd">Finite difference discretization</a> when a Crank-Nicolson scheme
is used to discretize the equations in time and the problem is
formulated for three spatial dimensions.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_55_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_55_1">

<p>
Express the Jacobian as \( J_{i,j,k,r,s,t} = \partial F_{i,j,k}/\partial u_{r,s,t} \) and observe, as in the 2D case, that \( J_{i,j,k,r,s,t} \) is very sparse:
\( J_{i,j,k,r,s,t}\neq 0 \) only for \( r=i\pm i \), \( s=j\pm 1 \), and \( t=k\pm 1 \)
as well as \( r=i \), \( s=j \), and \( t=k \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>nonlin_heat_FD_CN_2D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:sparsity:Jacobian" class="anchor">Exercise 56: Find the sparsity of the Jacobian</h2>

<p>
Consider a typical nonlinear Laplace term like
\( \nabla\cdot\dfc(u)\nabla u \) discretized by centered finite differences.
Explain why the Jacobian corresponding to this term has the same
sparsity pattern as the matrix associated with the corresponding linear
term \( \dfc\nabla^2 u \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_56_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_56_1">

<p>
Set up the unknowns that enter the difference equation at a
point \( (i,j) \) in 2D or \( (i,j,k) \) in 3D, and identify the
nonzero entries of the Jacobian that can arise from such a type
of difference equation.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>nonlin_sparsity_Jacobian</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:continuation:1DnNflow" class="anchor">Problem 57: Investigate a 1D problem with a continuation method</h2>

<p>
Flow of a pseudo-plastic power-law fluid between two flat plates can be
modeled by

$$ \frac{d}{dx}\left(\mu_0\left\vert\frac{du}{dx}\right\vert^{n-1}
\frac{du}{dx}\right) = -\beta,\quad u^{\prime}(0)=0,\ u(H) = 0,$$

where \( \beta>0 \) and \( \mu_0>0 \) are constants.
A target value of \( n \) may be \( n=0.2 \).

<p>
<b>a)</b>
Formulate a Picard iteration method directly for the differential
equation problem.

<p>
<b>b)</b>
Perform a finite difference discretization of the problem in
each Picard iteration. Implement a solver that can compute \( u \)
on a mesh. Verify that the solver gives an exact solution for \( n=1 \)
on a uniform mesh regardless of the cell size.

<p>
<b>c)</b>
Given a sequence of decreasing \( n \) values, solve the problem for each
\( n \) using the solution for the previous \( n \) as initial guess for
the Picard iteration. This is called a continuation method.
Experiment with \( n=(1,0.6,0.2) \) and \( n=(1,0.9,0.8,\ldots,0.2) \)
and make a table of the number of Picard iterations versus \( n \).

<p>
<b>d)</b>
Derive a Newton method at the differential equation level and
discretize the resulting linear equations in each Newton iteration
with the finite difference method.

<p>
<b>e)</b>
Investigate if Newton's method has better convergence properties than
Picard iteration, both in combination with a continuation method.

<p>
<!-- --- end exercise --- -->

<h1 id="nonlin:app:fem_vs_fdm" class="anchor">Symbolic nonlinear finite element equations</h1>

<p>
The integrals in nonlinear finite element equations are computed
by numerical integration rules in computer programs, so the
formulas for the variational form is directly transferred to numbers.
It is of interest to understand the nature of the system of difference equations
that arises from the finite element method in nonlinear problems and
to compare with corresponding expressions arising from finite difference
discretization. We shall dive into this problem here. To see the
structure of the difference equations implied by the finite element method,
we have to find symbolic expressions for the integrals, and this is
extremely difficult since the integrals involve the unknown function
in nonlinear problems. However, there are some techniques that allow
us to approximate the integrals and work out symbolic formulas that
can compared with their finite difference counterparts.

<p>
We shall address the 1D model problem <a href="._fem-book-sol031.html#mjx-eqn-9.50">(9.50)</a> from
the beginning of the section <a href="._fem-book-sol031.html#nonlin:alglevel:1D">1D stationary nonlinear differential equations</a>.
The finite difference discretization is shown in the section <a href="._fem-book-sol031.html#nonlin:alglevel:1D:fd">Finite difference discretization</a>, while the variational form based on
Galerkin's method is developed in the section ref{nonlin:alglevel:1D:fe}.
We build directly on formulas developed in the latter section.

<h2 id="nonlin:alglevel:1D:fe_basis" class="anchor">Finite element basis functions</h2>

<p>
Introduction of finite element basis functions \( \basphi_i \) means setting

$$ \baspsi_i = \basphi_{\nu(i)},\quad i\in\If,$$

where degree of freedom number \( \nu(i) \) in the mesh corresponds to
unknown number \( i \) (\( c_i \)).
In the present example, we use all the basis functions except the
last at \( i=N_n-1 \), i.e., \( \If = \{0,\ldots,N_n-2\} \), and \( \nu(j)=j \).
The expansion of \( u \) can be taken as

$$ u = D + \sum_{j\in\If} c_j\basphi_{\nu(j)},$$

but it is more common in a finite element context to use a boundary
function \( B=\sum_{j\in\Ifb}U_j\basphi_j \), where \( U_j \) are prescribed
Dirichlet conditions for degree of freedom number \( j \) and \( U_j \) is
the corresponding value.

$$ u = D\basphi_{N_n-1} + \sum_{j\in\If} c_j\basphi_{\nu(j)}\tp
$$

In the general case with \( u \) prescribed as \( U_j \) at some nodes \( j\in\Ifb \),
we set

$$ u = \sum_{j\in\Ifb} U_j\basphi_j +
\sum_{j\in\If}c_j\basphi_{\nu(j)},$$

where \( c_j = u(x^{\nu(j)}) \). That is, \( \nu(j) \) maps unknown number \( j \) to
the corresponding node number \( \nu(j) \) such that \( c_j = u(x^{\nu(j)}) \).

<h2 id="nonlin:alglevel:1D:fe:group" class="anchor">The group finite element method</h2>

<h3 id="___sec382" class="anchor">Finite element approximation of functions of \( u \) </h3>

<p>
Since we already expand \( u \) as \( \sum_j\basphi_j u(\xno{j}) \), we may use the
same approximation for other functions as well. For example,

$$
f(u)\approx \sum_{j} f(\xno{j})\basphi_j,
$$

where \( f(\xno{j}) \) is the value of \( f \) at node \( j \). Since \( f \) is a function
of \( u \), \( f(\xno{j})=f(u(\xno{j})) \). Introducing
\( u_j \) as a short form for \( u(\xno{j}) \), we can write

$$
f(u)\approx \sum_{j} f(u_{j})\basphi_j\tp
$$

This approximation is known as the <em>group finite element method</em>
or the <em>product approximation</em> technique. The index \( j \) runs over
all node numbers in the mesh.

<p>
The principal advantages of the group finite element method are two-fold:

<ol>
<li> Complicated nonlinear expressions can be simplified to increase
   the efficiency of numerical computations.</li>
<li> One can derive <em>symbolic forms</em> of the difference equations arising
   from the finite element method in nonlinear problems.
   The symbolic form is useful for comparing finite element and finite
   difference equations of nonlinear differential equation problems.</li>
</ol>

Below, we shall explore point 2 to see exactly how the finite element
method creates more complex expressions in the resulting
linear system (the difference equations) that the finite difference
method does. It turns out that is very difficult to see
what kind of terms in the difference equations that arise from
\( \int f(u)\basphi_i\dx \) without using the group finite element
method or numerical integration utilizing the nodes only.

<p>
Note, however, that an expression like \( \int f(u)\basphi_i\dx \) causes
no problems in a computer program as the integral is calculated by
numerical integration using an existing approximation of \( u \) in
\( f(u) \) such that the integrand can be sampled at any spatial point.

<h3 id="___sec383" class="anchor">Simplified problem </h3>

<p>
Our aim now is to derive symbolic expressions for the difference
equations arising from the finite element method in nonlinear
problems and compare the expressions with those arising in the
finite difference method. To this end,
let us simplify the model problem and set \( a=0 \), \( \dfc=1 \),
\( f(u)=u^2 \), and have Neumann conditions at both ends such that we
get a very simple nonlinear problem \( -u^{\prime\prime}=u^2 \),
\( u'(0)=1 \), \( u'(L)=0 \).
The variational form is then

$$ \int_0^L u^{\prime}v^{\prime}\dx = \int_0^L u^2v\dx
- v(0),\quad\forall v\in V\tp$$

The term with \( u^{\prime}v^{\prime} \) is well known so the only new feature is
the term \( \int u^2v\dx \).

<p>
To make the distance from finite element equations to finite
difference equations as short as possible, we shall substitute \( c_j \)
in the sum \( u=\sum_jc_j\basphi_j \) by \( u_j=u(\xno{j}) \) since \( c_j \) is
the value of \( u \) at node \( j \). (In the more general case
with Dirichlet conditions as well, we have a sum
\( \sum_jc_j\basphi_{\nu(j)} \) where \( c_j \) is replaced by \( u(\xno{\nu(j)}) \).
We can then introduce some other counter \( k \) such that it is
meaningful to write \( u=\sum_k u_k\basphi_k \), where \( k \) runs over appropriate
node numbers.)
The quantity \( u_j \) in \( \sum_ju_j\basphi_j \)
is the same as \( u \) at mesh point number \( j \)
in the finite difference method, which is commonly denoted \( u_j \).

<h3 id="___sec384" class="anchor">Integrating nonlinear functions </h3>

<p>
Consider the term \( \int u^2v\dx \) in the variational formulation
with \( v=\basphi_i \) and \( u=\sum_k\basphi_ku_k \):

$$ \int_0^L (\sum_ku_k\basphi_k)^2\basphi_i\dx\tp$$

Evaluating this integral for P1 elements (see ref{nonlin:exer:fu:fem:int}) results in the expression

$$ \frac{h}{12}(u_{i-1}^2 + 2u_i(u_{i-1} + u_{i+1}) + 6u_i^2
+ u_{i+1}^2),$$

to be compared with the simple value \( u_i^2 \) that would arise in
a finite difference discretization when \( u^2 \) is sampled at
mesh point \( x_i \). More complicated \( f(u) \) functions
in the integral \( \int_0^L f(u)\basphi_i\dx \)
give rise to much more lengthy expressions, if it is possible to
carry out the integral symbolically at all.

<h3 id="___sec385" class="anchor">Application of the group finite element method </h3>

<p>
Let us use the group finite element method to derive the terms in
the difference equation corresponding to \( f(u) \) in the differential
equation. We have

$$ \int_0^L f(u)\basphi_i\dx \approx
\int_0^L (\sum_j \basphi_jf(u_j))\basphi_i\dx
= \sum_j \left(\int_0^L \basphi_i\basphi_j\dx\right) f(u_j)\tp$$

We recognize this expression as the mass matrix \( M \), arising from
\( \int\basphi_i\basphi_j\dx \), times the
vector \( f=(f(u_0),f(u_1),\ldots,) \): \( Mf \). The associated terms
in the difference equations are, for P1 elements,

$$ \frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1}))\tp$$

Occasionally, we want to interpret this expression in terms of finite
differences, and to this end a rewrite of this expression is convenient:

$$ \frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1}))
= h[f(u) - \frac{h^2}{6}D_xD_x f(u)]_i\tp$$

That is, the finite element treatment of \( f(u) \) (when using a group
finite element method) gives the same term as in a finite difference
approach, \( f(u_i) \), minus a diffusion term which is the
2nd-order discretization of \( \frac{1}{6}h^2f''(x_i) \).

<p>
We may lump the mass matrix through integration with the Trapezoidal
rule so that \( M \) becomes diagonal in the finite element method.
In that case the \( f(u) \) term in the differential equation
gives rise to a single term \( hf(u_i) \), just as in the finite difference
method.

<h2 id="nonlin:alglevel:1D:fe:f" class="anchor">Numerical integration of nonlinear terms by hand</h2>

<p>
Let us reconsider a term \( \int f(u)v\dx \) as treated in the previous
section, but now we want to integrate this term numerically.
Such an approach can lead to easy-to-interpret formulas if we apply
a numerical integration rule that samples the integrand at the node
points \( \xno{i} \) only, because at such points, \( \basphi_j(\xno{i})=0 \)
if \( j\neq i \), which leads to great simplifications.

<p>
The term in question takes the form

$$ \int_0^L f(\sum_k u_k\basphi_k)\basphi_i\dx\tp$$

Evaluation of the integrand at a node \( \xno{\ell} \) leads to a
collapse of the sum \( \sum_k u_k\basphi_k \) to one term because

$$ \sum_k u_k\basphi_k(\xno{\ell}) = u_\ell\tp$$


$$ f(\sum_k u_k\underbrace{\basphi_k(\xno{\ell})}_{\delta_{k\ell}})
\underbrace{\basphi_i(\xno{\ell})}_{\delta_{i\ell}}
= f(u_\ell)\delta_{i\ell},$$

where we have used the Kronecker delta: \( \delta_{ij}=0 \) if \( i\neq j \) and
\( \delta_{ij}=1 \) if \( i=j \).

<p>
Considering the Trapezoidal rule for integration, where the integration
points are the nodes, we have

$$
\int_0^L f(\sum_k u_k\basphi_k(x))\basphi_i(x)\dx
\approx h\sum_{\ell=0}^{N_n} f(u_\ell)\delta_{i\ell} - \mathcal{C}
= hf(u_i)\tp
$$

This is the same representation of the \( f \) term as in the finite
difference method.
The term \( \mathcal{C} \) contains the evaluations of the integrand
at the ends with weight \( \half \), needed to make a true Trapezoidal rule:

$$ \mathcal{C} = \frac{h}{2}f(u_0)\basphi_i(0) + \frac{h}{2}f(u_{N_n-1})\basphi_i(L)\tp$$

The answer \( hf(u_i) \) must therefore be multiplied by \( \half \) if
\( i=0 \) or \( i=N_n-1 \). Note that \( \mathcal{C}=0 \) for \( i=1,\ldots,N_n-2 \).

<p>
One can alternatively use the Trapezoidal rule on the reference cell and
assemble the contributions. It is a bit more labor in this context,
but working on the reference cell is safer as that approach is
guaranteed to handle discontinuous derivatives of finite element
functions correctly (not important in this particular example),
while the rule above was derived with the
assumption that \( f \) is continuous at the integration points.

<p>
The conclusion is that it suffices to use the Trapezoidal rule if
one wants to derive the difference equations in the finite element
method and make them similar to those arising in the finite difference
method. The Trapezoidal rule has sufficient accuracy for P1 elements, but
for P2 elements one should turn to Simpson's rule.

<h2 id="nonlin:alglevel:1D:fe:Laplace" class="anchor">Discretization of a variable coefficient Laplace term</h2>

<p>
Turning back to the model problem <a href="._fem-book-sol031.html#mjx-eqn-9.50">(9.50)</a>, it
remains to calculate the contribution of the \( (\dfc u^{\prime})^{\prime} \)
and boundary terms
to the difference equations. The integral in the variational form
corresponding to \( (\dfc u^{\prime})^{\prime} \) is

$$ \int_0^L \dfc(\sum_k c_k\baspsi_k)\baspsi_i^{\prime}\baspsi_j^{\prime}\dx\tp$$

Numerical integration utilizing a value of \( \sum_k c_k\baspsi_k \) from
a previous iteration must in general be used to compute the integral.
Now our aim is to integrate symbolically, as much as we can, to obtain
some insight into how the finite element method approximates
this term.
To be able to derive symbolic expressions, we must either turn to
the group finite element method or numerical integration in the
node points. Finite element basis functions \( \basphi_i \) are now used.

<h3 id="___sec388" class="anchor">Group finite element method </h3>

<p>
We set \( \dfc(u)\approx \sum_k\alpha(u_k)\basphi_k \), and then
we write

$$
\int_0^L \dfc(\sum_k c_k\basphi_k)\basphi_i^{\prime}\basphi_j^{\prime}\dx
\approx
\sum_k (\underbrace{\int_0^L \basphi_k\basphi_i^{\prime}\basphi_j^{\prime}\dx}_{L_{i,j,k}})
\dfc(u_k) = \sum_k L_{i,j,k}\dfc(u_k)\tp
$$

Further calculations are now easiest to carry out in the reference
cell. With P1 elements we can compute
\( L_{i,j,k} \) for the two \( k \) values that are relevant on the reference
cell. Turning to local indices, one gets

$$
L_{r,s,t}^{(e)} =
\frac{1}{2h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad t=0, 1,
$$

where \( r,s,t=0,1 \) are indices over local degrees of
freedom in the reference cell
(\( i=q(e,r) \), \( j=q(e,s) \), and \( k=q(e,t) \)). The
sum \( \sum_k L_{i,j,k}\dfc(u_k) \) at the cell level becomes
\( \sum_{t=0}^1 L_{r,s,t}^{(e)}\dfc(\tilde u_t) \), where \( \tilde u_t \)
is \( u(\xno{q(e,t)}) \), i.e., the value of \( u \) at local node number \( t \) in
cell number \( e \). The element matrix becomes

$$
\begin{equation}
\half (\dfc(\tilde u_0) + \dfc(\tilde u^{(1)}))
\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right)\tp
\tag{9.79}
\end{equation}
$$

As usual, we employ
a left-to-right numbering of cells and nodes.
Row number \( i \) in the global matrix gets contributions from
the first row of the element matrix in cell \( i \) and the last
row of the element matrix in cell \( i-1 \).
In cell number \( i-1 \) the sum
\( \dfc(\tilde u_0) + \dfc(\tilde u^{(1)}) \) corresponds to
\( \dfc(u_{i-1}) + \dfc(u_i) \). The same sum becomes
\( \dfc(u_{i}) + \dfc(u_{i+1}) \) in cell number \( i \).
We can with this insight assemble the contributions to row number \( i \)
in the global matrix:

$$ \frac{1}{2h}(-(\dfc(u_{i-1}) + \dfc(u_i)),\quad
\dfc(u_{i-1}) + 2\dfc(u_i) + \dfc(u_{i+1}),\quad
\dfc(u_{i}) + \dfc(u_{i+1}))\tp
$$

Multiplying by the vector of unknowns \( u_i \) results in a formula that
can be arranged to

$$
\begin{equation}
-\frac{1}{h}(\half(\dfc(u_i) + \dfc(u_{i+1}))(u_{i+1}-u_i)
-  \half(\dfc(u_{i-1}) + \dfc(u_{i}))(u_{i}-u_{i-1})),
\tag{9.80}
\end{equation}
$$

which is nothing but the standard finite difference discretization
of \( -(\dfc(u)u^{\prime})^{\prime} \) with an arithmetic mean of \( \dfc(u) \) (and
the usual factor \( h \) because of the integration in the finite element method).

<h3 id="___sec389" class="anchor">Numerical integration at the nodes </h3>

<p>
Instead of using the group finite element method and exact integration
we can turn to the Trapezoidal rule for computing
\( \int_0^L \dfc(\sum_k u_k\basphi_k)\basphi_i^{\prime}\basphi_j^{\prime}\dx \), again at
the cell level since that is most convenient when we deal with discontinuous
functions \( \basphi_i' \):

$$
\begin{align}
\int_{-1}^1 \alpha(\sum_t\tilde u_t\refphi_t)\refphi_r'\refphi_s'\frac{h}{2}dX
&= \int_{-1}^1 \dfc(\sum_{t=0}^1
\tilde u_t\refphi_t)\frac{2}{h}\frac{d\refphi_r}{dX}
\frac{2}{h}\frac{d\refphi_s}{dX}\frac{h}{2}dX\nonumber\\ 
& = \frac{1}{2h}(-1)^r(-1)^s \int_{-1}^1 \dfc(\sum_{t=0}^1 u_t\refphi_t(X))dX
\nonumber\\ 
& \approx \frac{1}{2h}(-1)^r(-1)^s\dfc (
\sum_{t=0}^1\refphi_t(-1)\tilde u_t) + \dfc(\sum_{t=0}^1\refphi_t(1)\tilde u_t)
\nonumber\\ 
& = \frac{1}{2h}(-1)^r(-1)^s(\dfc(\tilde u_0) + \dfc(\tilde u^{(1)}))\tp
\tag{9.81}
\end{align}
$$

The element matrix in <a href="#mjx-eqn-9.81">(9.81)</a>
is identical to the one in
<a href="#mjx-eqn-9.79">(9.79)</a>, showing that the
group finite element method and Trapezoidal integration are
equivalent with a standard finite discretization of a
nonlinear Laplace term \( (\dfc(u)u^{\prime})^{\prime} \) using an arithmetic mean for
\( \dfc \): \( [D_x\overline{x}D_xu]_i \).

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark about integration in the physical \( x \) coordinate.</b>
We might comment on integration in the physical coordinate system too.
The common Trapezoidal rule in the section <a href="#nonlin:alglevel:1D:fe:f">Numerical integration of nonlinear terms by hand</a>
cannot be used to integrate derivatives like \( \basphi_i^{\prime} \), because
the formula is derived under the assumption of a continuous integrand.
One must instead use the more basic version of the Trapezoidal rule
where all the trapezoids are summed up. This is straightforward, but
I think it is even more straightforward to apply the Trapezoidal
rule on the reference cell and assemble the contributions.
</div>


<p>
The term \( \int auv\dx \) in the variational form is linear and gives
these terms in the algebraic equations:

$$ \frac{ah}{6}(u_{i-1} + 4u_i + u_{i+1})
= ah[u - \frac{h^2}{6}D_xD_x u]_i\tp$$

The final term in the variational form is the Neumann condition
at the boundary: \( Cv(0)=C\basphi_i(0) \). With a left-to-right numbering
only \( i=0 \) will give a contribution \( Cv(0)=C\delta_{i0} \) (since
\( \basphi_i(0)\neq 0 \) only for \( i=0 \)).

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Summary.</b>
For the equation

$$ -(\dfc(u)u^{\prime})^{\prime} +au = f(u),$$

P1 finite elements results in difference equations where

<ul>
 <li> the term \( -(\dfc(u)u^{\prime})^{\prime} \) becomes \( -h[D_x\overline{\dfc(u)}^xD_x u]_i \)
   if the group finite element method or Trapezoidal integration is applied,</li>
 <li> \( f(u) \) becomes \( hf(u_i) \) with Trapezoidal integration or the
   &quot;mass matrix&quot; representation \( h[f(u) - \frac{h}{6}D_xD_x f(u)]_i \)
   if computed by a group finite element method,</li>
 <li> \( au \) leads to the &quot;mass matrix&quot; form \( ah[u - \frac{h}{6}D_xD_x u]_i \).</li>
</ul>
</div>


<p>
As we now have explicit expressions for the nonlinear difference
equations also in the finite element method, a Picard or Newton method
can be defined as shown for the finite difference method.  However,
our efforts in deriving symbolic forms of the difference equations in
the finite element method was motivated by a desire to see how
nonlinear terms in differential equations make the finite element and
difference method different. For practical calculations in computer
programs we apply numerical integration, normally the more accurate
Gauss-Legendre quadrature rules, to the integrals directly. This
allows us to easily <em>evaluate</em> the nonlinear algebraic equations for a
given numerical approximation of \( u \) (here denoted \( u^{-} \)).  To
<em>solve</em> the nonlinear algebraic equations we need to apply the Picard
iteration method or Newton's method to the variational form directly,
as shown next.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">

  <li class="previous">
    <a href="._fem-book-sol032.html">&larr; Prev</a>
  </li>

  <li class="next">
    <a href="._fem-book-sol034.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

