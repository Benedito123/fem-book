<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,polynomial chaos,Chaospy software,intrusive polynomial chaos,non-intrusive polynomial chaos,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, u'ch:preface', u'ch:preface'),
              (u'Contents', 3, None, '___sec1'),
              (u'Supplementary materials', 3, None, '___sec2'),
              (u'Quick overview of the finite element method',
               0,
               u'ch:overview',
               u'ch:overview'),
              (u'Function approximation by global functions',
               0,
               u'ch:approx:global',
               u'ch:approx:global'),
              (u'Approximation of vectors',
               1,
               u'fem:approx:vec',
               u'fem:approx:vec'),
              (u'Approximation of planar vectors',
               2,
               u'fem:approx:vec:plane',
               u'fem:approx:vec:plane'),
              (u'The least squares method', 3, None, '___sec7'),
              (u'The projection method', 3, None, '___sec8'),
              (u'Approximation of general vectors',
               2,
               u'fem:approx:vec:Np1dim',
               u'fem:approx:vec:Np1dim'),
              (u'The least squares method', 3, None, '___sec10'),
              (u'The Galerkin or projection method', 3, None, '___sec11'),
              (u'Approximation principles',
               1,
               u'fem:approx:global',
               u'fem:approx:global'),
              (u'The least squares method',
               2,
               u'fem:approx:LS',
               u'fem:approx:LS'),
              (u'The projection (or Galerkin) method', 2, None, '___sec14'),
              (u'Example on linear approximation',
               2,
               u'fem:approx:global:linear',
               u'fem:approx:global:linear'),
              (u'Implementation of the least squares method',
               2,
               u'fem:approx:global:LS:code',
               u'fem:approx:global:LS:code'),
              (u'Symbolic integration', 3, None, '___sec17'),
              (u'Fall back on numerical integration', 3, None, '___sec18'),
              (u'Plotting the approximation', 3, None, '___sec19'),
              (u'Perfect approximation',
               2,
               u'fem:approx:global:exact1',
               u'fem:approx:global:exact1'),
              (u'The regression method',
               2,
               u'fem:approx:global:regression',
               u'fem:approx:global:regression'),
              (u'Overdetermined equation system', 3, None, '___sec22'),
              (u'The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              (u'Implementation', 3, None, '___sec24'),
              (u'Example', 3, None, '___sec25'),
              (u'Orthogonal basis functions', 1, None, '___sec26'),
              (u'Ill-conditioning',
               2,
               u'fem:approx:global:illconditioning',
               u'fem:approx:global:illconditioning'),
              (u'Fourier series',
               2,
               u'fem:approx:global:Fourier',
               u'fem:approx:global:Fourier'),
              (u'Orthogonal basis functions',
               2,
               u'fem:approx:global:orth',
               u'fem:approx:global:orth'),
              (u'Numerical computations', 2, None, '___sec30'),
              (u'Interpolation', 1, None, '___sec31'),
              (u'The interpolation (or collocation) principle',
               2,
               u'fem:approx:global:interp',
               u'fem:approx:global:interp'),
              (u'Example', 3, None, '___sec33'),
              (u'Lagrange polynomials',
               2,
               u'fem:approx:global:Lagrange',
               u'fem:approx:global:Lagrange'),
              (u'Approximation of a polynomial', 3, None, '___sec35'),
              (u'Successful example', 3, None, '___sec36'),
              (u'Less successful example', 3, None, '___sec37'),
              (u'Remedy for strong oscillations', 3, None, '___sec38'),
              (u'Bernstein polynomials',
               2,
               u'fem:approx:global:Bernstein',
               u'fem:approx:global:Bernstein'),
              (u'Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              (u'Approximation of functions in higher dimensions',
               1,
               u'fem:approx:2D',
               u'fem:approx:2D'),
              (u'2D basis functions as tensor products of 1D functions',
               2,
               u'fem:approx:2D:global',
               u'fem:approx:2D:global'),
              (u'Example on polynomial basis in 2D', 2, None, '___sec43'),
              (u'Implementation',
               2,
               u'fem:approx:2D:global:code',
               u'fem:approx:2D:global:code'),
              (u'Extension to 3D',
               2,
               u'fem:approx:3D:global',
               u'fem:approx:3D:global'),
              (u'Exercises', 1, None, '___sec46'),
              (u'Problem 1: Linear algebra refresher',
               2,
               u'fem:approx:exer:linalg1',
               u'fem:approx:exer:linalg1'),
              (u'Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               u'fem:approx:exer:vec:3Dby2D',
               u'fem:approx:exer:vec:3Dby2D'),
              (u'Problem 3: Approximate a parabola by a sine',
               2,
               u'fem:approx:exer:parabola_sine',
               u'fem:approx:exer:parabola_sine'),
              (u'Problem 4: Approximate the exponential function by power functions',
               2,
               u'fem:approx:exer:exp:powers',
               u'fem:approx:exer:exp:powers'),
              (u'Problem 5: Approximate the sine function by power functions',
               2,
               u'fem:approx:exer:sin:powers',
               u'fem:approx:exer:sin:powers'),
              (u'Problem 6: Approximate a steep function by sines',
               2,
               u'fem:approx:exer:tanh:sine1',
               u'fem:approx:exer:tanh:sine1'),
              (u'Remarks', 3, None, '___sec53'),
              (u'Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               u'fem:approx:exer:tanh:sine3',
               u'fem:approx:exer:tanh:sine3'),
              (u'Remarks', 3, None, '___sec55'),
              (u'Exercise 8: Fourier series as a least squares approximation',
               2,
               u'fem:approx:exer:Fourier',
               u'fem:approx:exer:Fourier'),
              (u'Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               u'fem:approx:exer:tanh:Lagrange',
               u'fem:approx:exer:tanh:Lagrange'),
              (u'Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               u'fem:approx:exer:tanh:Lagrange:regression',
               u'fem:approx:exer:tanh:Lagrange:regression'),
              (u'Function approximation by finite elements',
               0,
               u'ch:approx:fe',
               u'ch:approx:fe'),
              (u'Finite element basis functions',
               1,
               u'fem:approx:fe',
               u'fem:approx:fe'),
              (u'Elements and nodes',
               2,
               u'fem:approx:fe:def:elements:nodes',
               u'fem:approx:fe:def:elements:nodes'),
              (u'Example', 3, None, '___sec62'),
              (u'The basis functions', 2, None, '___sec63'),
              (u'Construction principles', 3, None, '___sec64'),
              (u'Properties of $\\basphi_i$', 3, None, '___sec65'),
              (u'Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              (u'Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              (u'Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              (u'Calculating the linear system',
               2,
               u'fem:approx:global:linearsystem',
               u'fem:approx:global:linearsystem'),
              (u'Calculating specific matrix entries', 3, None, '___sec70'),
              (u'Calculating a general row in the matrix',
               3,
               None,
               '___sec71'),
              (u'Assembly of elementwise computations',
               2,
               u'fem:approx:fe:elementwise',
               u'fem:approx:fe:elementwise'),
              (u'The element matrix', 3, None, '___sec73'),
              (u'Assembly of element matrices', 3, None, '___sec74'),
              (u'Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              (u'The element vector', 3, None, '___sec76'),
              (u'Mapping to a reference element',
               2,
               u'fem:approx:fe:mapping',
               u'fem:approx:fe:mapping'),
              (u'The coordinate transformation', 3, None, '___sec78'),
              (u'Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              (u'Formulas for local basis functions', 3, None, '___sec80'),
              (u'Example on integration over a reference element',
               2,
               u'fem:approx:fe:intg:ref',
               u'fem:approx:fe:intg:ref'),
              (u'Implementation',
               1,
               u'fem:approx:fe:impl',
               u'fem:approx:fe:impl'),
              (u'Integration',
               2,
               u'fem:approx:fe:impl:intg',
               u'fem:approx:fe:impl:intg'),
              (u'Linear system assembly and solution',
               2,
               u'fem:approx:fe:impl:linsys',
               u'fem:approx:fe:impl:linsys'),
              (u'Example on computing symbolic approximations',
               2,
               u'fem:approx:fe:impl:ex1:symbolic',
               u'fem:approx:fe:impl:ex1:symbolic'),
              (u'Using interpolation instead of least squares',
               2,
               u'fem:approx:fe:impl:ex1:collocation',
               u'fem:approx:fe:impl:ex1:collocation'),
              (u'Example on computing numerical approximations',
               2,
               u'fem:approx:fe:impl:ex1:numeric',
               u'fem:approx:fe:impl:ex1:numeric'),
              (u'The structure of the coefficient matrix',
               2,
               u'fem:approx:fe:A:structure',
               u'fem:approx:fe:A:structure'),
              (u'Applications',
               2,
               u'fem:approx:fe:impl:ex2',
               u'fem:approx:fe:impl:ex2'),
              (u'Sparse matrix storage and solution',
               2,
               u'fem:approx:fe:impl:sparse',
               u'fem:approx:fe:impl:sparse'),
              (u'Comparison of finite elements and finite differences',
               1,
               u'fem:approx:fe:fd',
               u'fem:approx:fe:fd'),
              (u'Finite difference approximation of given functions',
               2,
               u'fem:approx:fe:fd:fdproj',
               u'fem:approx:fe:fd:fdproj'),
              (u'Interpretation of a finite element approximation in terms of finite difference operators',
               2,
               u'fem:approx:fe:fd:feproj',
               u'fem:approx:fe:fd:feproj'),
              (u'Making finite elements behave as finite differences',
               2,
               u'fem:deq:1D:approx:fem_vs_fdm',
               u'fem:deq:1D:approx:fem_vs_fdm'),
              (u'Computations in physical space', 3, None, '___sec95'),
              (u'Elementwise computations', 3, None, '___sec96'),
              (u'Terminology', 3, None, '___sec97'),
              (u'A generalized element concept',
               1,
               u'fem:approx:fe:element',
               u'fem:approx:fe:element'),
              (u'Cells, vertices, and degrees of freedom',
               2,
               u'fem:approx:fe:element:terminology',
               u'fem:approx:fe:element:terminology'),
              (u'Extended finite element concept',
               2,
               u'fem:approx:fe:element:def',
               u'fem:approx:fe:element:def'),
              (u'Implementation',
               2,
               u'fem:approx:fe:element:impl',
               u'fem:approx:fe:element:impl'),
              (u'Computing the error of the approximation',
               2,
               u'fem:approx:fe:error',
               u'fem:approx:fe:error'),
              (u'Example on cubic Hermite polynomials',
               2,
               u'fem:approx:fe:element:impl:Hermite',
               u'fem:approx:fe:element:impl:Hermite'),
              (u'Numerical integration', 1, None, '___sec104'),
              (u'Newton-Cotes rules',
               2,
               u'fem:approx:fe:numint1',
               u'fem:approx:fe:numint1'),
              (u'Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              (u'Finite elements in 2D and 3D', 1, None, '___sec107'),
              (u'Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              (u'Element matrices and vectors', 3, None, '___sec109'),
              (u'Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              (u'Affine mapping of the reference cell', 2, None, '___sec111'),
              (u'Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              (u'Computing integrals', 2, None, '___sec113'),
              (u'Implementation',
               1,
               u'fe:approx:fenics',
               u'fe:approx:fenics'),
              (u'Example on approximation in 2D using FEniCS',
               2,
               u'fem:approx:fenics:2D',
               u'fem:approx:fenics:2D'),
              (u'Mathematical problem', 3, None, '___sec116'),
              (u'The code', 3, None, '___sec117'),
              (u'Dissection of the code', 3, None, '___sec118'),
              (u'Integrating SymPy and FEniCS', 3, None, '___sec119'),
              (u'Refined code with curve plotting',
               2,
               u'fem:approx:fenics:2D:2',
               u'fem:approx:fenics:2D:2'),
              (u'Interpolation and projection', 3, None, '___sec121'),
              (u'Plotting the solution along a line', 3, None, '___sec122'),
              (u'Integrating plotting and computations',
               3,
               None,
               '___sec123'),
              (u'Exercises', 1, None, '___sec124'),
              (u'Problem 11: Define nodes and elements',
               2,
               u'fem:approx:fe:exer:mesh1',
               u'fem:approx:fe:exer:mesh1'),
              (u'Problem 12: Define vertices, cells, and dof maps',
               2,
               u'fem:approx:fe:exer:mesh2',
               u'fem:approx:fe:exer:mesh2'),
              (u'Problem 13: Construct matrix sparsity patterns',
               2,
               u'fem:approx:fe:exer:defmesh:sparsity',
               u'fem:approx:fe:exer:defmesh:sparsity'),
              (u'Problem 14: Perform symbolic finite element computations',
               2,
               u'fem:approx:fe:exer:Asinwt:symbolic',
               u'fem:approx:fe:exer:Asinwt:symbolic'),
              (u'Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               u'fem:approx:exer:tanh:P1P2',
               u'fem:approx:exer:tanh:P1P2'),
              (u'Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               u'fem:approx:exer:tanh:P3P4',
               u'fem:approx:exer:tanh:P3P4'),
              (u'Exercise 17: Investigate the approximation error in finite elements',
               2,
               u'fem:approx:fe:exer:Asinwt:interpol:error',
               u'fem:approx:fe:exer:Asinwt:interpol:error'),
              (u'Problem 18: Approximate a step function by finite elements',
               2,
               u'fem:approx:fe:exer:Heaviside',
               u'fem:approx:fe:exer:Heaviside'),
              (u'Exercise 19: 2D approximation with orthogonal functions',
               2,
               u'fem:approx:fe:exer:2Dsines:symbolic',
               u'fem:approx:fe:exer:2Dsines:symbolic'),
              (u'Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               u'fem:approx:fe:exer:1D:trapez',
               u'fem:approx:fe:exer:1D:trapez'),
              (u'Exercise 21: Compare P1 elements and interpolation',
               2,
               u'fem:approx:fe:exer:1D:P1:vs:interp',
               u'fem:approx:fe:exer:1D:P1:vs:interp'),
              (u'Exercise 22: Implement 3D computations with global basis functions',
               2,
               u'fem:approx:fe:exer:3D:approx3D',
               u'fem:approx:fe:exer:3D:approx3D'),
              (u"Exercise 23: Use Simpson's rule and P2 elements",
               2,
               u'fem:approx:fe:exer:1D:simpson',
               u'fem:approx:fe:exer:1D:simpson'),
              (u'Exercise 24: Make a 3D code for Lagrange elements of arbitrary order',
               2,
               None,
               '___sec138'),
              (u'Variational formulations with global basis functions',
               0,
               u'ch:varform:global',
               u'ch:varform:global'),
              (u'Basic principles for approximating differential equations',
               1,
               u'fem:deq:1D:principles',
               u'fem:deq:1D:principles'),
              (u'Differential equation models',
               2,
               u'fem:deq:1D:models',
               u'fem:deq:1D:models'),
              (u'Simple model problems and their solutions',
               2,
               u'fem:deq:1D:models:simple',
               u'fem:deq:1D:models:simple'),
              (u'Forming the residual',
               2,
               u'fem:deq:1D:residual:min',
               u'fem:deq:1D:residual:min'),
              (u'The least squares method', 2, None, '___sec144'),
              (u'The Galerkin method', 2, None, '___sec145'),
              (u'The method of weighted residuals', 2, None, '___sec146'),
              (u'Test and trial functions', 2, None, '___sec147'),
              (u'The collocation method', 2, None, '___sec148'),
              (u'The subdomain collocation method', 3, None, '___sec149'),
              (u'Examples on using the principles',
               2,
               u'fem:deq:1D:ex:sines',
               u'fem:deq:1D:ex:sines'),
              (u'The model problem', 3, None, '___sec151'),
              (u'Basis functions', 3, None, '___sec152'),
              (u'The residual', 3, None, '___sec153'),
              (u'The least squares method', 3, None, '___sec154'),
              (u'The Galerkin method', 3, None, '___sec155'),
              (u'The collocation method', 3, None, '___sec156'),
              (u'Comparison', 3, None, '___sec157'),
              (u'Integration by parts',
               2,
               u'fem:deq:1D:varform',
               u'fem:deq:1D:varform'),
              (u'Weak form', 3, None, '___sec159'),
              (u'Boundary function',
               2,
               u'fem:deq:1D:essBC:Bfunc',
               u'fem:deq:1D:essBC:Bfunc'),
              (u'Computing with global polynomials', 1, None, '___sec161'),
              (u'Computing with Dirichlet and Neumann conditions',
               2,
               u'fem:deq:1D:varform:ex:DN:case',
               u'fem:deq:1D:varform:ex:DN:case'),
              (u'When the numerical method is exact', 2, None, '___sec163'),
              (u'Abstract notation for variational formulations',
               2,
               u'fem:deq:1D:varform:abstract',
               u'fem:deq:1D:varform:abstract'),
              (u'Variational problems and minimization of functionals',
               2,
               u'fem:deq:1D:optimization',
               u'fem:deq:1D:optimization'),
              (u'Example', 3, None, '___sec166'),
              (u'The general minimization problem', 3, None, '___sec167'),
              (u'Derivation', 3, None, '___sec168'),
              (u'Minimization of the discretized functional',
               3,
               None,
               '___sec169'),
              (u'Calculus of variations', 3, None, '___sec170'),
              (u'Examples on variational formulations',
               1,
               u'fem:deq:1D:varform:ex',
               u'fem:deq:1D:varform:ex'),
              (u'Variable coefficient', 2, None, '___sec172'),
              (u'First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec173'),
              (u'Nonlinear coefficient', 2, None, '___sec174'),
              (u'Implementation of the algorithms',
               1,
               u'fem:global:deq:1D:code',
               u'fem:global:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:global',
               u'fem:deq:1D:code:global'),
              (u'Fallback on numerical methods', 2, None, '___sec177'),
              (u'Example with constant right-hand side',
               2,
               None,
               '___sec178'),
              (u'Approximations may fail: convection-diffusion',
               1,
               u'ch:convdiff',
               u'ch:convdiff'),
              (u'Exercises', 1, None, '___sec180'),
              (u'Exercise 25: Refactor functions into a more general class',
               2,
               u'fem:deq:exer:BVP1D:class',
               u'fem:deq:exer:BVP1D:class'),
              (u'Exercise 26: Compute the deflection of a cable with sine functions',
               2,
               u'fem:deq:exer:tension:cable',
               u'fem:deq:exer:tension:cable'),
              (u'Exercise 27: Compute the deflection of a cable with power functions',
               2,
               u'fem:deq:exer:tension:cable_xn',
               u'fem:deq:exer:tension:cable_xn'),
              (u'Exercise 28: Check integration by parts',
               2,
               u'fem:deq:exer:intg:parts',
               u'fem:deq:exer:intg:parts'),
              (u'Variational formulations with finite elements',
               0,
               u'ch:varform:fe',
               u'ch:varform:fe'),
              (u'Computing with finite elements',
               1,
               u'fem:deq:1D:fem1',
               u'fem:deq:1D:fem1'),
              (u'Finite element mesh and basis functions',
               2,
               None,
               '___sec187'),
              (u'Computation in the global physical domain',
               2,
               u'fem:deq:1D:comp:global',
               u'fem:deq:1D:comp:global'),
              (u'Comparison with a finite difference discretization',
               2,
               u'fem:deq:1D:fdm_vs_fem',
               u'fem:deq:1D:fdm_vs_fem'),
              (u'Cellwise computations',
               2,
               u'fem:deq:1D:comp:elmwise',
               u'fem:deq:1D:comp:elmwise'),
              (u'The integral for the element matrix', 3, None, '___sec191'),
              (u'The integral for the element vector', 3, None, '___sec192'),
              (u'Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec193'),
              (u'Contributions from the first and last cell',
               3,
               None,
               '___sec194'),
              (u'Assembly', 3, None, '___sec195'),
              (u'Boundary conditions: specified nonzero value',
               1,
               u'fem:deq:1D:essBC',
               u'fem:deq:1D:essBC'),
              (u'General construction of a boundary function',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc',
               u'fem:deq:1D:fem:essBC:Bfunc'),
              (u'Example on computing with a finite element-based boundary function',
               2,
               None,
               '___sec198'),
              (u'Computations in physical coordinates', 3, None, '___sec199'),
              (u'Cellwise computations on the reference element',
               3,
               None,
               '___sec200'),
              (u'Modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (u'Computations in the physical system', 3, None, '___sec202'),
              (u'Symmetric modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (u'Modification of the element matrix and vector',
               2,
               None,
               '___sec204'),
              (u'Boundary conditions: specified derivative',
               1,
               u'fem:deq:1D:BC:nat',
               u'fem:deq:1D:BC:nat'),
              (u'The variational formulation', 2, None, '___sec206'),
              (u'Boundary term vanishes because of the test functions',
               2,
               u'fem:deq:1D:BC:nat:uLtest',
               u'fem:deq:1D:BC:nat:uLtest'),
              (u'Boundary term vanishes because of linear system modifications',
               2,
               u'fem:deq:1D:BC:nat:uLmod',
               u'fem:deq:1D:BC:nat:uLmod'),
              (u'Direct computation of the global linear system',
               2,
               u'fem:deq:1D:BC:nat:Aub',
               u'fem:deq:1D:BC:nat:Aub'),
              (u'Cellwise computations', 2, None, '___sec210'),
              (u'Implementation of finite element algorithms',
               1,
               u'fem:deq:1D:code',
               u'fem:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:fe',
               u'fem:deq:1D:code:fe'),
              (u'Utilizing a sparse matrix',
               2,
               u'fem:deq:1D:code:fe_sparse',
               u'fem:deq:1D:code:fe_sparse'),
              (u'Application to our model problem', 2, None, '___sec214'),
              (u'Variational formulations in 2D and 3D',
               1,
               u'fem:deq:2D:varform',
               u'fem:deq:2D:varform'),
              (u'Integration by parts', 2, None, '___sec216'),
              (u'Example on a multi-dimensional variational problem',
               2,
               u'sec:varform:general:convdiff',
               u'sec:varform:general:convdiff'),
              (u'Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec218'),
              (u'Numerical integration', 2, None, '___sec219'),
              (u'Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec220'),
              (u'A glimpse of the mathematical theory of the finite element method',
               2,
               None,
               '___sec221'),
              (u'Abstract variational forms', 3, None, '___sec222'),
              (u'Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec223'),
              (u'Assumptions', 3, None, '___sec224'),
              (u'Existence and uniqueness', 3, None, '___sec225'),
              (u'Stability', 3, None, '___sec226'),
              (u'Equivalent minimization problem', 3, None, '___sec227'),
              (u'Best approximation principle', 3, None, '___sec228'),
              (u'Best approximation property in the norm of the space',
               3,
               None,
               '___sec229'),
              (u'Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec230'),
              (u'Equivalent matrix minimization problem',
               3,
               None,
               '___sec231'),
              (u'A priori error estimate for the derivative',
               3,
               None,
               '___sec232'),
              (u'A priori error estimate for the solution',
               3,
               None,
               '___sec233'),
              (u'Implementation in 2D and 3D via FEniCS',
               1,
               u'fem:varform:fenics',
               u'fem:varform:fenics'),
              (u'Mathematical problem',
               2,
               u'fem:varform:fenics:problem',
               u'fem:varform:fenics:problem'),
              (u'Symmetry', 3, None, '___sec236'),
              (u'Variational formulation',
               2,
               u'fem:varform:fenics:varform',
               u'fem:varform:fenics:varform'),
              (u'The FEniCS solver', 2, None, '___sec238'),
              (u'Making the mesh', 2, None, '___sec239'),
              (u'Solving a problem', 2, None, '___sec240'),
              (u'Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec241'),
              (u'Summary', 1, None, '___sec242'),
              (u'Exercises', 1, None, '___sec243'),
              (u'Exercise 29: Compute the deflection of a cable with 2 P1 elements',
               2,
               u'fem:deq:exer:cable:2P1',
               u'fem:deq:exer:cable:2P1'),
              (u'Exercise 30: Compute the deflection of a cable with 1 P2 element',
               2,
               u'fem:deq:exer:cable:1P2',
               u'fem:deq:exer:cable:1P2'),
              (u'Exercise 31: Compute the deflection of a cable with a step load',
               2,
               u'fem:deq:exer:cable:stepload',
               u'fem:deq:exer:cable:stepload'),
              (u'Exercise 32: Compute with a non-uniform mesh',
               2,
               u'fem:deq:exer:1D:mesh:nonuniform',
               u'fem:deq:exer:1D:mesh:nonuniform'),
              (u'Problem 33: Solve a 1D finite element problem by hand',
               2,
               u'fem:deq:exer:1D:gen:problem1',
               u'fem:deq:exer:1D:gen:problem1'),
              (u'Exercise 34: Investigate exact finite element solutions',
               2,
               u'fem:deq:exer:1D:exact_numerics',
               u'fem:deq:exer:1D:exact_numerics'),
              (u'Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               u'fem:deq:exer:1D:Poisson:polar',
               u'fem:deq:exer:1D:Poisson:polar'),
              (u'Exercise 36: Compute with variable coefficients and P1 elements by hand',
               2,
               u'fem:deq:exer:1D:gen:problem2',
               u'fem:deq:exer:1D:gen:problem2'),
              (u'Exercise 37: Solve a 2D Poisson equation using polynomials and sines',
               2,
               u'fem:deq:exer:2D:torsion:xy:sin',
               u'fem:deq:exer:2D:torsion:xy:sin'),
              (u'Time-dependent variational forms',
               0,
               u'ch:femtime',
               u'ch:femtime'),
              (u'Discretization in time by a Forward Euler scheme',
               1,
               u'fem:deq:diffu:FE',
               u'fem:deq:diffu:FE'),
              (u'Time discretization', 2, None, '___sec255'),
              (u'Space discretization', 2, None, '___sec256'),
              (u'Variational forms', 2, None, '___sec257'),
              (u'Notation for the solution at recent time levels',
               2,
               None,
               '___sec258'),
              (u'Deriving the linear systems', 2, None, '___sec259'),
              (u'Computational algorithm', 2, None, '___sec260'),
              (u'Example using sinusoidal basis functions',
               2,
               u'fem:deq:diffu:FE:cosex',
               u'fem:deq:diffu:FE:cosex'),
              (u'Comparing P1 elements with the finite difference method',
               2,
               u'fem:deq:diffu:FE:fdvsP1fe',
               u'fem:deq:diffu:FE:fdvsP1fe'),
              (u'Lumping the mass matrix', 3, None, '___sec263'),
              (u'Discretization in time by a Backward Euler scheme',
               1,
               u'fem:deq:diffu:BE',
               u'fem:deq:diffu:BE'),
              (u'Time discretization', 2, None, '___sec265'),
              (u'Variational forms', 2, None, '___sec266'),
              (u'Linear systems', 2, None, '___sec267'),
              (u'Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec268'),
              (u'Dirichlet boundary conditions',
               1,
               u'fem:deq:diffu:Dirichlet',
               u'fem:deq:diffu:Dirichlet'),
              (u'Boundary function', 2, None, '___sec270'),
              (u'Finite element basis functions', 2, None, '___sec271'),
              (u'Modification of the linear system', 2, None, '___sec272'),
              (u'Example: Oscillating Dirichlet boundary condition',
               2,
               u'fem:deq:diffu:Dirichlet:ex',
               u'fem:deq:diffu:Dirichlet:ex'),
              (u'Accuracy of the finite element solution',
               1,
               u'fem:deq:diffu:anal',
               u'fem:deq:diffu:anal'),
              (u'Illustrating example', 2, None, '___sec275'),
              (u'Methods of analysis', 2, None, '___sec276'),
              (u'Fourier components and dispersion relations',
               2,
               None,
               '___sec277'),
              (u'Forward Euler discretization', 2, None, '___sec278'),
              (u'Backward Euler discretization', 2, None, '___sec279'),
              (u'Comparing amplification factors', 2, None, '___sec280'),
              (u'Exercises', 1, None, '___sec281'),
              (u'Exercise 38: Analyze a Crank-Nicolson scheme for the diffusion equation',
               2,
               u'fem:deq:exer:diffu:analysis:CN',
               u'fem:deq:exer:diffu:analysis:CN'),
              (u'Variational forms for systems of PDEs',
               0,
               u'ch:femsys',
               u'ch:femsys'),
              (u'Variational forms', 1, u'fem:sys:vform', u'fem:sys:vform'),
              (u'Sequence of scalar PDEs formulation', 2, None, '___sec285'),
              (u'Vector PDE formulation', 2, None, '___sec286'),
              (u'A worked example', 1, u'fem:sys:uT:ex', u'fem:sys:uT:ex'),
              (u'Identical function spaces for the unknowns',
               1,
               None,
               '___sec288'),
              (u'Variational form of each individual PDE',
               2,
               None,
               '___sec289'),
              (u'Compound scalar variational form', 2, None, '___sec290'),
              (u'Decoupled linear systems', 2, None, '___sec291'),
              (u'Coupled linear systems', 2, None, '___sec292'),
              (u'Different function spaces for the unknowns',
               1,
               None,
               '___sec293'),
              (u'Computations in 1D',
               1,
               u'femsys:cooling:1D',
               u'femsys:cooling:1D'),
              (u'Another example in 1D',
               2,
               u'fem:sys:up:1D',
               u'fem:sys:up:1D'),
              (u'Exercises', 1, None, '___sec296'),
              (u'Problem 39: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:1',
               u'femsys:exer:cooling:1'),
              (u'Problem 40: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:2',
               u'femsys:exer:cooling:2'),
              (u'Flexible implementations of boundary conditions',
               0,
               u'ch:nitsche',
               u'ch:nitsche'),
              (u'Optimization with constraint',
               1,
               u'nitsche:fxy:opt',
               u'nitsche:fxy:opt'),
              (u'Elimination of variables', 2, None, '___sec301'),
              (u'Lagrange multiplier method',
               2,
               u'nitsche:fxy:opt:Lagrange',
               u'nitsche:fxy:opt:Lagrange'),
              (u'Penalty method',
               2,
               u'nitsche:fxy:opt:penalty',
               u'nitsche:fxy:opt:penalty'),
              (u'Optimization of functionals',
               1,
               u'nitsche:pde:opt',
               u'nitsche:pde:opt'),
              (u'Classical calculus of variations',
               2,
               u'nitsche:pde:opt:varcalculus',
               u'nitsche:pde:opt:varcalculus'),
              (u'Penalty method for optimization with constraints',
               2,
               u'nitsche:pde:opt:penalty',
               u'nitsche:pde:opt:penalty'),
              (u'Lagrange multiplier method for optimization with constraints',
               2,
               u'nitsche:pde:opt:Lagrange',
               u'nitsche:pde:opt:Lagrange'),
              (u'Example: 1D problem',
               2,
               u'nitsche:pde:opt:1Dex',
               u'nitsche:pde:opt:1Dex'),
              (u'Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec309'),
              (u'Nonlinear problems', 0, u'ch:nonlin', u'ch:nonlin'),
              (u'Introduction of basic concepts',
               1,
               u'nonlin:timediscrete:logistic',
               u'nonlin:timediscrete:logistic'),
              (u'Linear versus nonlinear equations', 2, None, '___sec312'),
              (u'Algebraic equations', 3, None, '___sec313'),
              (u'Differential equations', 3, None, '___sec314'),
              (u'A simple model problem', 2, None, '___sec315'),
              (u'Linearization by explicit time discretization',
               2,
               u'nonlin:timediscrete:logistic:FE',
               u'nonlin:timediscrete:logistic:FE'),
              (u'Exact solution of nonlinear algebraic equations',
               2,
               u'nonlin:timediscrete:logistic:roots',
               u'nonlin:timediscrete:logistic:roots'),
              (u'Linearization', 2, None, '___sec318'),
              (u'Picard iteration',
               2,
               u'nonlin:timediscrete:logistic:Picard',
               u'nonlin:timediscrete:logistic:Picard'),
              (u'Stopping criteria', 3, None, '___sec320'),
              (u'A single Picard iteration', 3, None, '___sec321'),
              (u'Linearization by a geometric mean',
               2,
               u'nonlin:timediscrete:logistic:geometric:mean',
               u'nonlin:timediscrete:logistic:geometric:mean'),
              (u"Newton's method",
               2,
               u'nonlin:timediscrete:logistic:Newton',
               u'nonlin:timediscrete:logistic:Newton'),
              (u'Relaxation',
               2,
               u'nonlin:timediscrete:logistic:relaxation',
               u'nonlin:timediscrete:logistic:relaxation'),
              (u'Implementation and experiments',
               2,
               u'nonlin:timediscrete:logistic:impl',
               u'nonlin:timediscrete:logistic:impl'),
              (u'Generalization to a general nonlinear ODE',
               2,
               u'nonlin:ode:generic',
               u'nonlin:ode:generic'),
              (u'Explicit time discretization', 3, None, '___sec327'),
              (u'Backward Euler discretization', 3, None, '___sec328'),
              (u'Crank-Nicolson discretization', 3, None, '___sec329'),
              (u'Systems of ODEs',
               2,
               u'nonlin:ode:generic:sys:pendulum',
               u'nonlin:ode:generic:sys:pendulum'),
              (u'Example', 3, None, '___sec331'),
              (u'Systems of nonlinear algebraic equations',
               1,
               u'nonlin:systems:alg',
               u'nonlin:systems:alg'),
              (u'Picard iteration',
               2,
               u'nonlin:systems:alg:Picard',
               u'nonlin:systems:alg:Picard'),
              (u"Newton's method",
               2,
               u'nonlin:systems:alg:Newton',
               u'nonlin:systems:alg:Newton'),
              (u'Stopping criteria',
               2,
               u'nonlin:systems:alg:terminate',
               u'nonlin:systems:alg:terminate'),
              (u'Example: A nonlinear ODE model from epidemiology',
               2,
               u'nonlin:systems:alg:SI',
               u'nonlin:systems:alg:SI'),
              (u'Implicit time discretization', 3, None, '___sec337'),
              (u'A Picard iteration', 3, None, '___sec338'),
              (u"Newton's method", 3, None, '___sec339'),
              (u'Linearization at the differential equation level',
               1,
               u'nonlin:pdelevel',
               u'nonlin:pdelevel'),
              (u'Explicit time integration',
               2,
               u'nonlin:pdelevel:explicit',
               u'nonlin:pdelevel:explicit'),
              (u'Backward Euler scheme and Picard iteration',
               2,
               u'nonlin:pdelevel:Picard',
               u'nonlin:pdelevel:Picard'),
              (u"Backward Euler scheme and Newton's method",
               2,
               u'nonlin:pdelevel:Newton',
               u'nonlin:pdelevel:Newton'),
              (u'Linearization via Taylor expansions', 3, None, '___sec344'),
              (u'Similarity with Picard iteration', 3, None, '___sec345'),
              (u'Implementation', 3, None, '___sec346'),
              (u'Derivation with alternative notation', 3, None, '___sec347'),
              (u'Crank-Nicolson discretization',
               2,
               u'nonlin:pdelevel:Picard:CN',
               u'nonlin:pdelevel:Picard:CN'),
              (u'1D stationary nonlinear differential equations',
               1,
               u'nonlin:alglevel:1D',
               u'nonlin:alglevel:1D'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:1D:fd',
               u'nonlin:alglevel:1D:fd'),
              (u'Solution of algebraic equations', 2, None, '___sec351'),
              (u'The structure of the equation system', 3, None, '___sec352'),
              (u'Picard iteration', 3, None, '___sec353'),
              (u'Mesh with two cells', 3, None, '___sec354'),
              (u"Newton's method", 3, None, '___sec355'),
              (u'Multi-dimensional PDE problems', 1, None, '___sec356'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:dD:fd',
               u'nonlin:alglevel:dD:fd'),
              (u'Picard iteration', 3, None, '___sec358'),
              (u"Newton's method", 3, None, '___sec359'),
              (u'Continuation methods', 2, None, '___sec360'),
              (u'Exercises', 1, u'nonlin:exer', u'nonlin:exer'),
              (u'Problem 41: Determine if equations are nonlinear or not',
               2,
               u'nonlin:exer:lin:vs:nonlin',
               u'nonlin:exer:lin:vs:nonlin'),
              (u'Exercise 42: Derive and investigate a generalized logistic model',
               2,
               u'nonlin:exer:logistic:gen',
               u'nonlin:exer:logistic:gen'),
              (u"Problem 43: Experience the behavior of Newton's method",
               2,
               u'nonlin:exer:Newton:problems1',
               u'nonlin:exer:Newton:problems1'),
              (u'Problem 44: Compute the Jacobian of a $2\\times 2$ system',
               2,
               u'nonlin:exer:vib:Jacobian',
               u'nonlin:exer:vib:Jacobian'),
              (u'Problem 45: Solve nonlinear equations arising from a vibration ODE',
               2,
               u'nonlin:exer:vib:geometric:mean',
               u'nonlin:exer:vib:geometric:mean'),
              (u'Exercise 46: Find the truncation error of arithmetic mean of products',
               2,
               u'nonlin:exer:products:arith:mean',
               u'nonlin:exer:products:arith:mean'),
              (u"Problem 47: Newton's method for linear problems",
               2,
               u'nonlin:exer:Newton:linear',
               u'nonlin:exer:Newton:linear'),
              (u'Exercise 48: Discretize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:fem',
               u'nonlin:exer:1D:1pu2:fem'),
              (u'Exercise 49: Linearize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:PicardNewton',
               u'nonlin:exer:1D:1pu2:PicardNewton'),
              (u'Problem 50: Finite differences for the 1D Bratu problem',
               2,
               u'nonlin:exer:1D:fu:discretize:fd',
               u'nonlin:exer:1D:fu:discretize:fd'),
              (u'Exercise 51: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               u'nonlin:exer:1D:heat:nonlinear:fdm',
               u'nonlin:exer:1D:heat:nonlinear:fdm'),
              (u'Exercise 52: Differentiate a highly nonlinear term',
               2,
               u'nonlin:exer:grad:pow:term',
               u'nonlin:exer:grad:pow:term'),
              (u'Exercise 53: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               u'nonlin:exer:2D:heat:nonlinear:fd',
               u'nonlin:exer:2D:heat:nonlinear:fd'),
              (u'Exercise 54: Find the sparsity of the Jacobian',
               2,
               u'nonlin:exer:sparsity:Jacobian',
               u'nonlin:exer:sparsity:Jacobian'),
              (u'Problem 55: Investigate a 1D problem with a continuation method',
               2,
               u'nonlin:exer:continuation:1DnNflow',
               u'nonlin:exer:continuation:1DnNflow'),
              (u'Symbolic nonlinear finite element equations',
               1,
               u'nonlin:app:fem_vs_fdm',
               u'nonlin:app:fem_vs_fdm'),
              (u'Finite element basis functions',
               2,
               u'nonlin:alglevel:1D:fe_basis',
               u'nonlin:alglevel:1D:fe_basis'),
              (u'The group finite element method',
               2,
               u'nonlin:alglevel:1D:fe:group',
               u'nonlin:alglevel:1D:fe:group'),
              (u'Finite element approximation of functions of $u$',
               3,
               None,
               '___sec380'),
              (u'Simplified problem', 3, None, '___sec381'),
              (u'Integrating nonlinear functions', 3, None, '___sec382'),
              (u'Application of the group finite element method',
               3,
               None,
               '___sec383'),
              (u'Numerical integration of nonlinear terms by hand',
               2,
               u'nonlin:alglevel:1D:fe:f',
               u'nonlin:alglevel:1D:fe:f'),
              (u'Discretization of a variable coefficient Laplace term',
               2,
               u'nonlin:alglevel:1D:fe:Laplace',
               u'nonlin:alglevel:1D:fe:Laplace'),
              (u'Group finite element method', 3, None, '___sec386'),
              (u'Numerical integration at the nodes', 3, None, '___sec387'),
              (u'Uncertainty quantification and polynomial chaos expansions',
               0,
               u'ch:pc',
               u'ch:pc'),
              (u'Sample problems', 1, None, '___sec389'),
              (u'ODE for decay processes', 2, None, '___sec390'),
              (u'The stochastic Poisson equation', 2, None, '___sec391'),
              (u'Basic principles', 1, None, '___sec392'),
              (u'Basic statistical results', 2, None, '___sec393'),
              (u'Least-squares methods', 2, None, '___sec394'),
              (u'Example: Least squares applied to the decay ODE',
               2,
               None,
               '___sec395'),
              (u'Modeling the response', 2, None, '___sec396'),
              (u'Numerical integration', 2, None, '___sec397'),
              (u'Stochastic collocation', 2, None, '___sec398'),
              (u'The Chaospy software', 1, u'pc:chaospy', u'pc:chaospy'),
              (u'Intrusive polynomial chaos methods',
               1,
               u'pc:intrusive',
               u'pc:intrusive'),
              (u'Variational methods for linear systems',
               0,
               u'ch:cg',
               u'ch:cg'),
              (u'Conjugate gradient-like iterative methods',
               1,
               u'ch:linalg:CGmethods',
               u'ch:linalg:CGmethods'),
              (u'The Galerkin method', 2, None, '___sec403'),
              (u'The least squares method', 2, None, '___sec404'),
              (u'Krylov subspaces', 2, None, '___sec405'),
              (u'Computation of the basis vectors', 2, None, '___sec406'),
              (u'Computation of a new solution vector', 2, None, '___sec407'),
              (u'Summary of the least squares method', 2, None, '___sec408'),
              (u'Remark', 3, None, '___sec409'),
              (u'Truncation and restart', 2, None, '___sec410'),
              (u'Summary of the Galerkin method', 2, None, '___sec411'),
              (u'A framework based on the error', 2, None, '___sec412'),
              (u'Preconditioning',
               1,
               u'ch:linalg2:preconditioning',
               u'ch:linalg2:preconditioning'),
              (u'Motivation and Basic Principles', 2, None, '___sec414'),
              (u'Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec415'),
              (u'Classical iterative methods as preconditioners',
               2,
               u'ch:linalg:SORprecond',
               u'ch:linalg:SORprecond'),
              (u'Incomplete factorization preconditioners',
               2,
               u'linalg:ILU',
               u'linalg:ILU'),
              (u'Appendix: Useful formulas',
               0,
               u'ch:formulas',
               u'ch:formulas'),
              (u'Finite difference operator notation',
               1,
               u'sec:form:fdop',
               u'sec:form:fdop'),
              (u'Truncation errors of finite difference approximations',
               1,
               u'sec:form:truncerr',
               u'sec:form:truncerr'),
              (u'Finite differences of exponential functions',
               1,
               u'sec:form:fdexp',
               u'sec:form:fdexp'),
              (u'Complex exponentials', 3, None, '___sec422'),
              (u'Real exponentials', 3, None, '___sec423'),
              (u'Finite differences of $t^n$',
               1,
               u'sec:form:fdtn',
               u'sec:form:fdtn'),
              (u'Software', 2, None, '___sec425'),
              (u'References', 1, None, '___sec426')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0005"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized004.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized006.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:approx:global">Approximation principles</h1>

<p>
Let \( V \) be a function space spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

$$
\begin{equation*} V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\},\end{equation*}
$$

such that any function \( u\in V \) can be written as a linear
combination of the basis functions:

$$
\begin{equation}
\tag{30}
u = \sum_{j\in\If} c_j\baspsi_j\tp
\end{equation}
$$

<p>
That is, we consider functions as vectors in a vector space &ndash; a
so-called function space &ndash; and we have a finite set of basis
functions that span the space just as basis vectors or unit vectors
span a vector space.

<p>
The index set \( \If \) is defined as \( \If =\{0,\ldots,N\} \) and is
from now on used
both for compact notation and for flexibility in the numbering of
elements in sequences.

<p>
For now, in this introduction, we shall look at functions of a
single variable \( x \):
\( u=u(x) \), \( \baspsi_j=\baspsi_j(x) \), \( j\in\If \). Later, we will almost
trivially extend the mathematical details
to functions of two- or three-dimensional physical spaces.
The approximation <a href="#mjx-eqn-30">(30)</a> is typically used
to discretize a problem in space. Other methods, most notably
finite differences, are common for time discretization, although the
form <a href="#mjx-eqn-30">(30)</a> can be used in time as well.

<h2 id="fem:approx:LS">The least squares method</h2>

<p>
Given a function \( f(x) \), how can we determine its best approximation
\( u(x)\in V \)? A natural starting point is to apply the same reasoning
as we did for vectors in the section <a href="._fem-book-solarized004.html#fem:approx:vec:Np1dim">Approximation of general vectors</a>. That is,
we minimize the distance between \( u \) and \( f \). However, this requires
a norm for measuring distances, and a norm is most conveniently
defined through an
inner product. Viewing a function as a vector of infinitely
many point values, one for each value of \( x \), the inner product of
two arbitrary functions \( f(x) \) and \( g(x) \) could
intuitively be defined as the usual summation of
pairwise &quot;components&quot; (values), with summation replaced by integration:

$$
\begin{equation*}
(f,g) = \int f(x)g(x)\, \dx
\tp
\end{equation*}
$$

To fix the integration domain, we let \( f(x) \) and \( \baspsi_i(x) \)
be defined for a domain \( \Omega\subset\Real \).
The inner product of two functions \( f(x) \) and \( g(x) \) is then

$$
\begin{equation}
(f,g) = \int_\Omega f(x)g(x)\, \dx
\tag{31}
\tp
\end{equation}
$$

<p>
The distance between \( f \) and any function \( u\in V \) is simply
\( f-u \), and the squared norm of this distance is

$$
\begin{equation}
E = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))\tp
\tag{32}
\end{equation}
$$

Note the analogy with <a href="._fem-book-solarized004.html#mjx-eqn-21">(21)</a>: the given function
\( f \) plays the role of the given vector \( \f \), and the basis function
\( \baspsi_i \) plays the role of the basis vector \( \psib_i \).
We can rewrite <a href="#mjx-eqn-32">(32)</a>,
through similar steps as used for the result
<a href="._fem-book-solarized004.html#mjx-eqn-21">(21)</a>, leading to

$$
\begin{equation}
E(c_i, \ldots, c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)\tp   \tag{33}
\end{equation}
$$

Minimizing this function of \( N+1 \) scalar variables
\( \sequencei{c} \), requires differentiation
with respect to \( c_i \), for all \( i\in\If \). The resulting
equations are very similar to those we had in the vector case,
and we hence end up with a
linear system of the form <a href="._fem-book-solarized004.html#mjx-eqn-25">(25)</a>, with
basically the same expressions:

$$
\begin{align}
A_{i,j} &= (\baspsi_i,\baspsi_j),
\tag{34}\\ 
b_i &= (f,\baspsi_i)\tp
\tag{35}
\end{align}
$$

<p>
The only difference from
<a href="._fem-book-solarized004.html#mjx-eqn-25">(25)</a>
is that the inner product is defined in terms
of integration rather than summation.

<h2 id="___sec14">The projection (or Galerkin) method </h2>

<p>
As in the section <a href="._fem-book-solarized004.html#fem:approx:vec:Np1dim">Approximation of general vectors</a>, the minimization of \( (e,e) \)
is equivalent to

$$
\begin{equation}
(e,v)=0,\quad\forall v\in V\tp
\tag{36}
\end{equation}
$$

This is known as a projection of a function \( f \) onto the subspace \( V \).
We may also call it a Galerkin method for approximating functions.
Using the same reasoning as
in
<a href="._fem-book-solarized004.html#mjx-eqn-28">(28)</a>-<a href="._fem-book-solarized004.html#mjx-eqn-29">(29)</a>,
it follows that <a href="#mjx-eqn-36">(36)</a> is equivalent to

$$
\begin{equation}
(e,\baspsi_i)=0,\quad i\in\If\tp
\tag{37}
\end{equation}
$$

Inserting \( e=f-u \) in this equation and ordering terms, as in the
multi-dimensional vector case, we end up with a linear
system with a coefficient matrix <a href="#mjx-eqn-34">(34)</a> and
right-hand side vector <a href="#mjx-eqn-35">(35)</a>.

<p>
Whether we work with vectors in the plane, general vectors, or
functions in function spaces, the least squares principle and
the projection or Galerkin method are equivalent.

<h2 id="fem:approx:global:linear">Example on linear approximation</h2>

<p>
Let us apply the theory in the previous section to a simple problem:
given a parabola \( f(x)=10(x-1)^2-1 \) for \( x\in\Omega=[1,2] \), find
the best approximation \( u(x) \) in the space of all linear functions:

$$
\begin{equation*} V = \hbox{span}\,\{1, x\}\tp  \end{equation*}
$$

With our notation, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

$$
\begin{equation*} u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x,\end{equation*}
$$

where
\( c_0 \) and \( c_1 \) are found by solving a \( 2\times 2 \) the linear system.
The coefficient matrix has elements

$$
\begin{align}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, \dx = 1,
\tag{38}\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, \dx = 3/2,
\tag{39}\\ 
A_{1,0} &= A_{0,1} = 3/2,
\tag{40}\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,\dx = 7/3\tp   \tag{41}
\end{align}
$$

The corresponding right-hand side is

$$
\begin{align}
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, \dx = 7/3,
\tag{42}\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, \dx = 13/3\tp   \tag{43}
\end{align}
$$

Solving the linear system results in

$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,
\tag{44}
\end{equation}
$$

and consequently

$$
\begin{equation}
u(x) = 10x - \frac{38}{3}\tp   \tag{45}
\end{equation}
$$

Figure <a href="#fem:approx:global:fig:parabola:linear">3</a> displays the
parabola and its best approximation in the space of all linear functions.

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:fig:parabola:linear"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Best approximation of a parabola by a straight line.   <!-- caption label: fem:approx:global:fig:parabola:linear --> </p></center>
<p><img src="fig/parabola_ls_linear.png" align="bottom" width=400></p>
</center>

<h2 id="fem:approx:global:LS:code">Implementation of the least squares method</h2>

<h3 id="___sec17">Symbolic integration </h3>

<p>
The linear system can be computed either symbolically or
numerically (a numerical integration rule is needed in the latter case).
Let us first compute the system and its solution symbolically, i.e.,
using classical &quot;pen and paper&quot; mathematics with symbols.
The Python package <code>sympy</code> can greatly help with this type of
mathematics, and will therefore be frequently used in this text.
Some basic familiarity with <code>sympy</code> is assumed, typically
<code>symbols</code>, <code>integrate</code>, <code>diff</code>, <code>expand</code>, and <code>simplify</code>. Much can be learned
by studying the many applications of <code>sympy</code> that will be presented.

<p>
Below is a function for symbolic computation of the linear system,
where \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> involving
the symbol <code>x</code>, <code>psi</code> is a list of expressions for \( \sequencei{\baspsi} \),
and <code>Omega</code> is a 2-tuple/list holding the limits of the domain \( \Omega \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sympy as sym

def least_squares(f, psi, Omega):
    N = len(psi) - 1
    A = sym.zeros((N+1, N+1))
    b = sym.zeros((N+1, 1))
    x = sym.Symbol('x')
    for i in range(N+1):
        for j in range(i, N+1):
            A[i,j] = sym.integrate(psi[i]*psi[j],
                                  (x, Omega[0], Omega[1]))
            A[j,i] = A[i,j]
        b[i,0] = sym.integrate(psi[i]*f, (x, Omega[0], Omega[1]))
    c = A.LUsolve(b)
    # Note: c is a sympy Matrix object, solution is in c[:,0]
    u = 0
    for i in range(len(psi)):
        u += c[i,0]*psi[i]
    return u, c
</code></pre>
<!-- end verbatim block -->

<p>
Observe that we exploit the symmetry of the coefficient matrix:
only the upper triangular part is computed. Symbolic integration, also in
<code>sympy</code>, is often time consuming, and (roughly) halving the
work has noticeable effect on the waiting time for the computations to
finish.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
We remark that the symbols in <code>sympy</code> are created and stored in
a symbol factory that is indexed by the expression used in the construction
and that repeated constructions from the same expression will not create
new objects. The following code illustrates the behavior of the
symbol factory:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; x0 = Symbol(&quot;x&quot;)
&gt;&gt;&gt; x1 = Symbol(&quot;x&quot;)
&gt;&gt;&gt; id(x0) ==id(x1)
True
&gt;&gt;&gt; a0 = 3.0
&gt;&gt;&gt; a1 = 3.0
&gt;&gt;&gt; id(a0) ==id(a1)
False
</code></pre>
<!-- end verbatim block -->
</div>


<h3 id="___sec18">Fall back on numerical integration </h3>

<p>
Obviously, <code>sympy</code> may fail to successfully integrate
\( \int_\Omega\baspsi_i\baspsi_j\dx \), and
especially \( \int_\Omega f\baspsi_i\dx \), symbolically.
Therefore, we should extend
the <code>least_squares</code> function such that it falls back on
numerical integration if the symbolic integration is unsuccessful.
In the latter case, the returned value from <code>sympy</code>'s
<code>integrate</code> function is an object of type <code>Integral</code>.
We can test on this type and utilize the <code>mpmath</code> module in
<code>sympy</code> to perform numerical integration of high precision.
Even when <code>sympy</code> manages to integrate symbolically, it can
take an undesirable long time. We therefore include an
argument <code>symbolic</code> that governs whether or not to try
symbolic integration. Here is a complete and
improved version of the previous function <code>least_squares</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def least_squares(f, psi, Omega, symbolic=True):
    N = len(psi) - 1
    A = sym.zeros((N+1, N+1))
    b = sym.zeros((N+1, 1))
    x = sym.Symbol('x')
    for i in range(N+1):
        for j in range(i, N+1):
            integrand = psi[i]*psi[j]
            if symbolic:
                I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
            if not symbolic or isinstance(I, sym.Integral):
                # Could not integrate symbolically,
                # fall back on numerical integration
                integrand = sym.lambdify([x], integrand)
                I = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
            A[i,j] = A[j,i] = I

        integrand = psi[i]*f
        if symbolic:
            I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
        if not symbolic or isinstance(I, sym.Integral):
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
        b[i,0] = I
    c = A.LUsolve(b)  # symbolic solve
    # c is a sympy Matrix object, numbers are in c[i,0]
    c = [sym.simplify(c[i,0]) for i in range(c.shape[0])]
    u = sum(c[i]*psi[i] for i in range(len(psi)))
    return u, c
</code></pre>
<!-- end verbatim block -->
The function is found in the file <code>approx1D.py</code>.

<h3 id="___sec19">Plotting the approximation </h3>

<p>
Comparing the given \( f(x) \) and the approximate \( u(x) \) visually is done
by the following function, which utilizes <code>sympy</code>'s <code>lambdify</code> tool to
convert a <code>sympy</code> expression to a Python function for numerical
computations:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def comparison_plot(f, u, Omega, filename='tmp.pdf'):
    x = sym.Symbol('x')
    f = sym.lambdify([x], f, modules=&quot;numpy&quot;)
    u = sym.lambdify([x], u, modules=&quot;numpy&quot;)
    resolution = 401  # no of points in plot
    xcoor  = linspace(Omega[0], Omega[1], resolution)
    exact  = f(xcoor)
    approx = u(xcoor)
    plot(xcoor, approx)
    hold('on')
    plot(xcoor, exact)
    legend(['approximation', 'exact'])
    savefig(filename)
</code></pre>
<!-- end verbatim block -->
The <code>modules='numpy'</code> argument to <code>lambdify</code> is important
if there are mathematical functions, such as <code>sin</code> or <code>exp</code>
in the symbolic expressions in <code>f</code> or <code>u</code>, and these
mathematical functions are to be used with vector arguments, like
<code>xcoor</code> above.

<p>
Both the <code>least_squares</code> and <code>comparison_plot</code> functions are found in
the file <a href="http://tinyurl.com/znpudbt/approx1D.py" target="_self"><tt>approx1D.py</tt></a>.  The
<code>comparison_plot</code> function in this file is more advanced and flexible
than the simplistic version shown above.  The file <code>ex_approx1D.py</code>
applies the <code>approx1D</code> module to accomplish the forthcoming examples.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
We remind the reader that the code examples can be found in a
tarball at
<a href="http://hplgit.github.io/fem-book/doc/web/" target="_self"><tt>http://hplgit.github.io/fem-book/doc/web/</tt></a>.
The following command shows a useful way to search for code

<p>
<!-- begin verbatim block  shcod-->
<pre><code>Terminal&gt; find . -name '*.py' -exec grep least_squares {} \; -print
</code></pre>
<!-- end verbatim block -->
Here <code>'.'</code> specifies the directory for the search, <code>-name '*.py'</code> that
files with suffix <code>*.py</code> should be searched through while

<p>
<!-- begin verbatim block -->
<pre><code>-exec grep least_squares {} \; -print
</code></pre>
<!-- end verbatim block -->
means that all lines
containing the text <code>least_squares</code> should be printed to the screen.
</div>


<h2 id="fem:approx:global:exact1">Perfect approximation</h2>

<p>
Let us use the code above to recompute the problem from
the section <a href="#fem:approx:global:linear">Example on linear approximation</a> where we want to approximate
a parabola. What happens if we add an element \( x^2 \) to the basis and test what
the best approximation is if \( V \) is the space of all parabolic functions?
The answer is quickly found by running

<p>
<!-- begin verbatim block  pycod-->
<pre><code>&gt;&gt;&gt; from approx1D import *
&gt;&gt;&gt; x = sym.Symbol('x')
&gt;&gt;&gt; f = 10*(x-1)**2-1
&gt;&gt;&gt; u, c = least_squares(f=f, psi=[1, x, x**2], Omega=[1, 2])
&gt;&gt;&gt; print u
10*x**2 - 20*x + 9
&gt;&gt;&gt; print sym.expand(f)
10*x**2 - 20*x + 9
</code></pre>
<!-- end verbatim block -->

<p>
Now, what if we use \( \baspsi_i(x)=x^i \) for \( i=0,1,\ldots,N=40 \)?
The output from <code>least_squares</code> gives \( c_i=0 \) for \( i>2 \), which
means that the method finds the perfect approximation.

<p>
In fact, we have a general result that
if \( f\in V \), the least squares and projection/Galerkin methods compute
the exact solution \( u=f \).
The proof is straightforward: if \( f\in V \), \( f \) can be expanded in
terms of the basis functions, \( f=\sum_{j\in\If} d_j\baspsi_j \), for
some coefficients \( \sequencej{d} \),
and the right-hand side then has entries

$$
\begin{equation*} b_i = (f,\baspsi_i) = \sum_{j\in\If} d_j(\baspsi_j, \baspsi_i) = \sum_{j\in\If} d_jA_{i,j}
\tp  \end{equation*}
$$

The linear system \( \sum_jA_{i,j}c_j = b_i \), \( i\in\If \), is then

$$
\begin{equation*} \sum_{j\in\If} c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},
\quad i\in\If,\end{equation*}
$$

which implies that \( c_i=d_i \) for \( i\in\If \).

<h2 id="fem:approx:global:regression">The regression method</h2>

<p>
So far, the function to be approximated has been known in terms of
a formula \( f(x) \). Very often in applications, no formula is known, but
the function value is known at a set of points. If we use \( N+1 \) basis
functions and know exactly \( N+1 \) function values, we can determine the
coefficients \( c_i \) by <em>interpolation</em> as explained in the section <a href="._fem-book-solarized007.html#fem:approx:global:interp">The interpolation (or collocation) principle</a>. The approximating function will then
equal the \( f \) values at the points where the \( f \) values are sampled.

<p>
However, one normally has \( f \) sampled at a lot of points, here denoted
by \( \xno{0},\xno{1},\ldots,\xno{m} \), and we assume \( m\gg N \). What can
we do then to determine the coefficients?  The answer is to find a
least squares approximation.  The resulting method is called
<em>regression</em> and is well known from statistics when fitting a simple
(usually polynomial) function to a set of data points.

<h3 id="___sec22">Overdetermined equation system </h3>

<p>
Intuitively, we would demand \( u \) to equal \( f \) at all the
data points \( \xno{i} \), \( i0,1,\ldots,m \),

$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i=0,1,\ldots,m\tp
\tag{46}
\end{equation}
$$

The fundamental problem here is that we have more equations than
unknowns since there are \( N+1 \) unknowns and \( m+1>N+1 \) equations.
Such a system of equations is called an <em>overdetermined system</em>.
We can write it in matrix form as

$$
\begin{equation}
\sum_{j\in\If} A_{i,j}c_j = b_i,\quad i=0,1,\ldots,m,
\tag{47}
\end{equation}
$$

with coefficient matrix and right-hand side vector given by

$$
\begin{align}
A_{i,j} &= \baspsi_j(\xno{i}),
\tag{48}\\ 
b_i &= f(\xno{i})\tp
\tag{49}
\end{align}
$$

Note that the matrix is a <em>rectangular</em> \( (m+1)\times(N+1) \)
matrix since \( i=0,\ldots,m \) and \( j=0,\ldots,N \).

<h3 id="___sec23">The normal equations derived from a least squares principle </h3>

<p>
The least squares method is a common technique for solving
overdetermined equations systems. Let us write the overdetermined
system \( \sum_{j\in\If} A_{i,j}c_j = b_i \) more compactly in matrix form
as \( Ac=b \).  Since we have more equations than unknowns, it is (in
general) impossible to find a vector \( c \) that fulfills \( Ac=b \). The
best we can do is to make the residual \( r=b-Ac \) as small as
possible. That is, we can find \( c \) such that it minimizes the norm
Euclidean norm of \( r \): \( ||r|| \).  The algebra simplifies significantly
by minimizing \( ||r||^2 \) instead.  This principle corresponds to a
least squares method.

<p>
The \( i \)-th component of \( r \) reads \( r_i = b_i -\sum_jA_{i,j}c_j \),
so \( ||r||^2 = \sum_ir_i^2 \).
Minimizing \( ||r||^2 \) with respect to the unknowns \( c_0,\ldots,c_N \)
implies that

$$
\begin{equation}
\frac{\partial}{\partial c_k}||r||^2=0,\quad k=0,\ldots,N,
\tag{50}
\end{equation}
$$

which leads to

$$ \frac{\partial}{\partial c_k}\sum_i r_i^2 =
\sum_i 2r_i\frac{\partial r_i}{\partial c_k}
=\sum_i 2r_i \frac{\partial}{\partial c_k}(b_i -\sum_jA_{i,j}c_j)
= 2\sum_i r_i(-A_{i,k}) = 0\tp$$

By inserting \( r_i = b_i -\sum_jA_{i,j}c_j \) in the last expression we
get

$$ \sum_i\left(b_i -\sum_jA_{i,j}c_j\right)\left(-A_{i,k}\right)
= -\sum_i b_iA_{i,k} + \sum_j (\sum_i A_{i,j}A_{i,k})c_j = 0\tp$$

Introducing the transpose of \( A \), \( A^T \), we know that \( A^T_{i,j}=A_{j,i} \).
Therefore, the expression \( \sum_i A_{i,j}A_{i,k} \) can be written
as \( \sum_i A^T_{k,i}A_{i,j} \) and be recognized as the formula for the
matrix-matrix product \( A^TA \). Also, \( \sum_i b_i A_{i,k} \) can be written
\( \sum_i A^T_{k,i}b_i \) and recognized as the matrix-vector product
\( A^Tb \). These observations imply that <a href="#mjx-eqn-50">(50)</a>
is equivalent to the linear system

$$
\begin{equation}
\sum_j (\sum_i A^T_{k,i}A_{i,j})c_j=\sum_j(A^TA)_{k,j}
c_j = \sum_i  A^T_{k,i}b_i=(A^Tb)_k,\quad k=0,\ldots,N,
\tag{51}
\end{equation}
$$

or in matrix form,

$$
\begin{equation}
 A^TA c = A^Tb\tp
\tag{52}
\end{equation}
$$

The equation system <a href="#mjx-eqn-51">(51)</a> or
<a href="#mjx-eqn-52">(52)</a> are known as the
<em>normal equations</em>.
With \( A \) as an \( (m+1)\times (N+1) \) matrix, \( A^TA \) becomes an \( (N+1)\times (N+1) \)
matrix, and \( A^Tb \) becomes a vector of length \( N+1 \). Often, \( m\gg N \),
so \( A^TA \) is much smaller than \( A \).

<p>
Many prefer to write the linear system
<a href="#mjx-eqn-51">(51)</a> on the standard form
\( \sum_j B_{i,j}c_j=d_i \), \( i=0,\ldots,N \).  We can easily do so by
exchanging the \( i \) and \( k \) index (\( i\leftrightarrow k \)), \( \sum_i
A^T_{k,i}A_{i,j} = \sum_k A^T_{i,k}A_{k,j} \), and setting \( B_{i,j}=\sum_k
A^T_{i,k}A_{k,j} \). Similarly, we exchange \( i \) and \( k \) in the right-hand
side expression and get \( \sum_k A^T_{i,k}b_k = d_i \).  Expressing
\( B_{i,j} \) and \( d_i \) in terms of the \( \baspsi_i \) and \( \xno{i} \), using
<a href="#mjx-eqn-48">(48)</a> and
<a href="#mjx-eqn-49">(49)</a>, we end up with the formulas

$$
\begin{align}
B_{i,j} &= \sum_k A^T_{i,k}A_{k,j} = \sum_k A_{k,i}A_{k,j}
=\sum_{k=0}^m\baspsi_i(\xno{k})\baspsi_j(\xno{k}),
\tag{53}\\ 
d_i &=\sum_k A^T_{i,k}b_k = \sum_k A_{k,i}b_k =\sum_{k=0}^m
\baspsi_i(\xno{k})f(\xno{k})
\tag{54}
\end{align}
$$

<h3 id="___sec24">Implementation </h3>

<p>
The following function defines the matrix entries \( B_{i,j} \) according
to <a href="#mjx-eqn-53">(53)</a> and the right-hand side
entries \( d_i \) according
<a href="#mjx-eqn-54">(54)</a>. Thereafter, it solves the
linear system \( \sum_jB_{i,j}c_j=d_i \).  The input data <code>f</code> and <code>psi</code>
hold \( f(x) \) and \( \baspsi_i \), \( i=0,\ldots,N \), as symbolic expression, but
since \( m \) is thought to be much larger than \( N \), and there are loops
from \( 0 \) to \( m \), we use numerical computing to speed up the
computations.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def regression(f, psi, points):
    N = len(psi) - 1
    m = len(points)
    # Use numpy arrays and numerical computing
    B = np.zeros((N+1, N+1))
    d = np.zeros(N+1)
    # Wrap psi and f in Python functions rather than expressions
    # so that we can evaluate psi at points[i]
    x = sym.Symbol('x')
    psi_sym = psi  # save symbolic expression
    psi = [sym.lambdify([x], psi[i]) for i in range(N+1)]
    f = sym.lambdify([x], f)
    for i in range(N+1):
        for j in range(N+1):
            B[i,j] = 0
            for k in range(m+1):
                B[i,j] += psi[i](points[k])*psi[j](points[k])
        d[i] = 0
        for k in range(m+1):
            d[i] += psi[i](points[k])*f(points[k])
    c = np.linalg.solve(B, d)
    u = sum(c[i]*psi_sym[i] for i in range(N+1))
    return u, c
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec25">Example </h3>

<p>
We repeat the computational example from the section <a href="._fem-book-solarized007.html#fem:approx:global:interp">The interpolation (or collocation) principle</a>, but this time with many more
points. The parabola \( f(x)=10(x-1)^2-1 \) is to be approximated by a
linear function on \( \Omega=[1,2] \). We divide \( \Omega \) into \( m+2 \)
intervals and use the inner \( m+1 \) points:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sympy as sym
x = sym.Symbol('x')
f = 10*(x-1)**2 - 1
psi = [1, x]
Omega = [1, 2]
m_values = [2-1, 8-1, 64-1]
# Create m+3 points and use the inner m+1 points
for m in m_values:
    points = np.linspace(Omega[0], Omega[1], m+3)[1:-1]
    u, c = regression(f, psi, points)
    comparison_plot(
        f, u, Omega,
        filename='parabola_by_regression_%d' % (m+1),
        points=points,
        points_legend='%d interpolation points' % (m+1),
        legend_loc='upper left')
</code></pre>
<!-- end verbatim block -->
Figure <a href="#fem:approx:global:linear:regression:fig1">4</a> shows results for
\( m+1=2 \) (left), \( m+1=8 \) (middle), and \( m+1=64 \) (right) data points.
The approximating function is not so sensitive to the number of
points as long as they cover a significant part of the domain (the first 2 point approximation puts too much weight on the center,
while the 8 point approximation cover almost the entire
domain and produces a good approximation which is barely improved with 64 points):

$$
\begin{align*}
u(x) &= 10x - 13.2,\quad 2\hbox{ points}\\ 
u(x) &= 10x - 12.7,\quad 8\hbox{ points}\\ 
u(x) &= 10x - 12.7,\quad 64\hbox{ points}
\end{align*}
$$

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:linear:regression:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 4:  Approximation of a parabola by a regression method with varying number of points.   <!-- caption label: fem:approx:global:linear:regression:fig1 --> </p></center>
<p><img src="fig/parabola_by_regression.png" align="bottom" width=800></p>
</center>

<p>
To explicitly make the link to classical regression in statistics, we
consider \( f=10(x-1)^2 - 1 + \epsilon \), where \( \epsilon \) is a random,
normally distributed variable. The goal in classical regression is
to find the straight line that best fits the data points (in a least
squares sense). The only difference from the previous setup, is that
the \( f(\xno{i}) \) values are based on a function formula, here \( 10(x-1)^2-1 \),
<em>plus</em> normally distributed noise.
Figure <a href="#fem:approx:global:linear:regression:fig2">5</a> shows three sets of
data points, along with the original \( f(x) \) function without noise, and
the straight line that is a least squares approximation to the data points.
<!-- python ex_approx1D.py run_noisy_parabola_by_linear_regression -->

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:linear:regression:fig2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 5:  Approximation of a parabola with noise by a straight line.   <!-- caption label: fem:approx:global:linear:regression:fig2 --> </p></center>
<p><img src="fig/noisy_parabola_by_linear_regression.png" align="bottom" width=800></p>
</center>

<p>
We can fit a parabola instead of a straight line, as done in
Figure <a href="#fem:approx:global:linear:regression:fig3">6</a>. When \( m \) becomes large,
the fitted parabola and the original parabola without noise become very close.
<!-- python ex_approx1D.py run_noisy_parabola_by_quaddratic_regression -->

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:linear:regression:fig3"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 6:  Approximation of a parabola with noise by a parabola.   <!-- caption label: fem:approx:global:linear:regression:fig3 --> </p></center>
<p><img src="fig/noisy_parabola_by_quadratic_regression.png" align="bottom" width=800></p>
</center>

<p>
The regression method is not much used for approximating differential
equations or a given function, but is central in uncertainty quantification
methods such as polynomial chaos expansions.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>The residual: an indirect but computationally cheap measure of the error.</b>
<p>
When attempting to  solve
a system \( A c = b \), we may question how far off a vector \( c_0 \) is.
The error is clearly the difference between \( c \) and \( c_0 \), \( e=c-c_0 \).
The vector \( c_0 \) is obviously the solution of the problem \( A c_0 = b_0 \),
where \( b_0 \) is easily computable as the matrix vector product \( A c_0 \).
The residual can be seen as the error of the input data, \( b - b_0 \)
and is defined

$$
r = b - A c_0 .
$$

Clearly, the error and the residual are related by

$$
A e = r .
$$

While the computation of the error requires inversion of \( A \),
which may be computationally expensive, the residual
is easily computable.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: Here something is missing? What is actually the point? Try to insert a heading in the notice...)</font>
<!-- end inline comment -->
</div>


<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized004.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized006.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

