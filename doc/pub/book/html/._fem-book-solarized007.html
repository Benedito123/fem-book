<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,polynomial chaos,Chaospy software,intrusive polynomial chaos,non-intrusive polynomial chaos,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, u'ch:preface', u'ch:preface'),
              (u'Contents', 3, None, '___sec1'),
              (u'Supplementary materials', 3, None, '___sec2'),
              (u'Quick overview of the finite element method',
               0,
               u'ch:overview',
               u'ch:overview'),
              (u'Function approximation by global functions',
               0,
               u'ch:approx:global',
               u'ch:approx:global'),
              (u'Approximation of vectors',
               1,
               u'fem:approx:vec',
               u'fem:approx:vec'),
              (u'Approximation of planar vectors',
               2,
               u'fem:approx:vec:plane',
               u'fem:approx:vec:plane'),
              (u'The least squares method', 3, None, '___sec7'),
              (u'The projection method', 3, None, '___sec8'),
              (u'Approximation of general vectors',
               2,
               u'fem:approx:vec:Np1dim',
               u'fem:approx:vec:Np1dim'),
              (u'The least squares method', 3, None, '___sec10'),
              (u'The Galerkin or projection method', 3, None, '___sec11'),
              (u'Approximation principles',
               1,
               u'fem:approx:global',
               u'fem:approx:global'),
              (u'The least squares method',
               2,
               u'fem:approx:LS',
               u'fem:approx:LS'),
              (u'The projection (or Galerkin) method', 2, None, '___sec14'),
              (u'Example on linear approximation',
               2,
               u'fem:approx:global:linear',
               u'fem:approx:global:linear'),
              (u'Implementation of the least squares method',
               2,
               u'fem:approx:global:LS:code',
               u'fem:approx:global:LS:code'),
              (u'Symbolic integration', 3, None, '___sec17'),
              (u'Fall back on numerical integration', 3, None, '___sec18'),
              (u'Plotting the approximation', 3, None, '___sec19'),
              (u'Perfect approximation',
               2,
               u'fem:approx:global:exact1',
               u'fem:approx:global:exact1'),
              (u'The regression method',
               2,
               u'fem:approx:global:regression',
               u'fem:approx:global:regression'),
              (u'Overdetermined equation system', 3, None, '___sec22'),
              (u'The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              (u'Implementation', 3, None, '___sec24'),
              (u'Example', 3, None, '___sec25'),
              (u'Orthogonal basis functions', 1, None, '___sec26'),
              (u'Ill-conditioning',
               2,
               u'fem:approx:global:illconditioning',
               u'fem:approx:global:illconditioning'),
              (u'Fourier series',
               2,
               u'fem:approx:global:Fourier',
               u'fem:approx:global:Fourier'),
              (u'Orthogonal basis functions',
               2,
               u'fem:approx:global:orth',
               u'fem:approx:global:orth'),
              (u'Numerical computations', 2, None, '___sec30'),
              (u'Interpolation', 1, None, '___sec31'),
              (u'The interpolation (or collocation) principle',
               2,
               u'fem:approx:global:interp',
               u'fem:approx:global:interp'),
              (u'Example', 3, None, '___sec33'),
              (u'Lagrange polynomials',
               2,
               u'fem:approx:global:Lagrange',
               u'fem:approx:global:Lagrange'),
              (u'Approximation of a polynomial', 3, None, '___sec35'),
              (u'Successful example', 3, None, '___sec36'),
              (u'Less successful example', 3, None, '___sec37'),
              (u'Remedy for strong oscillations', 3, None, '___sec38'),
              (u'Bernstein polynomials',
               2,
               u'fem:approx:global:Bernstein',
               u'fem:approx:global:Bernstein'),
              (u'Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              (u'Approximation of functions in higher dimensions',
               1,
               u'fem:approx:2D',
               u'fem:approx:2D'),
              (u'2D basis functions as tensor products of 1D functions',
               2,
               u'fem:approx:2D:global',
               u'fem:approx:2D:global'),
              (u'Example on polynomial basis in 2D', 2, None, '___sec43'),
              (u'Implementation',
               2,
               u'fem:approx:2D:global:code',
               u'fem:approx:2D:global:code'),
              (u'Extension to 3D',
               2,
               u'fem:approx:3D:global',
               u'fem:approx:3D:global'),
              (u'Exercises', 1, None, '___sec46'),
              (u'Problem 1: Linear algebra refresher',
               2,
               u'fem:approx:exer:linalg1',
               u'fem:approx:exer:linalg1'),
              (u'Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               u'fem:approx:exer:vec:3Dby2D',
               u'fem:approx:exer:vec:3Dby2D'),
              (u'Problem 3: Approximate a parabola by a sine',
               2,
               u'fem:approx:exer:parabola_sine',
               u'fem:approx:exer:parabola_sine'),
              (u'Problem 4: Approximate the exponential function by power functions',
               2,
               u'fem:approx:exer:exp:powers',
               u'fem:approx:exer:exp:powers'),
              (u'Problem 5: Approximate the sine function by power functions',
               2,
               u'fem:approx:exer:sin:powers',
               u'fem:approx:exer:sin:powers'),
              (u'Problem 6: Approximate a steep function by sines',
               2,
               u'fem:approx:exer:tanh:sine1',
               u'fem:approx:exer:tanh:sine1'),
              (u'Remarks', 3, None, '___sec53'),
              (u'Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               u'fem:approx:exer:tanh:sine3',
               u'fem:approx:exer:tanh:sine3'),
              (u'Remarks', 3, None, '___sec55'),
              (u'Exercise 8: Fourier series as a least squares approximation',
               2,
               u'fem:approx:exer:Fourier',
               u'fem:approx:exer:Fourier'),
              (u'Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               u'fem:approx:exer:tanh:Lagrange',
               u'fem:approx:exer:tanh:Lagrange'),
              (u'Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               u'fem:approx:exer:tanh:Lagrange:regression',
               u'fem:approx:exer:tanh:Lagrange:regression'),
              (u'Function approximation by finite elements',
               0,
               u'ch:approx:fe',
               u'ch:approx:fe'),
              (u'Finite element basis functions',
               1,
               u'fem:approx:fe',
               u'fem:approx:fe'),
              (u'Elements and nodes',
               2,
               u'fem:approx:fe:def:elements:nodes',
               u'fem:approx:fe:def:elements:nodes'),
              (u'Example', 3, None, '___sec62'),
              (u'The basis functions', 2, None, '___sec63'),
              (u'Construction principles', 3, None, '___sec64'),
              (u'Properties of $\\basphi_i$', 3, None, '___sec65'),
              (u'Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              (u'Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              (u'Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              (u'Calculating the linear system',
               2,
               u'fem:approx:global:linearsystem',
               u'fem:approx:global:linearsystem'),
              (u'Calculating specific matrix entries', 3, None, '___sec70'),
              (u'Calculating a general row in the matrix',
               3,
               None,
               '___sec71'),
              (u'Assembly of elementwise computations',
               2,
               u'fem:approx:fe:elementwise',
               u'fem:approx:fe:elementwise'),
              (u'The element matrix', 3, None, '___sec73'),
              (u'Assembly of element matrices', 3, None, '___sec74'),
              (u'Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              (u'The element vector', 3, None, '___sec76'),
              (u'Mapping to a reference element',
               2,
               u'fem:approx:fe:mapping',
               u'fem:approx:fe:mapping'),
              (u'The coordinate transformation', 3, None, '___sec78'),
              (u'Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              (u'Formulas for local basis functions', 3, None, '___sec80'),
              (u'Example on integration over a reference element',
               2,
               u'fem:approx:fe:intg:ref',
               u'fem:approx:fe:intg:ref'),
              (u'Implementation',
               1,
               u'fem:approx:fe:impl',
               u'fem:approx:fe:impl'),
              (u'Integration',
               2,
               u'fem:approx:fe:impl:intg',
               u'fem:approx:fe:impl:intg'),
              (u'Linear system assembly and solution',
               2,
               u'fem:approx:fe:impl:linsys',
               u'fem:approx:fe:impl:linsys'),
              (u'Example on computing symbolic approximations',
               2,
               u'fem:approx:fe:impl:ex1:symbolic',
               u'fem:approx:fe:impl:ex1:symbolic'),
              (u'Using interpolation instead of least squares',
               2,
               u'fem:approx:fe:impl:ex1:collocation',
               u'fem:approx:fe:impl:ex1:collocation'),
              (u'Example on computing numerical approximations',
               2,
               u'fem:approx:fe:impl:ex1:numeric',
               u'fem:approx:fe:impl:ex1:numeric'),
              (u'The structure of the coefficient matrix',
               2,
               u'fem:approx:fe:A:structure',
               u'fem:approx:fe:A:structure'),
              (u'Applications',
               2,
               u'fem:approx:fe:impl:ex2',
               u'fem:approx:fe:impl:ex2'),
              (u'Sparse matrix storage and solution',
               2,
               u'fem:approx:fe:impl:sparse',
               u'fem:approx:fe:impl:sparse'),
              (u'Comparison of finite elements and finite differences',
               1,
               u'fem:approx:fe:fd',
               u'fem:approx:fe:fd'),
              (u'Finite difference approximation of given functions',
               2,
               u'fem:approx:fe:fd:fdproj',
               u'fem:approx:fe:fd:fdproj'),
              (u'Interpretation of a finite element approximation in terms of finite difference operators',
               2,
               u'fem:approx:fe:fd:feproj',
               u'fem:approx:fe:fd:feproj'),
              (u'Making finite elements behave as finite differences',
               2,
               u'fem:deq:1D:approx:fem_vs_fdm',
               u'fem:deq:1D:approx:fem_vs_fdm'),
              (u'Computations in physical space', 3, None, '___sec95'),
              (u'Elementwise computations', 3, None, '___sec96'),
              (u'Terminology', 3, None, '___sec97'),
              (u'A generalized element concept',
               1,
               u'fem:approx:fe:element',
               u'fem:approx:fe:element'),
              (u'Cells, vertices, and degrees of freedom',
               2,
               u'fem:approx:fe:element:terminology',
               u'fem:approx:fe:element:terminology'),
              (u'Extended finite element concept',
               2,
               u'fem:approx:fe:element:def',
               u'fem:approx:fe:element:def'),
              (u'Implementation',
               2,
               u'fem:approx:fe:element:impl',
               u'fem:approx:fe:element:impl'),
              (u'Computing the error of the approximation',
               2,
               u'fem:approx:fe:error',
               u'fem:approx:fe:error'),
              (u'Example on cubic Hermite polynomials',
               2,
               u'fem:approx:fe:element:impl:Hermite',
               u'fem:approx:fe:element:impl:Hermite'),
              (u'Numerical integration', 1, None, '___sec104'),
              (u'Newton-Cotes rules',
               2,
               u'fem:approx:fe:numint1',
               u'fem:approx:fe:numint1'),
              (u'Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              (u'Finite elements in 2D and 3D', 1, None, '___sec107'),
              (u'Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              (u'Element matrices and vectors', 3, None, '___sec109'),
              (u'Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              (u'Affine mapping of the reference cell', 2, None, '___sec111'),
              (u'Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              (u'Computing integrals', 2, None, '___sec113'),
              (u'Implementation',
               1,
               u'fe:approx:fenics',
               u'fe:approx:fenics'),
              (u'Example on approximation in 2D using FEniCS',
               2,
               u'fem:approx:fenics:2D',
               u'fem:approx:fenics:2D'),
              (u'Mathematical problem', 3, None, '___sec116'),
              (u'The code', 3, None, '___sec117'),
              (u'Dissection of the code', 3, None, '___sec118'),
              (u'Integrating SymPy and FEniCS', 3, None, '___sec119'),
              (u'Refined code with curve plotting',
               2,
               u'fem:approx:fenics:2D:2',
               u'fem:approx:fenics:2D:2'),
              (u'Interpolation and projection', 3, None, '___sec121'),
              (u'Plotting the solution along a line', 3, None, '___sec122'),
              (u'Integrating plotting and computations',
               3,
               None,
               '___sec123'),
              (u'Exercises', 1, None, '___sec124'),
              (u'Problem 11: Define nodes and elements',
               2,
               u'fem:approx:fe:exer:mesh1',
               u'fem:approx:fe:exer:mesh1'),
              (u'Problem 12: Define vertices, cells, and dof maps',
               2,
               u'fem:approx:fe:exer:mesh2',
               u'fem:approx:fe:exer:mesh2'),
              (u'Problem 13: Construct matrix sparsity patterns',
               2,
               u'fem:approx:fe:exer:defmesh:sparsity',
               u'fem:approx:fe:exer:defmesh:sparsity'),
              (u'Problem 14: Perform symbolic finite element computations',
               2,
               u'fem:approx:fe:exer:Asinwt:symbolic',
               u'fem:approx:fe:exer:Asinwt:symbolic'),
              (u'Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               u'fem:approx:exer:tanh:P1P2',
               u'fem:approx:exer:tanh:P1P2'),
              (u'Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               u'fem:approx:exer:tanh:P3P4',
               u'fem:approx:exer:tanh:P3P4'),
              (u'Exercise 17: Investigate the approximation error in finite elements',
               2,
               u'fem:approx:fe:exer:Asinwt:interpol:error',
               u'fem:approx:fe:exer:Asinwt:interpol:error'),
              (u'Problem 18: Approximate a step function by finite elements',
               2,
               u'fem:approx:fe:exer:Heaviside',
               u'fem:approx:fe:exer:Heaviside'),
              (u'Exercise 19: 2D approximation with orthogonal functions',
               2,
               u'fem:approx:fe:exer:2Dsines:symbolic',
               u'fem:approx:fe:exer:2Dsines:symbolic'),
              (u'Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               u'fem:approx:fe:exer:1D:trapez',
               u'fem:approx:fe:exer:1D:trapez'),
              (u'Exercise 21: Compare P1 elements and interpolation',
               2,
               u'fem:approx:fe:exer:1D:P1:vs:interp',
               u'fem:approx:fe:exer:1D:P1:vs:interp'),
              (u'Exercise 22: Implement 3D computations with global basis functions',
               2,
               u'fem:approx:fe:exer:3D:approx3D',
               u'fem:approx:fe:exer:3D:approx3D'),
              (u"Exercise 23: Use Simpson's rule and P2 elements",
               2,
               u'fem:approx:fe:exer:1D:simpson',
               u'fem:approx:fe:exer:1D:simpson'),
              (u'Exercise 24: Make a 3D code for Lagrange elements of arbitrary order',
               2,
               None,
               '___sec138'),
              (u'Variational formulations with global basis functions',
               0,
               u'ch:varform:global',
               u'ch:varform:global'),
              (u'Basic principles for approximating differential equations',
               1,
               u'fem:deq:1D:principles',
               u'fem:deq:1D:principles'),
              (u'Differential equation models',
               2,
               u'fem:deq:1D:models',
               u'fem:deq:1D:models'),
              (u'Simple model problems and their solutions',
               2,
               u'fem:deq:1D:models:simple',
               u'fem:deq:1D:models:simple'),
              (u'Forming the residual',
               2,
               u'fem:deq:1D:residual:min',
               u'fem:deq:1D:residual:min'),
              (u'The least squares method', 2, None, '___sec144'),
              (u'The Galerkin method', 2, None, '___sec145'),
              (u'The method of weighted residuals', 2, None, '___sec146'),
              (u'Test and trial functions', 2, None, '___sec147'),
              (u'The collocation method', 2, None, '___sec148'),
              (u'The subdomain collocation method', 3, None, '___sec149'),
              (u'Examples on using the principles',
               2,
               u'fem:deq:1D:ex:sines',
               u'fem:deq:1D:ex:sines'),
              (u'The model problem', 3, None, '___sec151'),
              (u'Basis functions', 3, None, '___sec152'),
              (u'The residual', 3, None, '___sec153'),
              (u'The least squares method', 3, None, '___sec154'),
              (u'The Galerkin method', 3, None, '___sec155'),
              (u'The collocation method', 3, None, '___sec156'),
              (u'Comparison', 3, None, '___sec157'),
              (u'Integration by parts',
               2,
               u'fem:deq:1D:varform',
               u'fem:deq:1D:varform'),
              (u'Weak form', 3, None, '___sec159'),
              (u'Boundary function',
               2,
               u'fem:deq:1D:essBC:Bfunc',
               u'fem:deq:1D:essBC:Bfunc'),
              (u'Computing with global polynomials', 1, None, '___sec161'),
              (u'Computing with Dirichlet and Neumann conditions',
               2,
               u'fem:deq:1D:varform:ex:DN:case',
               u'fem:deq:1D:varform:ex:DN:case'),
              (u'When the numerical method is exact', 2, None, '___sec163'),
              (u'Abstract notation for variational formulations',
               2,
               u'fem:deq:1D:varform:abstract',
               u'fem:deq:1D:varform:abstract'),
              (u'Variational problems and minimization of functionals',
               2,
               u'fem:deq:1D:optimization',
               u'fem:deq:1D:optimization'),
              (u'Example', 3, None, '___sec166'),
              (u'The general minimization problem', 3, None, '___sec167'),
              (u'Derivation', 3, None, '___sec168'),
              (u'Minimization of the discretized functional',
               3,
               None,
               '___sec169'),
              (u'Calculus of variations', 3, None, '___sec170'),
              (u'Examples on variational formulations',
               1,
               u'fem:deq:1D:varform:ex',
               u'fem:deq:1D:varform:ex'),
              (u'Variable coefficient', 2, None, '___sec172'),
              (u'First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec173'),
              (u'Nonlinear coefficient', 2, None, '___sec174'),
              (u'Implementation of the algorithms',
               1,
               u'fem:global:deq:1D:code',
               u'fem:global:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:global',
               u'fem:deq:1D:code:global'),
              (u'Fallback on numerical methods', 2, None, '___sec177'),
              (u'Example with constant right-hand side',
               2,
               None,
               '___sec178'),
              (u'Approximations may fail: convection-diffusion',
               1,
               u'ch:convdiff',
               u'ch:convdiff'),
              (u'Exercises', 1, None, '___sec180'),
              (u'Exercise 25: Refactor functions into a more general class',
               2,
               u'fem:deq:exer:BVP1D:class',
               u'fem:deq:exer:BVP1D:class'),
              (u'Exercise 26: Compute the deflection of a cable with sine functions',
               2,
               u'fem:deq:exer:tension:cable',
               u'fem:deq:exer:tension:cable'),
              (u'Exercise 27: Compute the deflection of a cable with power functions',
               2,
               u'fem:deq:exer:tension:cable_xn',
               u'fem:deq:exer:tension:cable_xn'),
              (u'Exercise 28: Check integration by parts',
               2,
               u'fem:deq:exer:intg:parts',
               u'fem:deq:exer:intg:parts'),
              (u'Variational formulations with finite elements',
               0,
               u'ch:varform:fe',
               u'ch:varform:fe'),
              (u'Computing with finite elements',
               1,
               u'fem:deq:1D:fem1',
               u'fem:deq:1D:fem1'),
              (u'Finite element mesh and basis functions',
               2,
               None,
               '___sec187'),
              (u'Computation in the global physical domain',
               2,
               u'fem:deq:1D:comp:global',
               u'fem:deq:1D:comp:global'),
              (u'Comparison with a finite difference discretization',
               2,
               u'fem:deq:1D:fdm_vs_fem',
               u'fem:deq:1D:fdm_vs_fem'),
              (u'Cellwise computations',
               2,
               u'fem:deq:1D:comp:elmwise',
               u'fem:deq:1D:comp:elmwise'),
              (u'The integral for the element matrix', 3, None, '___sec191'),
              (u'The integral for the element vector', 3, None, '___sec192'),
              (u'Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec193'),
              (u'Contributions from the first and last cell',
               3,
               None,
               '___sec194'),
              (u'Assembly', 3, None, '___sec195'),
              (u'Boundary conditions: specified nonzero value',
               1,
               u'fem:deq:1D:essBC',
               u'fem:deq:1D:essBC'),
              (u'General construction of a boundary function',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc',
               u'fem:deq:1D:fem:essBC:Bfunc'),
              (u'Example on computing with a finite element-based boundary function',
               2,
               None,
               '___sec198'),
              (u'Computations in physical coordinates', 3, None, '___sec199'),
              (u'Cellwise computations on the reference element',
               3,
               None,
               '___sec200'),
              (u'Modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (u'Computations in the physical system', 3, None, '___sec202'),
              (u'Symmetric modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (u'Modification of the element matrix and vector',
               2,
               None,
               '___sec204'),
              (u'Boundary conditions: specified derivative',
               1,
               u'fem:deq:1D:BC:nat',
               u'fem:deq:1D:BC:nat'),
              (u'The variational formulation', 2, None, '___sec206'),
              (u'Boundary term vanishes because of the test functions',
               2,
               u'fem:deq:1D:BC:nat:uLtest',
               u'fem:deq:1D:BC:nat:uLtest'),
              (u'Boundary term vanishes because of linear system modifications',
               2,
               u'fem:deq:1D:BC:nat:uLmod',
               u'fem:deq:1D:BC:nat:uLmod'),
              (u'Direct computation of the global linear system',
               2,
               u'fem:deq:1D:BC:nat:Aub',
               u'fem:deq:1D:BC:nat:Aub'),
              (u'Cellwise computations', 2, None, '___sec210'),
              (u'Implementation of finite element algorithms',
               1,
               u'fem:deq:1D:code',
               u'fem:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:fe',
               u'fem:deq:1D:code:fe'),
              (u'Utilizing a sparse matrix',
               2,
               u'fem:deq:1D:code:fe_sparse',
               u'fem:deq:1D:code:fe_sparse'),
              (u'Application to our model problem', 2, None, '___sec214'),
              (u'Variational formulations in 2D and 3D',
               1,
               u'fem:deq:2D:varform',
               u'fem:deq:2D:varform'),
              (u'Integration by parts', 2, None, '___sec216'),
              (u'Example on a multi-dimensional variational problem',
               2,
               u'sec:varform:general:convdiff',
               u'sec:varform:general:convdiff'),
              (u'Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec218'),
              (u'Numerical integration', 2, None, '___sec219'),
              (u'Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec220'),
              (u'A glimpse of the mathematical theory of the finite element method',
               2,
               None,
               '___sec221'),
              (u'Abstract variational forms', 3, None, '___sec222'),
              (u'Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec223'),
              (u'Assumptions', 3, None, '___sec224'),
              (u'Existence and uniqueness', 3, None, '___sec225'),
              (u'Stability', 3, None, '___sec226'),
              (u'Equivalent minimization problem', 3, None, '___sec227'),
              (u'Best approximation principle', 3, None, '___sec228'),
              (u'Best approximation property in the norm of the space',
               3,
               None,
               '___sec229'),
              (u'Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec230'),
              (u'Equivalent matrix minimization problem',
               3,
               None,
               '___sec231'),
              (u'A priori error estimate for the derivative',
               3,
               None,
               '___sec232'),
              (u'A priori error estimate for the solution',
               3,
               None,
               '___sec233'),
              (u'Implementation in 2D and 3D via FEniCS',
               1,
               u'fem:varform:fenics',
               u'fem:varform:fenics'),
              (u'Mathematical problem',
               2,
               u'fem:varform:fenics:problem',
               u'fem:varform:fenics:problem'),
              (u'Symmetry', 3, None, '___sec236'),
              (u'Variational formulation',
               2,
               u'fem:varform:fenics:varform',
               u'fem:varform:fenics:varform'),
              (u'The FEniCS solver', 2, None, '___sec238'),
              (u'Making the mesh', 2, None, '___sec239'),
              (u'Solving a problem', 2, None, '___sec240'),
              (u'Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec241'),
              (u'Summary', 1, None, '___sec242'),
              (u'Exercises', 1, None, '___sec243'),
              (u'Exercise 29: Compute the deflection of a cable with 2 P1 elements',
               2,
               u'fem:deq:exer:cable:2P1',
               u'fem:deq:exer:cable:2P1'),
              (u'Exercise 30: Compute the deflection of a cable with 1 P2 element',
               2,
               u'fem:deq:exer:cable:1P2',
               u'fem:deq:exer:cable:1P2'),
              (u'Exercise 31: Compute the deflection of a cable with a step load',
               2,
               u'fem:deq:exer:cable:stepload',
               u'fem:deq:exer:cable:stepload'),
              (u'Exercise 32: Compute with a non-uniform mesh',
               2,
               u'fem:deq:exer:1D:mesh:nonuniform',
               u'fem:deq:exer:1D:mesh:nonuniform'),
              (u'Problem 33: Solve a 1D finite element problem by hand',
               2,
               u'fem:deq:exer:1D:gen:problem1',
               u'fem:deq:exer:1D:gen:problem1'),
              (u'Exercise 34: Investigate exact finite element solutions',
               2,
               u'fem:deq:exer:1D:exact_numerics',
               u'fem:deq:exer:1D:exact_numerics'),
              (u'Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               u'fem:deq:exer:1D:Poisson:polar',
               u'fem:deq:exer:1D:Poisson:polar'),
              (u'Exercise 36: Compute with variable coefficients and P1 elements by hand',
               2,
               u'fem:deq:exer:1D:gen:problem2',
               u'fem:deq:exer:1D:gen:problem2'),
              (u'Exercise 37: Solve a 2D Poisson equation using polynomials and sines',
               2,
               u'fem:deq:exer:2D:torsion:xy:sin',
               u'fem:deq:exer:2D:torsion:xy:sin'),
              (u'Time-dependent variational forms',
               0,
               u'ch:femtime',
               u'ch:femtime'),
              (u'Discretization in time by a Forward Euler scheme',
               1,
               u'fem:deq:diffu:FE',
               u'fem:deq:diffu:FE'),
              (u'Time discretization', 2, None, '___sec255'),
              (u'Space discretization', 2, None, '___sec256'),
              (u'Variational forms', 2, None, '___sec257'),
              (u'Notation for the solution at recent time levels',
               2,
               None,
               '___sec258'),
              (u'Deriving the linear systems', 2, None, '___sec259'),
              (u'Computational algorithm', 2, None, '___sec260'),
              (u'Example using sinusoidal basis functions',
               2,
               u'fem:deq:diffu:FE:cosex',
               u'fem:deq:diffu:FE:cosex'),
              (u'Comparing P1 elements with the finite difference method',
               2,
               u'fem:deq:diffu:FE:fdvsP1fe',
               u'fem:deq:diffu:FE:fdvsP1fe'),
              (u'Lumping the mass matrix', 3, None, '___sec263'),
              (u'Discretization in time by a Backward Euler scheme',
               1,
               u'fem:deq:diffu:BE',
               u'fem:deq:diffu:BE'),
              (u'Time discretization', 2, None, '___sec265'),
              (u'Variational forms', 2, None, '___sec266'),
              (u'Linear systems', 2, None, '___sec267'),
              (u'Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec268'),
              (u'Dirichlet boundary conditions',
               1,
               u'fem:deq:diffu:Dirichlet',
               u'fem:deq:diffu:Dirichlet'),
              (u'Boundary function', 2, None, '___sec270'),
              (u'Finite element basis functions', 2, None, '___sec271'),
              (u'Modification of the linear system', 2, None, '___sec272'),
              (u'Example: Oscillating Dirichlet boundary condition',
               2,
               u'fem:deq:diffu:Dirichlet:ex',
               u'fem:deq:diffu:Dirichlet:ex'),
              (u'Accuracy of the finite element solution',
               1,
               u'fem:deq:diffu:anal',
               u'fem:deq:diffu:anal'),
              (u'Illustrating example', 2, None, '___sec275'),
              (u'Methods of analysis', 2, None, '___sec276'),
              (u'Fourier components and dispersion relations',
               2,
               None,
               '___sec277'),
              (u'Forward Euler discretization', 2, None, '___sec278'),
              (u'Backward Euler discretization', 2, None, '___sec279'),
              (u'Comparing amplification factors', 2, None, '___sec280'),
              (u'Exercises', 1, None, '___sec281'),
              (u'Exercise 38: Analyze a Crank-Nicolson scheme for the diffusion equation',
               2,
               u'fem:deq:exer:diffu:analysis:CN',
               u'fem:deq:exer:diffu:analysis:CN'),
              (u'Variational forms for systems of PDEs',
               0,
               u'ch:femsys',
               u'ch:femsys'),
              (u'Variational forms', 1, u'fem:sys:vform', u'fem:sys:vform'),
              (u'Sequence of scalar PDEs formulation', 2, None, '___sec285'),
              (u'Vector PDE formulation', 2, None, '___sec286'),
              (u'A worked example', 1, u'fem:sys:uT:ex', u'fem:sys:uT:ex'),
              (u'Identical function spaces for the unknowns',
               1,
               None,
               '___sec288'),
              (u'Variational form of each individual PDE',
               2,
               None,
               '___sec289'),
              (u'Compound scalar variational form', 2, None, '___sec290'),
              (u'Decoupled linear systems', 2, None, '___sec291'),
              (u'Coupled linear systems', 2, None, '___sec292'),
              (u'Different function spaces for the unknowns',
               1,
               None,
               '___sec293'),
              (u'Computations in 1D',
               1,
               u'femsys:cooling:1D',
               u'femsys:cooling:1D'),
              (u'Another example in 1D',
               2,
               u'fem:sys:up:1D',
               u'fem:sys:up:1D'),
              (u'Exercises', 1, None, '___sec296'),
              (u'Problem 39: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:1',
               u'femsys:exer:cooling:1'),
              (u'Problem 40: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:2',
               u'femsys:exer:cooling:2'),
              (u'Flexible implementations of boundary conditions',
               0,
               u'ch:nitsche',
               u'ch:nitsche'),
              (u'Optimization with constraint',
               1,
               u'nitsche:fxy:opt',
               u'nitsche:fxy:opt'),
              (u'Elimination of variables', 2, None, '___sec301'),
              (u'Lagrange multiplier method',
               2,
               u'nitsche:fxy:opt:Lagrange',
               u'nitsche:fxy:opt:Lagrange'),
              (u'Penalty method',
               2,
               u'nitsche:fxy:opt:penalty',
               u'nitsche:fxy:opt:penalty'),
              (u'Optimization of functionals',
               1,
               u'nitsche:pde:opt',
               u'nitsche:pde:opt'),
              (u'Classical calculus of variations',
               2,
               u'nitsche:pde:opt:varcalculus',
               u'nitsche:pde:opt:varcalculus'),
              (u'Penalty method for optimization with constraints',
               2,
               u'nitsche:pde:opt:penalty',
               u'nitsche:pde:opt:penalty'),
              (u'Lagrange multiplier method for optimization with constraints',
               2,
               u'nitsche:pde:opt:Lagrange',
               u'nitsche:pde:opt:Lagrange'),
              (u'Example: 1D problem',
               2,
               u'nitsche:pde:opt:1Dex',
               u'nitsche:pde:opt:1Dex'),
              (u'Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec309'),
              (u'Nonlinear problems', 0, u'ch:nonlin', u'ch:nonlin'),
              (u'Introduction of basic concepts',
               1,
               u'nonlin:timediscrete:logistic',
               u'nonlin:timediscrete:logistic'),
              (u'Linear versus nonlinear equations', 2, None, '___sec312'),
              (u'Algebraic equations', 3, None, '___sec313'),
              (u'Differential equations', 3, None, '___sec314'),
              (u'A simple model problem', 2, None, '___sec315'),
              (u'Linearization by explicit time discretization',
               2,
               u'nonlin:timediscrete:logistic:FE',
               u'nonlin:timediscrete:logistic:FE'),
              (u'Exact solution of nonlinear algebraic equations',
               2,
               u'nonlin:timediscrete:logistic:roots',
               u'nonlin:timediscrete:logistic:roots'),
              (u'Linearization', 2, None, '___sec318'),
              (u'Picard iteration',
               2,
               u'nonlin:timediscrete:logistic:Picard',
               u'nonlin:timediscrete:logistic:Picard'),
              (u'Stopping criteria', 3, None, '___sec320'),
              (u'A single Picard iteration', 3, None, '___sec321'),
              (u'Linearization by a geometric mean',
               2,
               u'nonlin:timediscrete:logistic:geometric:mean',
               u'nonlin:timediscrete:logistic:geometric:mean'),
              (u"Newton's method",
               2,
               u'nonlin:timediscrete:logistic:Newton',
               u'nonlin:timediscrete:logistic:Newton'),
              (u'Relaxation',
               2,
               u'nonlin:timediscrete:logistic:relaxation',
               u'nonlin:timediscrete:logistic:relaxation'),
              (u'Implementation and experiments',
               2,
               u'nonlin:timediscrete:logistic:impl',
               u'nonlin:timediscrete:logistic:impl'),
              (u'Generalization to a general nonlinear ODE',
               2,
               u'nonlin:ode:generic',
               u'nonlin:ode:generic'),
              (u'Explicit time discretization', 3, None, '___sec327'),
              (u'Backward Euler discretization', 3, None, '___sec328'),
              (u'Crank-Nicolson discretization', 3, None, '___sec329'),
              (u'Systems of ODEs',
               2,
               u'nonlin:ode:generic:sys:pendulum',
               u'nonlin:ode:generic:sys:pendulum'),
              (u'Example', 3, None, '___sec331'),
              (u'Systems of nonlinear algebraic equations',
               1,
               u'nonlin:systems:alg',
               u'nonlin:systems:alg'),
              (u'Picard iteration',
               2,
               u'nonlin:systems:alg:Picard',
               u'nonlin:systems:alg:Picard'),
              (u"Newton's method",
               2,
               u'nonlin:systems:alg:Newton',
               u'nonlin:systems:alg:Newton'),
              (u'Stopping criteria',
               2,
               u'nonlin:systems:alg:terminate',
               u'nonlin:systems:alg:terminate'),
              (u'Example: A nonlinear ODE model from epidemiology',
               2,
               u'nonlin:systems:alg:SI',
               u'nonlin:systems:alg:SI'),
              (u'Implicit time discretization', 3, None, '___sec337'),
              (u'A Picard iteration', 3, None, '___sec338'),
              (u"Newton's method", 3, None, '___sec339'),
              (u'Linearization at the differential equation level',
               1,
               u'nonlin:pdelevel',
               u'nonlin:pdelevel'),
              (u'Explicit time integration',
               2,
               u'nonlin:pdelevel:explicit',
               u'nonlin:pdelevel:explicit'),
              (u'Backward Euler scheme and Picard iteration',
               2,
               u'nonlin:pdelevel:Picard',
               u'nonlin:pdelevel:Picard'),
              (u"Backward Euler scheme and Newton's method",
               2,
               u'nonlin:pdelevel:Newton',
               u'nonlin:pdelevel:Newton'),
              (u'Linearization via Taylor expansions', 3, None, '___sec344'),
              (u'Similarity with Picard iteration', 3, None, '___sec345'),
              (u'Implementation', 3, None, '___sec346'),
              (u'Derivation with alternative notation', 3, None, '___sec347'),
              (u'Crank-Nicolson discretization',
               2,
               u'nonlin:pdelevel:Picard:CN',
               u'nonlin:pdelevel:Picard:CN'),
              (u'1D stationary nonlinear differential equations',
               1,
               u'nonlin:alglevel:1D',
               u'nonlin:alglevel:1D'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:1D:fd',
               u'nonlin:alglevel:1D:fd'),
              (u'Solution of algebraic equations', 2, None, '___sec351'),
              (u'The structure of the equation system', 3, None, '___sec352'),
              (u'Picard iteration', 3, None, '___sec353'),
              (u'Mesh with two cells', 3, None, '___sec354'),
              (u"Newton's method", 3, None, '___sec355'),
              (u'Multi-dimensional PDE problems', 1, None, '___sec356'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:dD:fd',
               u'nonlin:alglevel:dD:fd'),
              (u'Picard iteration', 3, None, '___sec358'),
              (u"Newton's method", 3, None, '___sec359'),
              (u'Continuation methods', 2, None, '___sec360'),
              (u'Exercises', 1, u'nonlin:exer', u'nonlin:exer'),
              (u'Problem 41: Determine if equations are nonlinear or not',
               2,
               u'nonlin:exer:lin:vs:nonlin',
               u'nonlin:exer:lin:vs:nonlin'),
              (u'Exercise 42: Derive and investigate a generalized logistic model',
               2,
               u'nonlin:exer:logistic:gen',
               u'nonlin:exer:logistic:gen'),
              (u"Problem 43: Experience the behavior of Newton's method",
               2,
               u'nonlin:exer:Newton:problems1',
               u'nonlin:exer:Newton:problems1'),
              (u'Problem 44: Compute the Jacobian of a $2\\times 2$ system',
               2,
               u'nonlin:exer:vib:Jacobian',
               u'nonlin:exer:vib:Jacobian'),
              (u'Problem 45: Solve nonlinear equations arising from a vibration ODE',
               2,
               u'nonlin:exer:vib:geometric:mean',
               u'nonlin:exer:vib:geometric:mean'),
              (u'Exercise 46: Find the truncation error of arithmetic mean of products',
               2,
               u'nonlin:exer:products:arith:mean',
               u'nonlin:exer:products:arith:mean'),
              (u"Problem 47: Newton's method for linear problems",
               2,
               u'nonlin:exer:Newton:linear',
               u'nonlin:exer:Newton:linear'),
              (u'Exercise 48: Discretize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:fem',
               u'nonlin:exer:1D:1pu2:fem'),
              (u'Exercise 49: Linearize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:PicardNewton',
               u'nonlin:exer:1D:1pu2:PicardNewton'),
              (u'Problem 50: Finite differences for the 1D Bratu problem',
               2,
               u'nonlin:exer:1D:fu:discretize:fd',
               u'nonlin:exer:1D:fu:discretize:fd'),
              (u'Exercise 51: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               u'nonlin:exer:1D:heat:nonlinear:fdm',
               u'nonlin:exer:1D:heat:nonlinear:fdm'),
              (u'Exercise 52: Differentiate a highly nonlinear term',
               2,
               u'nonlin:exer:grad:pow:term',
               u'nonlin:exer:grad:pow:term'),
              (u'Exercise 53: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               u'nonlin:exer:2D:heat:nonlinear:fd',
               u'nonlin:exer:2D:heat:nonlinear:fd'),
              (u'Exercise 54: Find the sparsity of the Jacobian',
               2,
               u'nonlin:exer:sparsity:Jacobian',
               u'nonlin:exer:sparsity:Jacobian'),
              (u'Problem 55: Investigate a 1D problem with a continuation method',
               2,
               u'nonlin:exer:continuation:1DnNflow',
               u'nonlin:exer:continuation:1DnNflow'),
              (u'Symbolic nonlinear finite element equations',
               1,
               u'nonlin:app:fem_vs_fdm',
               u'nonlin:app:fem_vs_fdm'),
              (u'Finite element basis functions',
               2,
               u'nonlin:alglevel:1D:fe_basis',
               u'nonlin:alglevel:1D:fe_basis'),
              (u'The group finite element method',
               2,
               u'nonlin:alglevel:1D:fe:group',
               u'nonlin:alglevel:1D:fe:group'),
              (u'Finite element approximation of functions of $u$',
               3,
               None,
               '___sec380'),
              (u'Simplified problem', 3, None, '___sec381'),
              (u'Integrating nonlinear functions', 3, None, '___sec382'),
              (u'Application of the group finite element method',
               3,
               None,
               '___sec383'),
              (u'Numerical integration of nonlinear terms by hand',
               2,
               u'nonlin:alglevel:1D:fe:f',
               u'nonlin:alglevel:1D:fe:f'),
              (u'Discretization of a variable coefficient Laplace term',
               2,
               u'nonlin:alglevel:1D:fe:Laplace',
               u'nonlin:alglevel:1D:fe:Laplace'),
              (u'Group finite element method', 3, None, '___sec386'),
              (u'Numerical integration at the nodes', 3, None, '___sec387'),
              (u'Uncertainty quantification and polynomial chaos expansions',
               0,
               u'ch:pc',
               u'ch:pc'),
              (u'Sample problems', 1, None, '___sec389'),
              (u'ODE for decay processes', 2, None, '___sec390'),
              (u'The stochastic Poisson equation', 2, None, '___sec391'),
              (u'Basic principles', 1, None, '___sec392'),
              (u'Basic statistical results', 2, None, '___sec393'),
              (u'Least-squares methods', 2, None, '___sec394'),
              (u'Example: Least squares applied to the decay ODE',
               2,
               None,
               '___sec395'),
              (u'Modeling the response', 2, None, '___sec396'),
              (u'Numerical integration', 2, None, '___sec397'),
              (u'Stochastic collocation', 2, None, '___sec398'),
              (u'The Chaospy software', 1, u'pc:chaospy', u'pc:chaospy'),
              (u'Intrusive polynomial chaos methods',
               1,
               u'pc:intrusive',
               u'pc:intrusive'),
              (u'Variational methods for linear systems',
               0,
               u'ch:cg',
               u'ch:cg'),
              (u'Conjugate gradient-like iterative methods',
               1,
               u'ch:linalg:CGmethods',
               u'ch:linalg:CGmethods'),
              (u'The Galerkin method', 2, None, '___sec403'),
              (u'The least squares method', 2, None, '___sec404'),
              (u'Krylov subspaces', 2, None, '___sec405'),
              (u'Computation of the basis vectors', 2, None, '___sec406'),
              (u'Computation of a new solution vector', 2, None, '___sec407'),
              (u'Summary of the least squares method', 2, None, '___sec408'),
              (u'Remark', 3, None, '___sec409'),
              (u'Truncation and restart', 2, None, '___sec410'),
              (u'Summary of the Galerkin method', 2, None, '___sec411'),
              (u'A framework based on the error', 2, None, '___sec412'),
              (u'Preconditioning',
               1,
               u'ch:linalg2:preconditioning',
               u'ch:linalg2:preconditioning'),
              (u'Motivation and Basic Principles', 2, None, '___sec414'),
              (u'Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec415'),
              (u'Classical iterative methods as preconditioners',
               2,
               u'ch:linalg:SORprecond',
               u'ch:linalg:SORprecond'),
              (u'Incomplete factorization preconditioners',
               2,
               u'linalg:ILU',
               u'linalg:ILU'),
              (u'Appendix: Useful formulas',
               0,
               u'ch:formulas',
               u'ch:formulas'),
              (u'Finite difference operator notation',
               1,
               u'sec:form:fdop',
               u'sec:form:fdop'),
              (u'Truncation errors of finite difference approximations',
               1,
               u'sec:form:truncerr',
               u'sec:form:truncerr'),
              (u'Finite differences of exponential functions',
               1,
               u'sec:form:fdexp',
               u'sec:form:fdexp'),
              (u'Complex exponentials', 3, None, '___sec422'),
              (u'Real exponentials', 3, None, '___sec423'),
              (u'Finite differences of $t^n$',
               1,
               u'sec:form:fdtn',
               u'sec:form:fdtn'),
              (u'Software', 2, None, '___sec425'),
              (u'References', 1, None, '___sec426')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0007"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="___sec31">Interpolation </h1>

<h2 id="fem:approx:global:interp">The interpolation (or collocation) principle</h2>

<p>
The principle of minimizing the distance between \( u \) and \( f \) is
an intuitive way of computing a best approximation \( u\in V \) to \( f \).
However, there are other approaches as well.
One is to demand that \( u(\xno{i}) = f(\xno{i}) \) at some selected points
\( \xno{i} \), \( i\in\If \):

$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i\in\If\tp  \tag{58}
\end{equation}
$$

We recognize that the equation \( \sum_j c_j \baspsi_j(\xno{i}) = f(\xno{i}) \)
is actually a linear system with \( N+1 \) unknown coefficients \( \sequencej{c} \):

$$
\begin{equation}
\sum_{j\in\If} A_{i,j}c_j = b_i,\quad i\in\If,
\tag{59}
\end{equation}
$$

with coefficient matrix and right-hand side vector given by

$$
\begin{align}
A_{i,j} &= \baspsi_j(\xno{i}),
\tag{60}\\ 
b_i &= f(\xno{i})\tp   \tag{61}
\end{align}
$$

This time the coefficient matrix is not symmetric because
\( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general.
The method is often referred to as an <em>interpolation method</em>
since some point values of \( f \) are given (\( f(\xno{i}) \)) and we
fit a continuous function \( u \) that goes through the \( f(\xno{i}) \) points.
In this case the \( \xno{i} \) points are called <em>interpolation points</em>.
When the same approach is used to approximate differential equations,
one usually applies the name <em>collocation method</em> and
\( \xno{i} \) are known as <em>collocation points</em>.

<p>
Given \( f \)  as a <code>sympy</code> symbolic expression <code>f</code>, \( \sequencei{\baspsi} \)
as a list <code>psi</code>, and a set of points \( \sequencei{x} \)  as a list or array
<code>points</code>, the following Python function sets up and solves the matrix system
for the coefficients \( \sequencei{c} \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def interpolation(f, psi, points):
    N = len(psi) - 1
    A = sym.zeros((N+1, N+1))
    b = sym.zeros((N+1, 1))
    psi_sym = psi  # save symbolic expression
    # Turn psi and f into Python functions
    x = sym.Symbol('x')
    psi = [sym.lambdify([x], psi[i]) for i in range(N+1)]
    f = sym.lambdify([x], f)
    for i in range(N+1):
        for j in range(N+1):
            A[i,j] = psi[j](points[i])
        b[i,0] = f(points[i])
    c = A.LUsolve(b)
    # c is a sympy Matrix object, turn to list
    c = [sym.simplify(c[i,0]) for i in range(c.shape[0])]
    u = sym.simplify(sum(c[i,0]*psi_sym[i] for i in range(N+1)))
    return u, c
</code></pre>
<!-- end verbatim block -->
The <code>interpolation</code> function is a part of the <code>approx1D</code>
module.

<p>
We found it convenient in the above function to turn the expressions <code>f</code> and
<code>psi</code> into ordinary Python functions of <code>x</code>, which can be called with
<code>float</code> values in the list <code>points</code> when building the matrix and
the right-hand side. The alternative is to use the <code>subs</code> method
to substitute the <code>x</code> variable in an expression by an element from
the <code>points</code> list. The following session illustrates both approaches
in a simple setting:

<p>
<!-- begin verbatim block  ipy-->
<pre><code>&gt;&gt;&gt; import sympy as sym
&gt;&gt;&gt; x = sym.Symbol('x')
&gt;&gt;&gt; e = x**2              # symbolic expression involving x
&gt;&gt;&gt; p = 0.5               # a value of x
&gt;&gt;&gt; v = e.subs(x, p)      # evaluate e for x=p
&gt;&gt;&gt; v
0.250000000000000
&gt;&gt;&gt; type(v)
sympy.core.numbers.Float
&gt;&gt;&gt; e = lambdify([x], e)  # make Python function of e
&gt;&gt;&gt; type(e)
&gt;&gt;&gt; function
&gt;&gt;&gt; v = e(p)              # evaluate e(x) for x=p
&gt;&gt;&gt; v
0.25
&gt;&gt;&gt; type(v)
float
</code></pre>
<!-- end verbatim block -->

<p>
A nice feature of the interpolation or collocation method is that it
avoids computing integrals. However, one has to decide on the location
of the \( \xno{i} \) points.  A simple, yet common choice, is to
distribute them uniformly throughout the unit interval.

<h3 id="___sec33">Example </h3>

<p>
Let us illustrate the interpolation method by approximating
our parabola \( f(x)=10(x-1)^2-1 \) by a linear function on \( \Omega=[1,2] \),
using two collocation points \( x_0=1+1/3 \) and \( x_1=1+2/3 \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sympy as sym
x = sym.Symbol('x')
f = 10*(x-1)**2 - 1
psi = [1, x]
Omega = [1, 2]
points = [1 + sym.Rational(1,3), 1 + sym.Rational(2,3)]
u, c = interpolation(f, psi, points)
comparison_plot(f, u, Omega)
</code></pre>
<!-- end verbatim block -->
The resulting linear system becomes

$$
\begin{equation*}
\left(\begin{array}{ll}
1 & 4/3\\ 
1 & 5/3\\ 
\end{array}\right)
\left(\begin{array}{l}
c_0\\ 
c_1\\ 
\end{array}\right)
=
\left(\begin{array}{l}
1/9\\ 
31/9\\ 
\end{array}\right)
\end{equation*}
$$

with solution \( c_0=-119/9 \) and \( c_1=10 \).
Figure <a href="#fem:approx:global:linear:interp:fig1">10</a> (left) shows the resulting
approximation \( u=-119/9 + 10x \).
We can easily test other interpolation points, say \( x_0=1 \) and \( x_1=2 \).
This changes the line quite significantly, see
Figure <a href="#fem:approx:global:linear:interp:fig1">10</a> (right).

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:linear:interp:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 10:  Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right).   <!-- caption label: fem:approx:global:linear:interp:fig1 --> </p></center>
<p><img src="fig/parabola_inter.png" align="bottom" width=800></p>
</center>

<h2 id="fem:approx:global:Lagrange">Lagrange polynomials</h2>

<p>
In the section <a href="._fem-book-solarized006.html#fem:approx:global:Fourier">Fourier series</a> we explained the advantage
of having a diagonal matrix: formulas for the coefficients
\( \sequencei{c} \) can then be derived by hand. For an interpolation (or
collocation) method a diagonal matrix implies that \( \baspsi_j(\xno{i})
= 0 \) if \( i\neq j \). One set of basis functions \( \baspsi_i(x) \) with this
property is the <em>Lagrange interpolating polynomials</em>, or just
<em>Lagrange polynomials</em>. (Although the functions are named after
Lagrange, they were first discovered by Waring in 1779, rediscovered
by Euler in 1783, and published by Lagrange in 1795.)  Lagrange
polynomials are key building blocks in the finite element method, so
familiarity with these polynomials will be required anyway.

<p>
A Lagrange polynomial can be written as

$$
\begin{equation}
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N},
\tag{62}
\end{equation}
$$

for \( i\in\If \).
We see from <a href="#mjx-eqn-62">(62)</a> that all the \( \baspsi_i \)
functions are polynomials of degree \( N \) which have the property

$$
\begin{equation}
\baspsi_i(x_s) = \delta_{is},\quad \delta_{is} =
\left\lbrace\begin{array}{ll}
1, & i=s,\\ 
0, & i\neq s,
\end{array}\right.
\tag{63}
\end{equation}
$$

when \( x_s \) is an interpolation (collocation) point.
Here we have used the <em>Kronecker delta</em> symbol \( \delta_{is} \).
This property implies that \( A \) is a diagonal matrix, that is
that  \( A_{i,j}=0 \) for \( i\neq j \) and
\( A_{i,j}=1 \) when \( i=j \). The solution of the linear system is
then simply

$$
\begin{equation}
c_i = f(\xno{i}),\quad i\in\If,
\tag{64}
\end{equation}
$$

and

$$
\begin{equation}
u(x) = \sum_{j\in\If} c_i \baspsi_i(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)\tp   \tag{65}
\end{equation}
$$

We remark however that <a href="#mjx-eqn-63">(63)</a> does not necessary imply that the matrix
obtained by the least squares or project methods are diagonal.

<p>
The following function computes the Lagrange interpolating polynomial
\( \baspsi_i(x) \) on the unit interval (0,1), given the interpolation points \( \xno{0},\ldots,\xno{N} \) in
the list or array <code>points</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def Lagrange_polynomial(x, i, points):
    p = 1
    for k in range(len(points)):
        if k != i:
            p *= (x - points[k])/(points[i] - points[k])
    return p
</code></pre>
<!-- end verbatim block -->
The next function computes a complete basis, \( \baspsi_0,\ldots,\baspsi_N \), using equidistant points throughout
\( \Omega \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def Lagrange_polynomials_01(x, N):
    if isinstance(x, sym.Symbol):
        h = sym.Rational(1, N-1)
    else:
        h = 1.0/(N-1)
    points = [i*h for i in range(N)]
    psi = [Lagrange_polynomial(x, i, points) for i in range(N)]
    return psi, points
</code></pre>
<!-- end verbatim block -->
When <code>x</code> is an <code>sym.Symbol</code> object, we let the spacing between the
interpolation points, <code>h</code>, be a <code>sympy</code> rational number, so that we
get nice end results in the formulas for \( \baspsi_i \).  The other case,
when <code>x</code> is a plain Python <code>float</code>, signifies numerical computing, and
then we let <code>h</code> be a floating-point number.  Observe that the
<code>Lagrange_polynomial</code> function works equally well in the symbolic and
numerical case - just think of <code>x</code> being an <code>sym.Symbol</code> object or a
Python <code>float</code>.  A little interactive session illustrates the
difference between symbolic and numerical computing of the basis
functions and points:

<p>
<!-- begin verbatim block  ipy-->
<pre><code>&gt;&gt;&gt; import sympy as sym
&gt;&gt;&gt; x = sym.Symbol('x')
&gt;&gt;&gt; psi, points = Lagrange_polynomials_01(x, N=2)
&gt;&gt;&gt; points
[0, 1/2, 1]
&gt;&gt;&gt; psi
[(1 - x)*(1 - 2*x), 2*x*(2 - 2*x), -x*(1 - 2*x)]

&gt;&gt;&gt; x = 0.5  # numerical computing
&gt;&gt;&gt; psi, points = Lagrange_polynomials_01(x, N=2)
&gt;&gt;&gt; points
[0.0, 0.5, 1.0]
&gt;&gt;&gt; psi
[-0.0, 1.0, 0.0]
</code></pre>
<!-- end verbatim block -->

<p>
That is, when used symbolically, the <code>Lagrange_polynomials_01</code>
function returns the symbolic expression for the Lagrange functions
while when <code>x</code> is a numerical valued the function returns the value of
the basis function evaluate in <code>x</code>.  In the present example only the
second basis function should be 1 in the mid-point while the others
are zero according to <a href="#mjx-eqn-63">(63)</a>.

<h3 id="___sec35">Approximation of a polynomial </h3>

<p>
The Galerkin or least squares methods lead to an exact approximation
if \( f \) lies in the space spanned by the basis functions. It could be
of interest to see how the interpolation method with Lagrange
polynomials as basis is able to approximate a polynomial, e.g., a
parabola. Running

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for N in 2, 4, 5, 6, 8, 10, 12:
    f = x**2
    psi, points = Lagrange_polynomials_01(x, N)
    u = interpolation(f, psi, points)
</code></pre>
<!-- end verbatim block -->
shows the result that up to <code>N=4</code> we achieve an exact approximation,
and then round-off errors start to grow, such that
<code>N=15</code> leads to a 15-degree polynomial for \( u \) where
the coefficients in front of \( x^r \) for \( r>2 \) are
of size \( 10^{-5} \) and smaller. As the matrix is ill-conditioned
and we use floating-point arithmetic, we do not obtain the exact
solution. Still, we get  a solution that is visually identical to the
exact solution. The reason is that the ill-conditioning causes
the system to have many solutions very close to the true solution.
While we are lucky for <code>N=15</code> and obtain a solution that is
visually identical to the true solution, ill-conditioning may also
result in completely wrong results. As we continue with higher values,  <code>N=20</code> reveals that the
procedure is starting to fall apart as the approximate solution is around 0.9 at \( x=1.0 \),
where it should have
been \( 1.0 \). At <code>N=30</code> the approximate solution is around \( 5\cdot10^8  \) at \( x=1 \).

<p>

<!-- begin inline comment -->
<font color="red">(<b>kam 2</b>: Not sure of this. Need to test. Seems like an unstable variant of Lagrange which is somewhat strange when combined with interpolation which should produce the identity matrix)</font>
<!-- end inline comment -->

<h3 id="___sec36">Successful example </h3>

<p>
Trying out the Lagrange polynomial basis for approximating
\( f(x)=\sin 2\pi x \) on \( \Omega =[0,1] \) with the least squares
and the interpolation techniques can be done by

<p>
<!-- begin verbatim block  pycod-->
<pre><code>x = sym.Symbol('x')
f = sym.sin(2*sym.pi*x)
psi, points = Lagrange_polynomials_01(x, N)
Omega=[0, 1]
u, c = least_squares(f, psi, Omega)
comparison_plot(f, u, Omega)
u, c = interpolation(f, psi, points)
comparison_plot(f, u, Omega)
</code></pre>
<!-- end verbatim block -->
Figure <a href="#fem:approx:global:Lagrange:fig:sine:ls:colloc">11</a> shows the results.
There is a difference between the least squares and the interpolation
technique but the difference decreases rapidly with  Increasing \( N \).

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:Lagrange:fig:sine:ls:colloc"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 11:  Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 3.  <!-- caption label: fem:approx:global:Lagrange:fig:sine:ls:colloc --> </p></center>
<p><img src="fig/Lagrange_ls_interp_sin_4.png" align="bottom" width=800></p>
</center>

<h3 id="___sec37">Less successful example </h3>

<p>
The next example concerns interpolating \( f(x)=|1-2x| \) on \( \Omega
=[0,1] \) using Lagrange polynomials. Figure
<a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14">12</a> shows a peculiar
effect: the approximation starts to oscillate more and more as \( N \)
grows. This numerical artifact is not surprising when looking at the
individual Lagrange polynomials. Figure
<a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:osc">13</a> shows two such
polynomials, \( \psi_2(x) \) and \( \psi_7(x) \), both of degree 11 and
computed from uniformly spaced points \( \xno{i}=i/11 \),
\( i=0,\ldots,11 \), marked with circles.  We clearly see the property of
Lagrange polynomials: \( \psi_2(\xno{i})=0 \) and \( \psi_7(\xno{i})=0 \) for
all \( i \), except \( \psi_2(\xno{2})=1 \) and \( \psi_7(\xno{7})=1 \).  The most
striking feature, however, is the dominating oscillation near the
boundary where \( \psi_2>5 \) and \( \psi_7=-10 \) in some points. The reason is easy to understand: since we force the
functions to be zero at so many points, a polynomial of high degree is
forced to oscillate between the points.  The phenomenon is named
<em>Runge's phenomenon</em> and you can read a more detailed explanation on
<a href="http://en.wikipedia.org/wiki/Runge%27s_phenomenon" target="_self">Wikipedia</a>.

<h3 id="___sec38">Remedy for strong oscillations </h3>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,
\tag{66}
\end{equation}
$$

on the interval \( \Omega = [a,b] \).
Here is a flexible version of the <code>Lagrange_polynomials_01</code> function above,
valid for any interval \( \Omega =[a,b] \) and with the possibility to generate
both uniformly distributed points and Chebyshev nodes:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def Lagrange_polynomials(x, N, Omega, point_distribution='uniform'):
    if point_distribution == 'uniform':
        if isinstance(x, sym.Symbol):
            h = sym.Rational(Omega[1] - Omega[0], N)
        else:
            h = (Omega[1] - Omega[0])/float(N)
        points = [Omega[0] + i*h for i in range(N+1)]
    elif point_distribution == 'Chebyshev':
        points = Chebyshev_nodes(Omega[0], Omega[1], N)
    psi = [Lagrange_polynomial(x, i, points) for i in range(N+1)]
    return psi, points

def Chebyshev_nodes(a, b, N):
    from math import cos, pi
    return [0.5*(a+b) + 0.5*(b-a)*cos(float(2*i+1)/(2*N+1))*pi) \ 
            for i in range(N+1)]
</code></pre>
<!-- end verbatim block -->
All the functions computing Lagrange polynomials listed
above are found in the module file <code>Lagrange.py</code>.

<p>
Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14">14</a> shows the
improvement of using Chebyshev nodes, compared with the equidistant
points in Figure
<a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14">12</a>.  The reason for
this improvement is that the corresponding Lagrange polynomials have
much smaller oscillations, which can be seen by comparing Figure
<a href="#fem:approx:global:Lagrange:fig:abs:Lag:Cheb:osc">15</a> (Chebyshev
points) with Figure
<a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:osc">13</a> (equidistant
points). Note the different scale on the vertical axes in the two
figures and also that the Chebyshev points tend to cluster
more around the element boundaries.

<p>
Another cure for undesired oscillations of higher-degree interpolating
polynomials is to use lower-degree Lagrange polynomials on many small
patches of the domain. This is actually the idea pursued in the finite
element method. For instance, linear Lagrange polynomials on \( [0,1/2] \)
and \( [1/2,1] \) would yield a perfect approximation to \( f(x)=|1-2x| \) on
\( \Omega = [0,1] \) since \( f \) is piecewise linear.

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 12:  Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right).   <!-- caption label: fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14 --> </p></center>
<p><img src="fig/Lagrange_interp_abs_8_15.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:Lagrange:fig:abs:Lag:unif:osc"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 13:  Illustration of the oscillatory behavior of two Lagrange polynomials based on 12 uniformly spaced points (marked by circles).   <!-- caption label: fem:approx:global:Lagrange:fig:abs:Lag:unif:osc --> </p></center>
<p><img src="fig/Lagrange_basis_12.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 14:  Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right).   <!-- caption label: fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14 --> </p></center>
<p><img src="fig/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:Lagrange:fig:abs:Lag:Cheb:osc"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 15:  Illustration of the less oscillatory behavior of two Lagrange polynomials based on 12 Chebyshev points (marked by circles).   <!-- caption label: fem:approx:global:Lagrange:fig:abs:Lag:Cheb:osc --> </p></center>
<p><img src="fig/Lagrange_basis_Cheb_12.png" align="bottom" width=400></p>
</center>

<p>
How does the least squares or projection methods work with Lagrange
polynomials?
We can just call the <code>least_squares</code> function, but
<code>sympy</code> has problems integrating the \( f(x)=|1-2x| \)
function times a polynomial, so we need to fall back on numerical
integration.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def least_squares(f, psi, Omega):
    N = len(psi) - 1
    A = sym.zeros((N+1, N+1))
    b = sym.zeros((N+1, 1))
    x = sym.Symbol('x')
    for i in range(N+1):
        for j in range(i, N+1):
            integrand = psi[i]*psi[j]
            I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
            if isinstance(I, sym.Integral):
                # Could not integrate symbolically, fall back
                # on numerical integration with mpmath.quad
                integrand = sym.lambdify([x], integrand)
                I = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
            A[i,j] = A[j,i] = I
        integrand = psi[i]*f
        I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
        if isinstance(I, sym.Integral):
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
        b[i,0] = I
    c = A.LUsolve(b)
    c = [sym.simplify(c[i,0]) for i in range(c.shape[0])]
    u = sum(c[i]*psi[i] for i in range(len(psi)))
    return u, c
</code></pre>
<!-- end verbatim block -->

<p>
<!-- Convergence of Lagrange polynomials. -->

<p>
<center> <!-- figure label: --> <div id="fem:approx:global:Lagrange:fig:abs:Lag:unif:ls"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 16:  Illustration of an approximation of the absolute value function using the least square method .   <!-- caption label: fem:approx:global:Lagrange:fig:abs:Lag:unif:ls --> </p></center>
<p><img src="fig/Lagrange_ls_abs_12.png" align="bottom" width=400></p>
</center>

<h2 id="fem:approx:global:Bernstein">Bernstein polynomials</h2>

<p>
An alternative to the Taylor and Lagrange families of polynomials
are the Bernstein polynomials.
These polynomials are popular in visualization and we include a
presentation of them for completeness. Furthermore, as we
will demonstrate, the choice of basis functions may matter
in terms of accuracy and efficiency.
In fact, in finite element methods,
a main challenge, from a numerical analysis point of view,
is to determine appropriate basis functions for
a particular purpose or equation.

<p>
On the unit interval, the Bernstein
polynomials are defined in terms of powers of \( x \) and \( 1-x \)
(the barycentric coordinates of the unit interval) as
$$
\begin{equation}
B_{i,n} = \binom{n}{i} x^i (1-x)^{n-i}, \quad i=0, \ldots, n .
\tag{67}
\end{equation}
$$

<p>
<center> <!-- figure label: --> <div id="Bernstein_basis_8"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 17:  The nine functions of a Bernstein basis of order 8.  <!-- caption label: Bernstein_basis_8 --> </p></center>
<p><img src="fig/Bernstein_basis8.png" align="bottom" ></p>
</center>

<p>
<center> <!-- figure label: --> <div id="Lagrange_basis_8"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 18:  The nine functions of a Lagrange basis of order 8.  <!-- caption label: Lagrange_basis_8 --> </p></center>
<p><img src="fig/Lagrange_basis8.png" align="bottom" ></p>
</center>

<p>
The Figure <a href="#Bernstein_basis_8">17</a> shows the  basis functions of a Bernstein basis of order 8.
This figure should be compared against Figure <a href="#Lagrange_basis_8">18</a>, which
shows the corresponding Lagrange basis of order 8.
The Lagrange basis is convenient because it is a nodal basis, that is; the basis functions are 1 in their nodal points and zero at all other nodal points as described by <a href="#mjx-eqn-63">(63)</a>.
However, looking at Figure <a href="#Lagrange_basis_8">18</a>
we also notice that the basis function are oscillatory and have absolute
values that are significantly larger than 1 between the nodal points.
Consider for instance the basis function represented by the purple color.
It is 1 in \( x=0.5 \) and 0 at all other nodal points
and hence this basis function represents the value at the mid-point.
However, this function also has strong
negative contributions close to the element boundaries where
it takes negative values less than \( -2 \).
For the Bernstein basis, all  functions are positive and
all functions output values in \( [0,1] \). Therefore there is no oscillatory behavior.
The main disadvantage of the Bernstein basis is that the basis is not
a nodal basis. In fact, all functions contribute everywhere except \( x=0 \) and \( x=1 \).

<p>
Both Lagrange and Bernstein polynomials take larger values towards the element boundaries than in
the middle of the element, but the Bernstein polynomials always remain less or equal to 1.

<p>
We  remark that the Bernstein basis is easily extended to polygons in 2D and
3D in terms of the barycentric coordinates. For example, consider the reference triangle in
2D consisting of the faces \( x=0 \), \( y=0 \), and \( x+y=1 \). The barycentric coordinates
are \( b_1(x,y)=x \), \( b_2(x,y) \), and \( b_3(x,y)=1-x-y \) and the Bernstein basis functions
of order \( n \) is of the form

$$
B_{i,j,k} = \frac{n!}{i! j! k!} x^i y^j (1-x-y)^k, \quad \mbox{ for }  i+j+k = n \tp
$$

<h1 id="___sec40">Approximation properties and convergence rates </h1>

<p>
We will now compare the different approximation methods in terms of
accuracy and efficiency.  We consider four different series for
generating approximations: Taylor, Lagrange, sinusoidal, and
Bernstein. For all families we expect that the approximations improve
as we increase the number of basis functions in our
representations. We also expect that the computational complexity
increases. Let us therefore try to quantify the accuracy and
efficiency of the different methods in terms of the number of basis
functions \( N \). In the present example we consider the least square
method.

<p>
Let us consider the approximation of a Gaussian bell function, i.e.,
that the exact solution is

$$
u_e = \exp(-(x-0.5)^2) - \exp(-0.5^2)
$$

We remark that \( u_e \) is zero in \( x=0 \) and \( x=1 \) and that
we have chosen the bell function because it cannot be expressed
as a finite sum of either polynomials or sines.
We may therefore study the behavior as \( N\rightarrow\infty \).

<p>
To quantify the behavior of the error as well as the
complexity of the computations we  compute the approximation
with increasing number of basis functions and time
the computations by using <code>time.clock</code> (returning the CPU time so far
in the program). A code example goes as
follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def convergence_rate_analysis(series_type, func):
    N_values = [2, 4, 8, 16]
    norms = []
    cpu_times = []
    for N in N_values:

        psi = series(series_type, N)
        t0 = time.clock()
        u, c = least_squares_non_verbose(
	       gauss_bell, psi, Omega, False)
        t1 = time.clock()

        error2 = sym.lambdify([x], (func - u)**2)
        L2_norm = scipy.integrate.quad(error2, Omega[0], Omega[1])
        L2_norm = scipy.sqrt(L2_norm)
        norms.append(L2_norm[0])
        cpu_times.append(t1-t0)

    return N_values, norms, cpu_times
</code></pre>
<!-- end verbatim block -->

<p>
We run the analysis as follows

<p>
<!-- begin verbatim block  pycod-->
<pre><code>Omega = [0, 1]
x = sym.Symbol(&quot;x&quot;)
gaussian_bell = sym.exp(-(x-0.5)**2) - sym.exp(-0.5**2)
step = sym.Piecewise((1, 0.25 &lt; x), (0, True)) - \ 
       sym.Piecewise((1, 0.75 &lt; x), (0, True))
func = gaussian_bell

import pylab
series_types = [&quot;Taylor&quot;, &quot;Sinusoidal&quot;, &quot;Bernstein&quot;, &quot;Lagrange&quot;]
for series_type in series_types:
    N_values, norms, cpu_times = \ 
        convergence_rate_analysis(series_type, func)
    plt.loglog(N_values, norms)
plt.show()
</code></pre>
<!-- end verbatim block -->

<p>
Below we list the numerical error for different \( N \)  when approximating the Gaussian bell function.

<p>
<table border="1">
<thead>
<tr><th align="center">    N    </th> <th align="center">   2    </th> <th align="center">   4    </th> <th align="center">   8    </th> <th align="center">   16   </th> </tr>
</thead>
<tbody>
<tr><td align="center">   Taylor       </td> <td align="center">   9.83e-02    </td> <td align="center">   2.63e-03    </td> <td align="center">   7.83e-07    </td> <td align="center">   3.57e-10    </td> </tr>
<tr><td align="center">   sine         </td> <td align="center">   2.70e-03    </td> <td align="center">   6.10e-04    </td> <td align="center">   1.20e-04    </td> <td align="center">   2.17e-05    </td> </tr>
<tr><td align="center">   Bernstein    </td> <td align="center">   2.10e-03    </td> <td align="center">   4.45e-05    </td> <td align="center">   8.73e-09    </td> <td align="center">   4.49e-15    </td> </tr>
<tr><td align="center">   Lagrange     </td> <td align="center">   2.10e-03    </td> <td align="center">   4.45e-05    </td> <td align="center">   8.73e-09    </td> <td align="center">   2.45e-12    </td> </tr>
</tbody>
</table>
<p>
It is quite clear that the different methods have different
properties.  For example, the Lagrange basis for \( N=16 \) is 145 times
more accurate than the Taylor basis. However, Bernstein is actually
more than 500 times more accurate than the Lagrange basis! The
approximations obtained by sines are far behind the polynomial
approximations for \( N>4 \).

<p>
The corresponding CPU time of the required computations also vary quite a bit:

<p>
<table border="1">
<thead>
<tr><th align="center">    N    </th> <th align="center">  2   </th> <th align="center">  4   </th> <th align="center">  8   </th> <th align="center">  16 </th> </tr>
</thead>
<tbody>
<tr><td align="center">   Taylor       </td> <td align="center">   0.0123    </td> <td align="center">   0.0325    </td> <td align="center">   0.108     </td> <td align="center">   0.441    </td> </tr>
<tr><td align="center">   sine         </td> <td align="center">   0.0113    </td> <td align="center">   0.0383    </td> <td align="center">   0.229     </td> <td align="center">   1.107    </td> </tr>
<tr><td align="center">   Bernstein    </td> <td align="center">   0.0384    </td> <td align="center">   0.1100    </td> <td align="center">   0.3368    </td> <td align="center">   1.187    </td> </tr>
<tr><td align="center">   Lagrange     </td> <td align="center">   0.0807    </td> <td align="center">   0.3820    </td> <td align="center">   2.5233    </td> <td align="center">   26.52    </td> </tr>
</tbody>
</table>
<p>
Here, the timings are in seconds.  The Taylor basis is the most
efficient and is in fact more than 60 times faster than the Lagrange
basis for \( N=16 \) (with our naive implementation of basic formulas).

<p>
In order to get a more precise idea of how the approximation methods
behave as \( N \) increases, we investigate two simple data models which
may be used in a regression analysis.  These two are the polynomial
and exponential model defined by

$$
\begin{align}
\tag{68}
E_{1}(N) &= \alpha_{1} N^{\beta_{1}}, \\ 
\tag{69}
E_{2}(N) &= \alpha_{2} \exp(\beta_2 N)
\end{align}
$$

Taking the logarithm of <a href="#mjx-eqn-68">(68)</a> we
obtain

$$
\log (E_1(N)) = \beta_1 \log(N) + log(\alpha_1)
$$

Hence, letting \( x=\log(N) \) be the independent variable and \( y=\log
(E_1(N)) \) the dependent one, we simply have the straight line \( y = a x
+ b \) with \( a=\beta_1 \) and \( b= log(\alpha_1) \).  Then, we may perform a
regression analysis as earlier with respect to the basis functions
\( (1,x) \) and obtain an estimate of the order of convergence in terms of
\( \beta_1 \) . For the second model <a href="#mjx-eqn-69">(69)</a>, we take
the natural logarithm and obtain

$$
\ln (E_2(N)) = \beta_2 N + \ln(\alpha_2)
$$

Again, regression analysis provides the means to estimate the convergence,
but here we let \( x=N \) be the independent variable,
\( y=\ln (E_2(N)) \), \( a=\beta_2 \) and \( b= \ln(\alpha_2) \).
To summarize, the polynomial model should have the data around a straight
line in a log-log plot, while the exponential model has its date around
a straight line in a log plot with the logarithmic scale on the \( y \) axis.

<p>
Before we perform the regression analysis, a good rule is to inspect
the behavior visually in log and log-log plots. Figure
<a href="#fem:approx:bell:loglogfig">19</a> shows a log-log plot of the error with
respect to \( N \) for the various methods. Clearly, the sinusoidal basis
seems to have a polynomial convergence rate as the log-log plot is a
linear line. The Bernstein, Lagrange, and Taylor methods appear to
have convergence that is faster than polynomial. It is then
interesting to consider a log plot and see if the behavior is
exponential. Figure <a href="#fem:approx:bell:semilogfig">20</a> is a log
plot. Here, the Bernstein approximation appears to be a linear line
which suggests that the convergence is exponential.

<p>
<center> <!-- figure label: --> <div id="fem:approx:bell:loglogfig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 19:  Convergence of least square approximation using basis function in terms of the Taylor, sinusoidal, Bernstein and Lagrange basis in a log-log plot.   <!-- caption label: fem:approx:bell:loglogfig --> </p></center>
<p><img src="fig/Bell_convergence_loglog.png" align="bottom" ></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:bell:semilogfig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 20:  Convergence of least square approximation using basis function in terms of the Taylor, sinusoidal, Bernstein and Lagrange basis in a log plot.   <!-- caption label: fem:approx:bell:semilogfig --> </p></center>
<p><img src="fig/Bell_convergence_semilogy.png" align="bottom" ></p>
</center>

<p>
The following program computes the order of convergence for
the sines using the polynomial model <a href="#mjx-eqn-68">(68)</a>
while the Bernstein approximation is estimates
in terms of model <a href="#mjx-eqn-69">(69)</a>. We avoid to
compute estimates for the Taylor and Lagrange approximations as neither
the log-log plot nor the log plot demonstrated linear behavior.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 3</b>: Any comment about the <code>regression_with_noise</code> function?)</font>
<!-- end inline comment -->

<p>
<!-- begin verbatim block  pycod-->
<pre><code>N_values = [2, 4, 8, 16, 32]
Taylor     = [0.0983, 0.00263,  7.83e-07, 3.57e-10]
Sinusoidal = [0.0027, 0.00061,  0.00012,  2.17e-05]
Bernstein  = [0.0021, 4.45e-05, 8.73e-09, 4.49e-15]
Lagrange   = [0.0021, 4.45e-05, 8.73e-09, 2.45e-12]

x = sym.Symbol('x')
psi = [1, x]

u, c = regression_with_noise(log2(Sinusoidal), psi, log2(N_values))
print &quot;estimated model for sine: %3.2e*N**(%3.2e)&quot; % \ 
      (2**(c[0]), c[1])

# Check the numbers estimated by the model by manual inspection
for N in N_values:
    print 2**c[0] * N**c[1]

u, c = regression_with_noise(log(Bernstein), psi, N_values)
print &quot;estimated model for Bernstein: %3.2e*exp(%3.2e*N)&quot; % \ 
      (exp(c[0]), c[1])

# Check the numbers estimated by the model by manual inspection
for N in N_values:
    print exp(c[0]) * exp(N * c[1])
</code></pre>
<!-- end verbatim block -->

<p>
The program estimates the sine approximation convergences as
\( 1.43e-02\cdot N^{-2.3} \), which means that the convergence is slightly
above second order.  The Bernstein approximation on the other hand is
\( 8.01e-02 \cdot \exp(-1.92e+00 N) \).

<p>
The CPU time in this example here would be significantly faster if the
algorithms were implemented in a compiled language like C/C++ or
Fortran and we should not be careful in drawing conclusion about the
efficiency of the different methods based on this example
alone. However, for completeness we include a log-log plot in Figure
<a href="#fem:comp:bell:loglogfig">21</a> to illustrate the polynomial increase in
CPU time with respect to N.

<p>
<center> <!-- figure label: --> <div id="fem:comp:bell:loglogfig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 21:  CPU timings of the approximation with the difference basis in a log-log plot.   <!-- caption label: fem:comp:bell:loglogfig --> </p></center>
<p><img src="fig/Bell_computations_loglog.png" align="bottom" ></p>
</center>

<p>
The complete code can be found in
<a href="http://tinyurl.com/znpudbt/convergence_rate_local.py" target="_self"><tt>convergence_rate_local.py</tt></a>.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

