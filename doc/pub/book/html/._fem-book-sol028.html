<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:64px;      /* fixed header height for style bootswatch_readable */
  margin:-64px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              ('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Contents', 3, None, '___sec1'),
              ('Supplementary materials', 3, None, '___sec2'),
              ('Quick overview of the finite element method',
               0,
               'ch:overview',
               'ch:overview'),
              ('Function approximation by global functions',
               0,
               'ch:approx:global',
               'ch:approx:global'),
              ('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec7'),
              ('The projection method', 3, None, '___sec8'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec10'),
              ('The Galerkin or projection method', 3, None, '___sec11'),
              ('Approximation principles',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method', 2, 'fem:approx:LS', 'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec14'),
              ('Example on linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec17'),
              ('Fall back on numerical integration', 3, None, '___sec18'),
              ('Plotting the approximation', 3, None, '___sec19'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact1',
               'fem:approx:global:exact1'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec22'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              ('Implementation', 3, None, '___sec24'),
              ('Example', 3, None, '___sec25'),
              ('Orthogonal basis functions', 1, None, '___sec26'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec30'),
              ('Interpolation', 1, None, '___sec31'),
              ('The interpolation (or collocation) principle',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec33'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec35'),
              ('Successful example', 3, None, '___sec36'),
              ('Less successful example', 3, None, '___sec37'),
              ('Remedy for strong oscillations', 3, None, '___sec38'),
              ('Bernstein polynomials',
               2,
               'fem:approx:global:Bernstein',
               'fem:approx:global:Bernstein'),
              ('Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              ('Approximation of functions in higher dimensions',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example on polynomial basis in 2D', 2, None, '___sec43'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Exercises', 1, None, '___sec46'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power '
               'functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec53'),
              ('Problem 7: Approximate a steep function by sines with boundary '
               'adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec55'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange '
               'polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange '
               'polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Function approximation by finite elements',
               0,
               'ch:approx:fe',
               'ch:approx:fe'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec62'),
              ('The basis functions', 2, None, '___sec63'),
              ('Construction principles', 3, None, '___sec64'),
              ('Properties of $\\basphi_i$', 3, None, '___sec65'),
              ('Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              ('Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              ('Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec70'),
              ('Calculating a general row in the matrix', 3, None, '___sec71'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec73'),
              ('Assembly of element matrices', 3, None, '___sec74'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              ('The element vector', 3, None, '___sec76'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec78'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              ('Formulas for local basis functions', 3, None, '___sec80'),
              ('Example on integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation', 1, 'fem:approx:fe:impl', 'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite elements and finite differences',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Interpretation of a finite element approximation in terms of '
               'finite difference operators',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fdm',
               'fem:deq:1D:approx:fem_vs_fdm'),
              ('Computations in physical space', 3, None, '___sec95'),
              ('Elementwise computations', 3, None, '___sec96'),
              ('Terminology', 3, None, '___sec97'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example on cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec104'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              ('Finite elements in 2D and 3D', 1, None, '___sec107'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              ('Element matrices and vectors', 3, None, '___sec109'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              ('Affine mapping of the reference cell', 2, None, '___sec111'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              ('Computing integrals', 2, None, '___sec113'),
              ('Implementation', 1, 'fe:approx:fenics', 'fe:approx:fenics'),
              ('Example on approximation in 2D using FEniCS',
               2,
               'fem:approx:fenics:2D',
               'fem:approx:fenics:2D'),
              ('Mathematical problem', 3, None, '___sec116'),
              ('The code', 3, None, '___sec117'),
              ('Dissection of the code', 3, None, '___sec118'),
              ('Integrating SymPy and FEniCS', 3, None, '___sec119'),
              ('Refined code with curve plotting',
               2,
               'fem:approx:fenics:2D:2',
               'fem:approx:fenics:2D:2'),
              ('Interpolation and projection', 3, None, '___sec121'),
              ('Plotting the solution along a line', 3, None, '___sec122'),
              ('Integrating plotting and computations', 3, None, '___sec123'),
              ('Exercises', 1, None, '___sec124'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite '
               'elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis '
               'functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Exercise 24: Make a 3D code for Lagrange elements of arbitrary '
               'order',
               2,
               None,
               '___sec138'),
              ('Variational formulations with global basis functions',
               0,
               'ch:varform:global',
               'ch:varform:global'),
              ('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('Differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Simple model problems and their solutions',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              ('Forming the residual',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec144'),
              ('The Galerkin method', 2, None, '___sec145'),
              ('The method of weighted residuals', 2, None, '___sec146'),
              ('The method of weighted residual and the truncation error',
               2,
               'varform:trunc',
               'varform:trunc'),
              ('Test and trial functions', 2, None, '___sec148'),
              ('The collocation method', 2, None, '___sec149'),
              ('The subdomain collocation method', 3, None, '___sec150'),
              ('Examples on using the principles',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The model problem', 3, None, '___sec152'),
              ('Basis functions', 3, None, '___sec153'),
              ('The residual', 3, None, '___sec154'),
              ('The least squares method', 3, None, '___sec155'),
              ('The Galerkin method', 3, None, '___sec156'),
              ('The collocation method', 3, None, '___sec157'),
              ('Comparison', 3, None, '___sec158'),
              ('Integration by parts',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('Weak form', 3, None, '___sec160'),
              ('Boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Computing with global polynomials', 1, None, '___sec162'),
              ('Computing with Dirichlet and Neumann conditions',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              ('When the numerical method is exact', 2, None, '___sec164'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Variational problems and minimization of functionals',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              ('Example', 3, None, '___sec167'),
              ('The general minimization problem', 3, None, '___sec168'),
              ('Derivation', 3, None, '___sec169'),
              ('Minimization of the discretized functional',
               3,
               None,
               '___sec170'),
              ('Calculus of variations', 3, None, '___sec171'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient', 2, None, '___sec173'),
              ('First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec174'),
              ('Nonlinear coefficient', 2, None, '___sec175'),
              ('Implementation of the algorithms',
               1,
               'fem:global:deq:1D:code',
               'fem:global:deq:1D:code'),
              ('Extensions of the code for approximation',
               2,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              ('Fallback to numerical methods', 2, None, '___sec178'),
              ('Example with constant right-hand side', 2, None, '___sec179'),
              ('Approximations may fail: convection-diffusion',
               1,
               'ch:convdiff',
               'ch:convdiff'),
              ('Exercises', 1, None, '___sec181'),
              ('Exercise 25: Refactor functions into a more general class',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              ('Exercise 26: Compute the deflection of a cable with sine '
               'functions',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              ('Exercise 27: Compute the deflection of a cable with power '
               'functions',
               2,
               'fem:deq:exer:tension:cable_xn',
               'fem:deq:exer:tension:cable_xn'),
              ('Exercise 28: Check integration by parts',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Variational formulations with finite elements',
               0,
               'ch:varform:fe',
               'ch:varform:fe'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Finite element mesh and basis functions', 2, None, '___sec188'),
              ('Computation in the global physical domain',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              ('Comparison with a finite difference discretization',
               2,
               'fem:deq:1D:fdm_vs_fem',
               'fem:deq:1D:fdm_vs_fem'),
              ('Cellwise computations',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('The integral for the element matrix', 3, None, '___sec192'),
              ('The integral for the element vector', 3, None, '___sec193'),
              ('Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec194'),
              ('Contributions from the first and last cell',
               3,
               None,
               '___sec195'),
              ('Assembly', 3, None, '___sec196'),
              ('Boundary conditions: specified nonzero value',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              ('Example on computing with a finite element-based boundary '
               'function',
               2,
               None,
               '___sec199'),
              ('Computations in physical coordinates', 3, None, '___sec200'),
              ('Cellwise computations on the reference element',
               3,
               None,
               '___sec201'),
              ('Modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Computations in the physical system', 3, None, '___sec203'),
              ('Symmetric modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              ('Modification of the element matrix and vector',
               2,
               'fem:bc:elmat:mod',
               'fem:bc:elmat:mod'),
              ('Boundary conditions: specified derivative',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec207'),
              ('Boundary term vanishes because of the test functions',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              ('Boundary term vanishes because of linear system modifications',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              ('Direct computation of the global linear system',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              ('Cellwise computations', 2, None, '___sec211'),
              ('Implementation of finite element algorithms',
               1,
               'fem:deq:1D:code',
               'fem:deq:1D:code'),
              ('Extensions of the code for approximation',
               2,
               'fem:deq:1D:code:fe',
               'fem:deq:1D:code:fe'),
              ('Utilizing a sparse matrix',
               2,
               'fem:deq:1D:code:fe_sparse',
               'fem:deq:1D:code:fe_sparse'),
              ('Application to our model problem', 2, None, '___sec215'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Integration by parts', 2, None, '___sec217'),
              ('Example on a multi-dimensional variational problem',
               2,
               'sec:varform:general:convdiff',
               'sec:varform:general:convdiff'),
              ('Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec219'),
              ('Numerical integration', 2, None, '___sec220'),
              ('Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec221'),
              ('A glimpse of the mathematical theory of the finite element '
               'method',
               2,
               None,
               '___sec222'),
              ('Abstract variational forms', 3, None, '___sec223'),
              ('Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec224'),
              ('Assumptions', 3, None, '___sec225'),
              ('Existence and uniqueness', 3, None, '___sec226'),
              ('Stability', 3, None, '___sec227'),
              ('Equivalent minimization problem', 3, None, '___sec228'),
              ('Best approximation principle', 3, None, '___sec229'),
              ('Best approximation property in the norm of the space',
               3,
               None,
               '___sec230'),
              ('Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec231'),
              ('Equivalent matrix minimization problem', 3, None, '___sec232'),
              ('A priori error estimate for the derivative',
               3,
               None,
               '___sec233'),
              ('A priori error estimate for the solution',
               3,
               None,
               '___sec234'),
              ('Implementation in 2D and 3D via FEniCS',
               1,
               'fem:varform:fenics',
               'fem:varform:fenics'),
              ('Mathematical problem',
               2,
               'fem:varform:fenics:problem',
               'fem:varform:fenics:problem'),
              ('Symmetry', 3, None, '___sec237'),
              ('Variational formulation',
               2,
               'fem:varform:fenics:varform',
               'fem:varform:fenics:varform'),
              ('The FEniCS solver', 2, None, '___sec239'),
              ('Making the mesh', 2, None, '___sec240'),
              ('Solving a problem', 2, None, '___sec241'),
              ('Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec242'),
              ('Summary', 1, None, '___sec243'),
              ('Exercises', 1, None, '___sec244'),
              ('Exercise 29: Compute the deflection of a cable with 2 P1 '
               'elements',
               2,
               'fem:deq:exer:cable:2P1',
               'fem:deq:exer:cable:2P1'),
              ('Exercise 30: Compute the deflection of a cable with 1 P2 '
               'element',
               2,
               'fem:deq:exer:cable:1P2',
               'fem:deq:exer:cable:1P2'),
              ('Exercise 31: Compute the deflection of a cable with a step '
               'load',
               2,
               'fem:deq:exer:cable:stepload',
               'fem:deq:exer:cable:stepload'),
              ('Exercise 32: Compute with a non-uniform mesh',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              ('Problem 33: Solve a 1D finite element problem by hand',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              ('Exercise 34: Investigate exact finite element solutions',
               2,
               'fem:deq:exer:1D:exact_numerics',
               'fem:deq:exer:1D:exact_numerics'),
              ('Exercise 35: Compare finite elements and differences for a '
               'radially symmetric Poisson equation',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              ('Exercise 36: Compute with variable coefficients and P1 '
               'elements by hand',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              ('Exercise 37: Solve a 2D Poisson equation using polynomials and '
               'sines',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              ('Exercise 38: Solve a 3D Laplace problem with FEniCS',
               2,
               'fem:fenics:borehole:exer:3D',
               'fem:fenics:borehole:exer:3D'),
              ('Exercise 39: Solve a 1D Laplace problem with FEniCS',
               2,
               'fem:fenics:borehole:exer:1D',
               'fem:fenics:borehole:exer:1D'),
              ('Time-dependent variational forms',
               0,
               'ch:femtime',
               'ch:femtime'),
              ('Discretization in time by a Forward Euler scheme',
               1,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              ('Time discretization', 2, None, '___sec258'),
              ('Space discretization', 2, None, '___sec259'),
              ('Variational forms', 2, None, '___sec260'),
              ('Notation for the solution at recent time levels',
               2,
               None,
               '___sec261'),
              ('Deriving the linear systems', 2, None, '___sec262'),
              ('Computational algorithm', 2, None, '___sec263'),
              ('Example using cosinusoidal basis functions',
               2,
               'fem:deq:diffu:FE:cosex',
               'fem:deq:diffu:FE:cosex'),
              ('Comparing P1 elements with the finite difference method',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              ('Lumping the mass matrix', 3, None, '___sec266'),
              ('Discretization in time by a Backward Euler scheme',
               1,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              ('Time discretization', 2, None, '___sec268'),
              ('Variational forms', 2, None, '___sec269'),
              ('Linear systems', 2, None, '___sec270'),
              ('Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec271'),
              ('Dirichlet boundary conditions',
               1,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              ('Boundary function', 2, None, '___sec273'),
              ('Finite element basis functions', 2, None, '___sec274'),
              ('Modification of the linear system', 2, None, '___sec275'),
              ('Example: Oscillating Dirichlet boundary condition',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              ('Accuracy of the finite element solution',
               1,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              ('Methods of analysis', 2, None, '___sec278'),
              ('Fourier components and dispersion relations',
               2,
               None,
               '___sec279'),
              ('Forward Euler discretization', 2, None, '___sec280'),
              ('Backward Euler discretization', 2, None, '___sec281'),
              ('Comparing amplification factors', 2, None, '___sec282'),
              ('Exercises', 1, None, '___sec283'),
              ('Exercise 40: Analyze a Crank-Nicolson scheme for the diffusion '
               'equation',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              ('Variational forms for systems of PDEs',
               0,
               'ch:femsys',
               'ch:femsys'),
              ('Variational forms', 1, 'fem:sys:vform', 'fem:sys:vform'),
              ('Sequence of scalar PDEs formulation', 2, None, '___sec287'),
              ('Vector PDE formulation', 2, None, '___sec288'),
              ('A worked example', 1, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              ('Identical function spaces for the unknowns',
               1,
               None,
               '___sec290'),
              ('Variational form of each individual PDE', 2, None, '___sec291'),
              ('Compound scalar variational form', 2, None, '___sec292'),
              ('Decoupled linear systems', 2, None, '___sec293'),
              ('Coupled linear systems', 2, None, '___sec294'),
              ('Different function spaces for the unknowns',
               1,
               None,
               '___sec295'),
              ('Computations in 1D',
               1,
               'femsys:cooling:1D',
               'femsys:cooling:1D'),
              ('Another example in 1D', 2, 'fem:sys:up:1D', 'fem:sys:up:1D'),
              ('Exercises', 1, None, '___sec298'),
              ('Problem 41: Estimate order of convergence for the Cooling law',
               2,
               'femsys:exer:cooling:1',
               'femsys:exer:cooling:1'),
              ('Problem 42: Estimate order of convergence for the Cooling law',
               2,
               'femsys:exer:cooling:2',
               'femsys:exer:cooling:2'),
              ('Flexible implementations of boundary conditions',
               0,
               'ch:nitsche',
               'ch:nitsche'),
              ('Optimization with constraint',
               1,
               'nitsche:fxy:opt',
               'nitsche:fxy:opt'),
              ('Elimination of variables', 2, None, '___sec303'),
              ('Lagrange multiplier method',
               2,
               'nitsche:fxy:opt:Lagrange',
               'nitsche:fxy:opt:Lagrange'),
              ('Penalty method',
               2,
               'nitsche:fxy:opt:penalty',
               'nitsche:fxy:opt:penalty'),
              ('Optimization of functionals',
               1,
               'nitsche:pde:opt',
               'nitsche:pde:opt'),
              ('Classical calculus of variations',
               2,
               'nitsche:pde:opt:varcalculus',
               'nitsche:pde:opt:varcalculus'),
              ("Penalty and Nitsche's methods for optimization with "
               'constraints',
               2,
               'nitsche:pde:opt:penalty',
               'nitsche:pde:opt:penalty'),
              ('Lagrange multiplier method for optimization with constraints',
               2,
               'nitsche:pde:opt:Lagrange',
               'nitsche:pde:opt:Lagrange'),
              ('Example: 1D problem',
               2,
               'nitsche:pde:opt:1Dex',
               'nitsche:pde:opt:1Dex'),
              ('Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec311'),
              ('Nonlinear problems', 0, 'ch:nonlin', 'ch:nonlin'),
              ('Introduction of basic concepts',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              ('Linear versus nonlinear equations', 2, None, '___sec314'),
              ('Algebraic equations', 3, None, '___sec315'),
              ('Differential equations', 3, None, '___sec316'),
              ('A simple model problem', 2, None, '___sec317'),
              ('Linearization by explicit time discretization',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              ('Exact solution of nonlinear algebraic equations',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              ('Linearization', 2, None, '___sec320'),
              ('Picard iteration',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              ('Stopping criteria', 3, None, '___sec322'),
              ('A single Picard iteration', 3, None, '___sec323'),
              ('Linearization by a geometric mean',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              ("Newton's method",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              ('Relaxation',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              ('Implementation and experiments',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              ('Generalization to a general nonlinear ODE',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              ('Explicit time discretization', 3, None, '___sec329'),
              ('Backward Euler discretization', 3, None, '___sec330'),
              ('Crank-Nicolson discretization', 3, None, '___sec331'),
              ('Systems of ODEs',
               2,
               'nonlin:ode:generic:sys:pendulum',
               'nonlin:ode:generic:sys:pendulum'),
              ('Example', 3, None, '___sec333'),
              ('Systems of nonlinear algebraic equations',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              ('Picard iteration',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              ("Newton's method",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              ('Stopping criteria',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              ('Example: A nonlinear ODE model from epidemiology',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              ('Implicit time discretization', 3, None, '___sec339'),
              ('A Picard iteration', 3, None, '___sec340'),
              ("Newton's method", 3, None, '___sec341'),
              ('Linearization at the differential equation level',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              ('Explicit time integration',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              ('Backward Euler scheme and Picard iteration',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              ("Backward Euler scheme and Newton's method",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              ('Linearization via Taylor expansions', 3, None, '___sec346'),
              ('Similarity with Picard iteration', 3, None, '___sec347'),
              ('Implementation', 3, None, '___sec348'),
              ('Derivation with alternative notation', 3, None, '___sec349'),
              ('Crank-Nicolson discretization',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              ('1D stationary nonlinear differential equations',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              ('Solution of algebraic equations', 2, None, '___sec353'),
              ('The structure of the equation system', 3, None, '___sec354'),
              ('Picard iteration', 3, None, '___sec355'),
              ('Mesh with two cells', 3, None, '___sec356'),
              ("Newton's method", 3, None, '___sec357'),
              ('Multi-dimensional PDE problems', 1, None, '___sec358'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:dD:fd',
               'nonlin:alglevel:dD:fd'),
              ('Picard iteration', 3, None, '___sec360'),
              ("Newton's method", 3, None, '___sec361'),
              ('Continuation methods', 2, None, '___sec362'),
              ('Exercises', 1, 'nonlin:exer', 'nonlin:exer'),
              ('Problem 43: Determine if equations are nonlinear or not',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              ('Exercise 44: Derive and investigate a generalized logistic '
               'model',
               2,
               'nonlin:exer:logistic:gen',
               'nonlin:exer:logistic:gen'),
              ("Problem 45: Experience the behavior of Newton's method",
               2,
               'nonlin:exer:Newton:problems1',
               'nonlin:exer:Newton:problems1'),
              ('Problem 46: Compute the Jacobian of a $2\\times 2$ system',
               2,
               'nonlin:exer:vib:Jacobian',
               'nonlin:exer:vib:Jacobian'),
              ('Problem 47: Solve nonlinear equations arising from a vibration '
               'ODE',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              ('Exercise 48: Find the truncation error of arithmetic mean of '
               'products',
               2,
               'nonlin:exer:products:arith:mean',
               'nonlin:exer:products:arith:mean'),
              ("Problem 49: Newton's method for linear problems",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              ('Exercise 50: Discretize a 1D problem with a nonlinear '
               'coefficient',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              ('Exercise 51: Linearize a 1D problem with a nonlinear '
               'coefficient',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              ('Problem 52: Finite differences for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              ('Exercise 53: Discretize a nonlinear 1D heat conduction PDE by '
               'finite differences',
               2,
               'nonlin:exer:1D:heat:nonlinear:fdm',
               'nonlin:exer:1D:heat:nonlinear:fdm'),
              ('Exercise 54: Differentiate a highly nonlinear term',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              ('Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion '
               'equation',
               2,
               'nonlin:exer:2D:heat:nonlinear:fd',
               'nonlin:exer:2D:heat:nonlinear:fd'),
              ('Exercise 56: Find the sparsity of the Jacobian',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              ('Problem 57: Investigate a 1D problem with a continuation '
               'method',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              ('Symbolic nonlinear finite element equations',
               1,
               'nonlin:app:fem_vs_fdm',
               'nonlin:app:fem_vs_fdm'),
              ('Finite element basis functions',
               2,
               'nonlin:alglevel:1D:fe_basis',
               'nonlin:alglevel:1D:fe_basis'),
              ('The group finite element method',
               2,
               'nonlin:alglevel:1D:fe:group',
               'nonlin:alglevel:1D:fe:group'),
              ('Finite element approximation of functions of $u$',
               3,
               None,
               '___sec382'),
              ('Simplified problem', 3, None, '___sec383'),
              ('Integrating nonlinear functions', 3, None, '___sec384'),
              ('Application of the group finite element method',
               3,
               None,
               '___sec385'),
              ('Numerical integration of nonlinear terms by hand',
               2,
               'nonlin:alglevel:1D:fe:f',
               'nonlin:alglevel:1D:fe:f'),
              ('Discretization of a variable coefficient Laplace term',
               2,
               'nonlin:alglevel:1D:fe:Laplace',
               'nonlin:alglevel:1D:fe:Laplace'),
              ('Group finite element method', 3, None, '___sec388'),
              ('Numerical integration at the nodes', 3, None, '___sec389'),
              ('Variational methods for linear systems', 0, 'ch:cg', 'ch:cg'),
              ('Conjugate gradient-like iterative methods',
               1,
               'ch:linalg:CGmethods',
               'ch:linalg:CGmethods'),
              ('The Galerkin method', 2, None, '___sec392'),
              ('The least squares method', 2, None, '___sec393'),
              ('Krylov subspaces', 2, None, '___sec394'),
              ('Computation of the basis vectors', 2, None, '___sec395'),
              ('Computation of a new solution vector', 2, None, '___sec396'),
              ('Summary of the least squares method', 2, None, '___sec397'),
              ('Remark', 3, None, '___sec398'),
              ('Truncation and restart', 2, None, '___sec399'),
              ('Summary of the Galerkin method', 2, None, '___sec400'),
              ('A framework based on the error', 2, None, '___sec401'),
              ('Preconditioning',
               1,
               'ch:linalg2:preconditioning',
               'ch:linalg2:preconditioning'),
              ('Motivation and Basic Principles', 2, None, '___sec403'),
              ('Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec404'),
              ('Classical iterative methods as preconditioners',
               2,
               'ch:linalg:SORprecond',
               'ch:linalg:SORprecond'),
              ('Incomplete factorization preconditioners',
               2,
               'linalg:ILU',
               'linalg:ILU'),
              ('Preconditioners developed for solving PDE problems',
               2,
               None,
               '___sec407'),
              ('Appendix: Useful formulas', 0, 'ch:formulas', 'ch:formulas'),
              ('Finite difference operator notation',
               1,
               'sec:form:fdop',
               'sec:form:fdop'),
              ('Truncation errors of finite difference approximations',
               1,
               'sec:form:truncerr',
               'sec:form:truncerr'),
              ('Finite differences of exponential functions',
               1,
               'sec:form:fdexp',
               'sec:form:fdexp'),
              ('Complex exponentials', 3, None, '___sec412'),
              ('Real exponentials', 3, None, '___sec413'),
              ('Finite differences of $t^n$',
               1,
               'sec:form:fdtn',
               'sec:form:fdtn'),
              ('Software', 2, None, '___sec415'),
              ('References', 1, None, '___sec416')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="fem-book-sol.html">Introduction to Numerical Methods for Variational Problems</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._fem-book-sol002.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#ch:preface" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplementary materials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol003.html#ch:overview" style="font-size: 80%;"><b>Quick overview of the finite element method</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol003.html#ch:approx:global" style="font-size: 80%;"><b>Function approximation by global functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec:plane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of planar vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec:Np1dim" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of general vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin or projection method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:LS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection (or Galerkin) method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on linear approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:LS:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbolic integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fall back on numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:exact1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perfect approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The regression method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overdetermined equation system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The normal equations derived from a least squares principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:illconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ill-conditioning</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fourier series</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:orth" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The interpolation (or collocation) principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of a polynomial</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Successful example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less successful example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remedy for strong oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:Bernstein" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bernstein polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation properties and convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of functions in higher dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D basis functions as tensor products of 1D functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on polynomial basis in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D:global:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:3D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension to 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:linalg1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 1: Linear algebra refresher</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:vec:3Dby2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2: Approximate a three-dimensional vector in a plane</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:parabola_sine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 3: Approximate a parabola by a sine</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:exp:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 4: Approximate the exponential function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:sin:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 5: Approximate the sine function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:sine1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6: Approximate a steep function by sines</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:sine3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 7: Approximate a steep function by sines with boundary adjustment</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 8: Fourier series as a least squares approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 9: Approximate a steep function by Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:Lagrange:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 10: Approximate a steep function by Lagrange polynomials and regression</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#ch:approx:fe" style="font-size: 80%;"><b>Function approximation by finite elements</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:def:elements:nodes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construction principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties of \( \basphi_i \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on quadratic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on linear finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on cubic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:global:linearsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating specific matrix entries</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating a general row in the matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:elementwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of element matrices</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of irregularly numbered elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:mapping" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mapping to a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The coordinate transformation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for the element matrix and vector entries</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for local basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:intg:ref" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on integration over a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:intg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:linsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear system assembly and solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing symbolic approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:collocation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using interpolation instead of least squares</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:numeric" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing numerical approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:A:structure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applications</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sparse matrix storage and solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Comparison of finite elements and finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd:fdproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximation of given functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd:feproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpretation of a finite element approximation in terms of finite difference operators</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:deq:1D:approx:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making finite elements behave as finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical space</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminology</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:terminology" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cells, vertices, and degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:def" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended finite element concept</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error of the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:impl:Hermite" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on cubic Hermite polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#fem:approx:fe:numint1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton-Cotes rules</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gauss-Legendre rules with optimized points</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions over triangles in the physical domain</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element matrices and vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions over triangles in the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Affine mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Isoparametric mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing integrals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fe:approx:fenics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fenics:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on approximation in 2D using FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the code</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating SymPy and FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fenics:2D:2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refined code with curve plotting</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpolation and projection</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution along a line</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating plotting and computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:mesh1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 11: Define nodes and elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:mesh2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 12: Define vertices, cells, and dof maps</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:defmesh:sparsity" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 13: Construct matrix sparsity patterns</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:Asinwt:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 14: Perform symbolic finite element computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:exer:tanh:P1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 15: Approximate a steep function by P1 and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:exer:tanh:P3P4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 16: Approximate a steep function by P3 and P4 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:Asinwt:interpol:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 17: Investigate the approximation error in finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:Heaviside" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 18: Approximate a step function by finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:2Dsines:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 19: 2D approximation with orthogonal functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:1D:trapez" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 20: Use the Trapezoidal rule and P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:1D:P1:vs:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 21: Compare P1 elements and interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:3D:approx3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 22: Implement 3D computations with global basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#fem:approx:fe:exer:1D:simpson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 23: Use Simpson's rule and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol015.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 24: Make a 3D code for Lagrange elements of arbitrary order</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#ch:varform:global" style="font-size: 80%;"><b>Variational formulations with global basis functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:principles" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basic principles for approximating differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:models" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equation models</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:models:simple" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple model problems and their solutions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:residual:min" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming the residual</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method of weighted residuals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#varform:trunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method of weighted residual and the truncation error</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The subdomain collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:ex:sines" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples on using the principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The residual</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec156" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec157" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec158" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Weak form</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:essBC:Bfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec162" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing with global polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:varform:ex:DN:case" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing with Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec164" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the numerical method is exact</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#fem:deq:1D:varform:abstract" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract notation for variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#fem:deq:1D:optimization" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational problems and minimization of functionals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec167" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec168" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The general minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec169" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec170" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimization of the discretized functional</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculus of variations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:deq:1D:varform:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Examples on variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variable coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First-order derivative in the equation and boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:global:deq:1D:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of the algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:deq:1D:code:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extensions of the code for approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fallback to numerical methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example with constant right-hand side</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#ch:convdiff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximations may fail: convection-diffusion</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:BVP1D:class" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 25: Refactor functions into a more general class</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:tension:cable" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 26: Compute the deflection of a cable with sine functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:tension:cable_xn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 27: Compute the deflection of a cable with power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:intg:parts" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 28: Check integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#ch:varform:fe" style="font-size: 80%;"><b>Variational formulations with finite elements</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:fem1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing with finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element mesh and basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:comp:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation in the global physical domain</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:fdm_vs_fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison with a finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:comp:elmwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The integral for the element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The integral for the element vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec194" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Detailed calculations of the element matrix and vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec195" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contributions from the first and last cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec196" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:essBC" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Boundary conditions: specified nonzero value</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;General construction of a boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec199" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing with a finite element-based boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec200" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec201" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations on the reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc:modsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec203" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in the physical system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc:modsys:symm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetric modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:bc:elmat:mod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the element matrix and vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Boundary conditions: specified derivative</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#___sec207" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:uLtest" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary term vanishes because of the test functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:uLmod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary term vanishes because of linear system modifications</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:Aub" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct computation of the global linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#___sec211" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of finite element algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extensions of the code for approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code:fe_sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utilizing a sparse matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#___sec215" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application to our model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:deq:2D:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational formulations in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec217" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#sec:varform:general:convdiff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on a multi-dimensional variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec219" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation to a reference cell in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec220" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec221" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenient formulas for P1 elements in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec222" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A glimpse of the mathematical theory of the finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec223" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec224" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on an abstract variational form and associated spaces</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec225" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assumptions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec226" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Existence and uniqueness</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec227" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec228" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec229" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Best approximation principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec230" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Best approximation property in the norm of the space</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec231" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetric, positive definite coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec232" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent matrix minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec233" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A priori error estimate for the derivative</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec234" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A priori error estimate for the solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation in 2D and 3D via FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec237" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetry</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec239" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The FEniCS solver</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec240" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec241" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving a problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol025.html#___sec242" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Convection-diffusion and Petrov-Galerkin methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol025.html#___sec243" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Summary</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#___sec244" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:2P1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 29: Compute the deflection of a cable with 2 P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 30: Compute the deflection of a cable with 1 P2 element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:stepload" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 31: Compute the deflection of a cable with a step load</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:mesh:nonuniform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 32: Compute with a non-uniform mesh</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:gen:problem1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 33: Solve a 1D finite element problem by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:exact_numerics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 34: Investigate exact finite element solutions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:Poisson:polar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:gen:problem2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 36: Compute with variable coefficients and P1 elements by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:2D:torsion:xy:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 37: Solve a 2D Poisson equation using polynomials and sines</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:fenics:borehole:exer:3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 38: Solve a 3D Laplace problem with FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:fenics:borehole:exer:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 39: Solve a 1D Laplace problem with FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#ch:femtime" style="font-size: 80%;"><b>Time-dependent variational forms</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization in time by a Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec258" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec259" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Space discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec260" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec261" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notation for the solution at recent time levels</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec262" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving the linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec263" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computational algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE:cosex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example using cosinusoidal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE:fdvsP1fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing P1 elements with the finite difference method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec266" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lumping the mass matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization in time by a Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec268" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec269" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec270" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec271" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference operators corresponding to P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dirichlet boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec273" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec274" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec275" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:Dirichlet:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: Oscillating Dirichlet boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:anal" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Accuracy of the finite element solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec278" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methods of analysis</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec279" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fourier components and dispersion relations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec280" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec281" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec282" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing amplification factors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec283" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:exer:diffu:analysis:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 40: Analyze a Crank-Nicolson scheme for the diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#ch:femsys" style="font-size: 80%;"><b>Variational forms for systems of PDEs</b></a></li>
     <!-- navigation toc: --> <li><a href="#fem:sys:vform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="#___sec287" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence of scalar PDEs formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec288" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector PDE formulation</a></li>
     <!-- navigation toc: --> <li><a href="#fem:sys:uT:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A worked example</a></li>
     <!-- navigation toc: --> <li><a href="#___sec290" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Identical function spaces for the unknowns</a></li>
     <!-- navigation toc: --> <li><a href="#___sec291" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form of each individual PDE</a></li>
     <!-- navigation toc: --> <li><a href="#___sec292" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compound scalar variational form</a></li>
     <!-- navigation toc: --> <li><a href="#___sec293" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decoupled linear systems</a></li>
     <!-- navigation toc: --> <li><a href="#___sec294" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coupled linear systems</a></li>
     <!-- navigation toc: --> <li><a href="#___sec295" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Different function spaces for the unknowns</a></li>
     <!-- navigation toc: --> <li><a href="#femsys:cooling:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computations in 1D</a></li>
     <!-- navigation toc: --> <li><a href="#fem:sys:up:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Another example in 1D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec298" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#femsys:exer:cooling:1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 41: Estimate order of convergence for the Cooling law</a></li>
     <!-- navigation toc: --> <li><a href="#femsys:exer:cooling:2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 42: Estimate order of convergence for the Cooling law</a></li>
     <!-- navigation toc: --> <li><a href="#ch:nitsche" style="font-size: 80%;"><b>Flexible implementations of boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:fxy:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization with constraint</a></li>
     <!-- navigation toc: --> <li><a href="#___sec303" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elimination of variables</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:fxy:opt:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange multiplier method</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:fxy:opt:penalty" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Penalty method</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:pde:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of functionals</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:pde:opt:varcalculus" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classical calculus of variations</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:pde:opt:penalty" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Penalty and Nitsche's methods for optimization with constraints</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:pde:opt:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange multiplier method for optimization with constraints</a></li>
     <!-- navigation toc: --> <li><a href="#nitsche:pde:opt:1Dex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: 1D problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec311" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: adding a constraint in a Neumann problem</a></li>
     <!-- navigation toc: --> <li><a href="#ch:nonlin" style="font-size: 80%;"><b>Nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Introduction of basic concepts</a></li>
     <!-- navigation toc: --> <li><a href="#___sec314" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear versus nonlinear equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec315" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec316" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec317" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple model problem</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:roots" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact solution of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec320" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="#___sec322" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="#___sec323" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A single Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by a geometric mean</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:relaxation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:timediscrete:logistic:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation and experiments</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:ode:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization to a general nonlinear ODE</a></li>
     <!-- navigation toc: --> <li><a href="#___sec329" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec330" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec331" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:ode:generic:sys:pendulum" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Systems of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="#___sec333" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Systems of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:terminate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:SI" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: A nonlinear ODE model from epidemiology</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec339" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec340" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec341" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization at the differential equation level</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:explicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec346" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization via Taylor expansions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec347" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity with Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec348" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec349" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation with alternative notation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Picard:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#nonlin:alglevel:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;1D stationary nonlinear differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#nonlin:alglevel:1D:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec353" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution of algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec354" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the equation system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec355" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec356" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh with two cells</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec357" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec358" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multi-dimensional PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#nonlin:alglevel:dD:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec360" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec361" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec362" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continuation methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:lin:vs:nonlin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 43: Determine if equations are nonlinear or not</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:logistic:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 44: Derive and investigate a generalized logistic model</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:Newton:problems1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 45: Experience the behavior of Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:vib:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 46: Compute the Jacobian of a \( 2\times 2 \) system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:vib:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 47: Solve nonlinear equations arising from a vibration ODE</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:products:arith:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 48: Find the truncation error of arithmetic mean of products</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:Newton:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 49: Newton's method for linear problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:1pu2:fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 50: Discretize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:1pu2:PicardNewton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 51: Linearize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:fu:discretize:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 52: Finite differences for the 1D Bratu problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:heat:nonlinear:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 53: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:grad:pow:term" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 54: Differentiate a highly nonlinear term</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:2D:heat:nonlinear:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:sparsity:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 56: Find the sparsity of the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:continuation:1DnNflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 57: Investigate a 1D problem with a continuation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:app:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Symbolic nonlinear finite element equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe_basis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe:group" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec382" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element approximation of functions of \( u \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec383" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec384" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating nonlinear functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec385" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application of the group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe:f" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration of nonlinear terms by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe:Laplace" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization of a variable coefficient Laplace term</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec388" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec389" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration at the nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:cg" style="font-size: 80%;"><b>Variational methods for linear systems</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg:CGmethods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Conjugate gradient-like iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec392" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec393" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec394" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Krylov subspaces</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec395" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation of the basis vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec396" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation of a new solution vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec397" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec398" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec399" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation and restart</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec400" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of the Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec401" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A framework based on the error</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg2:preconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Preconditioning</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec403" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motivation and Basic Principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec404" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use of the preconditioning matrix in the iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg:SORprecond" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classical iterative methods as preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#linalg:ILU" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incomplete factorization preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec407" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preconditioners developed for solving PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#ch:formulas" style="font-size: 80%;"><b>Appendix: Useful formulas</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdop" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference operator notation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:truncerr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors of finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdexp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of exponential functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec412" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complex exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec413" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Real exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdtn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of \( t^n \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec415" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol037.html#___sec416" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0028"></a>
<!-- !split -->

<center><h1 id="ch:femsys" class="anchor">Variational forms for systems of PDEs</h1></center> <!-- chapter heading -->

<p>
Many mathematical models involve \( m+1 \) unknown functions
governed by a system of \( m+1 \) differential equations. In abstract form
we may denote the unknowns by \( u^{(0)},\ldots,
u^{(m)} \) and write the governing equations as

$$
\begin{align*}
\mathcal{L}_0(u^{(0)},\ldots,u^{(m)}) &= 0,\\ 
&\vdots\\ 
\mathcal{L}_{m}(u^{(0)},\ldots,u^{(m)}) &= 0,
\end{align*}
$$

where \( \mathcal{L}_i \) is some differential operator defining differential
equation number \( i \).

<h1 id="fem:sys:vform" class="anchor">Variational forms</h1>

<p>
There are basically two ways of formulating a variational form
for a system of differential equations. The first method treats
each equation independently as a scalar equation, while the other
method views the total system as a vector equation with a vector function
as unknown.

<h2 id="___sec287" class="anchor">Sequence of scalar PDEs formulation </h2>

<p>
Let us start with the approach that treats one equation at a time.
We multiply equation number \( i \) by
some test function \( v^{(i)}\in V^{(i)} \) and integrate over the domain:

$$
\begin{align}
\int_\Omega \mathcal{L}^{(0)}(u^{(0)},\ldots,u^{(m)}) v^{(0)}\dx &= 0,
\tag{7.1}\\ 
&\vdots
\tag{7.2}\\ 
\int_\Omega \mathcal{L}^{(m)}(u^{(0)},\ldots,u^{(m)}) v^{(m)}\dx &= 0
\tag{7.3}
\tp
\end{align}
$$

Terms with second-order derivatives may be integrated by parts, with
Neumann conditions inserted in boundary integrals.
Let

$$ V^{(i)} = \hbox{span}\{\baspsi_0^{(i)},\ldots,\baspsi_{N_i}^{(i)}\},$$

such that

$$ u^{(i)} = B^{(i)}(\x) + \sum_{j=0}^{N_i} c_j^{(i)} \baspsi_j^{(i)}(\x),
$$

where \( B^{(i)} \) is a boundary function to handle nonzero Dirichlet conditions.
Observe that different unknowns may live in different spaces with different
basis functions and numbers of degrees of freedom.

<p>
From the \( m \) equations in the variational forms we can derive
\( m \) coupled systems of algebraic equations for the
\( \Pi_{i=0}^{m} N_i \) unknown coefficients \( c_j^{(i)} \), \( j=0,\ldots,N_i \),
\( i=0,\ldots,m \).

<h2 id="___sec288" class="anchor">Vector PDE formulation </h2>

<p>
The alternative method for deriving a variational form for a system of
differential equations introduces a vector of unknown functions

$$ \u = (u^{(0)},\ldots,u^{(m)}),$$

a vector of test functions

$$ \v = (v^{(0)},\ldots,v^{(m)}),$$

with

$$ \u, \v \in  \V = V^{(0)}\times \cdots \times V^{(m)}
\tp $$

With nonzero Dirichlet conditions, we have a vector
\( \boldsymbol{B} = (B^{(0)},\ldots,B^{(m)}) \) with boundary functions and then
it is \( \u - \boldsymbol{B} \) that lies in \( \V \), not \( \u \) itself.

<p>
The governing system of differential equations is written

$$ \boldsymbol{\mathcal{L}}(\u ) = 0,$$

where

$$ \boldsymbol{\mathcal{L}}(\u ) = (\mathcal{L}^{(0)}(\u),\ldots, \mathcal{L}^{(m)}(\u))
\tp $$

The variational form is derived by taking the inner product of
the vector of equations and the test function vector:

$$
\begin{equation}
\int_\Omega \boldsymbol{\mathcal{L}}(\u )\cdot\v = 0\quad\forall\v\in\V\tp
\tag{7.4}
\end{equation}
$$

<p>
Observe that <a href="#mjx-eqn-7.4">(7.4)</a> is one scalar equation. To derive
systems of algebraic equations for the unknown coefficients in the
expansions of the unknown functions, one chooses \( m \) linearly
independent \( \v \) vectors to generate \( m \) independent variational forms
from <a href="#mjx-eqn-7.4">(7.4)</a>.  The particular choice \( \v =
(v^{(0)},0,\ldots,0) \) recovers <a href="#mjx-eqn-7.1">(7.1)</a>, \( \v =
(0,\ldots,0,v^{(m)}) \) recovers <a href="#mjx-eqn-7.3">(7.3)</a>, and \( \v =
(0,\ldots,0,v^{(i)},0,\ldots,0) \) recovers the variational form number
\( i \), \( \int_\Omega \mathcal{L}^{(i)} v^{(i)}\dx =0 \), in
<a href="#mjx-eqn-7.1">(7.1)</a>-<a href="#mjx-eqn-7.3">(7.3)</a>.

<h1 id="fem:sys:uT:ex" class="anchor">A worked example</h1>

<p>
We now consider a specific system of two partial differential equations
in two space dimensions:

$$
\begin{align}
\mu \nabla^2 w &= -\beta,
\tag{7.5}\\ 
\kappa\nabla^2 T &= - \mu ||\nabla w||^2
\tp
\tag{7.6}
\end{align}
$$

The unknown functions \( w(x,y) \) and \( T(x,y) \) are defined in a domain \( \Omega \),
while \( \mu \), \( \beta \),
and \( \kappa \) are given constants. The norm in
<a href="#mjx-eqn-7.6">(7.6)</a> is the standard Euclidean norm:

$$ ||\nabla w||^2 = \nabla w\cdot\nabla w = w_x^2 + w_y^2
\tp $$

<p>
The boundary conditions associated with
<a href="#mjx-eqn-7.5">(7.5)</a>-<a href="#mjx-eqn-7.6">(7.6)</a> are \( w=0 \) on
\( \partial\Omega \) and \( T=T_0 \) on \( \partial\Omega \).
Each of the equations <a href="#mjx-eqn-7.5">(7.5)</a> and <a href="#mjx-eqn-7.6">(7.6)</a>
needs one condition at each point on the boundary.

<p>
The system <a href="#mjx-eqn-7.5">(7.5)</a>-<a href="#mjx-eqn-7.6">(7.6)</a> arises
from fluid flow in a straight pipe, with the \( z \) axis in the direction
of the pipe. The domain \( \Omega \) is a cross section of the pipe, \( w \)
is the velocity in the \( z \) direction, \( \mu \)
is the viscosity of the fluid, \( \beta \) is the pressure gradient along
the pipe, \( T \) is the temperature,
and \( \kappa \) is the heat conduction coefficient of the
fluid. The equation <a href="#mjx-eqn-7.5">(7.5)</a> comes from the Navier-Stokes
equations, and <a href="#mjx-eqn-7.6">(7.6)</a> follows from the energy equation.
The term \( - \mu ||\nabla w||^2 \) models heating of the fluid
due to internal friction.

<p>
Observe that the system <a href="#mjx-eqn-7.5">(7.5)</a>-<a href="#mjx-eqn-7.6">(7.6)</a> has
only a one-way coupling: \( T \) depends on \( w \), but \( w \) does not depend on
\( T \). Hence, we can solve <a href="#mjx-eqn-7.5">(7.5)</a> with respect
to \( w \) and then <a href="#mjx-eqn-7.6">(7.6)</a> with respect to \( T \).
Some may argue that this is not a real system of PDEs, but just two scalar
PDEs. Nevertheless, the one-way coupling
is convenient when comparing different variational forms
and different implementations.

<h1 id="___sec290" class="anchor">Identical function spaces for the unknowns </h1>

<p>
Let us first apply the same function space \( V \) for \( w \) and \( T \)
(or more precisely, \( w\in V \) and \( T-T_0 \in V \)).
With

$$ V = \hbox{span}\{\baspsi_0(x,y),\ldots,\baspsi_N(x,y)\}, $$

we write

$$
\begin{equation}
w = \sum_{j=0}^N c^{(w)}_j \baspsi_j,\quad T = T_0 + \sum_{j=0}^N c^{(T)}_j
\baspsi_j\tp
\tag{7.7}
\end{equation}
$$

Note that \( w \) and \( T \) in <a href="#mjx-eqn-7.5">(7.5)</a>-<a href="#mjx-eqn-7.6">(7.6)</a>
denote the exact solution of the PDEs, while \( w \) and \( T \)
in <a href="#mjx-eqn-7.7">(7.7)</a> are the discrete functions that approximate
the exact solution. It should be clear from the context whether a
symbol means the exact or approximate solution, but when we need both
at the same time, we use a subscript e to denote the exact solution.

<h2 id="___sec291" class="anchor">Variational form of each individual PDE </h2>

<p>
Inserting the expansions <a href="#mjx-eqn-7.7">(7.7)</a>
in the governing PDEs, results in a residual in each equation,

$$
\begin{align}
R_w &= \mu \nabla^2 w + \beta,
\tag{7.8}\\ 
R_T &= \kappa\nabla^2 T + \mu ||\nabla w||^2
\tp
\tag{7.9}
\end{align}
$$

A Galerkin method demands \( R_w \) and \( R_T \) do be orthogonal to \( V \):

$$
\begin{align*}
\int_\Omega R_w v \dx &=0\quad\forall v\in V,\\ 
\int_\Omega R_T v \dx &=0\quad\forall v\in V
\tp
\end{align*}
$$

Because of the Dirichlet conditions, \( v=0 \) on \( \partial\Omega \).
We integrate the Laplace terms by parts and note that the boundary terms
vanish since \( v=0 \) on \( \partial\Omega \):

$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v \dx &= \int_\Omega \beta v\dx
\quad\forall v\in V,
\tag{7.10}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v\dx \quad\forall v\in V
\tag{7.11}
\tp
\end{align}
$$

The equation \( R_w \) in <a href="#mjx-eqn-7.8">(7.8)</a> is linear
in \( w \), while the equation \( R_T \) in <a href="#mjx-eqn-7.9">(7.9)</a>
is linear in \( T \) and nonlinear in \( w \).

<h2 id="___sec292" class="anchor">Compound scalar variational form </h2>

<p>
The alternative way of deriving the variational from is to
introduce a test vector function \( \v\in\V = V\times V \) and take
the inner product of \( \v \) and the residuals, integrated over the domain:

$$ \int_{\Omega} (R_w, R_T)\cdot\v \dx = 0\quad\forall\v\in\V
\tp $$

With \( \v = (v_0,v_1) \) we get

$$ \int_{\Omega} (R_w v_0 + R_T v_1) \dx = 0\quad\forall\v\in\V
\tp $$

Integrating the Laplace terms by parts results in

$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v_0 + \kappa\nabla T\cdot\nabla v_1)\dx
= \int_\Omega (\beta v_0 + \mu\nabla w\cdot\nabla w\, v_1)\dx,
\quad\forall \v\in\V
\tp
\tag{7.12}
\end{equation}
$$

Choosing \( v_0=v \) and \( v_1=0 \) gives the variational form
<a href="#mjx-eqn-7.10">(7.10)</a>, while \( v_0=0 \) and \( v_1=v \) gives
<a href="#mjx-eqn-7.11">(7.11)</a>.

<p>
With the inner product notation, \( (p,q) = \int_\Omega pq\dx \), we
can alternatively write <a href="#mjx-eqn-7.10">(7.10)</a> and
<a href="#mjx-eqn-7.11">(7.11)</a> as

$$
\begin{align*}
 (\mu\nabla w,\nabla v) &= (\beta, v)
\quad\forall v\in V,\\ 
(\kappa \nabla T,\nabla v) &= (\mu\nabla w\cdot\nabla w, v)\quad\forall v\in V,
\end{align*}
$$

or since \( \mu \) and \( \kappa \) are considered constant,

$$
\begin{align}
\mu (\nabla w,\nabla v) &= (\beta, v)
\quad\forall v\in V,
\tag{7.13}\\ 
\kappa(\nabla T,\nabla v) &= \mu(\nabla w\cdot\nabla w, v)\quad\forall v\in V
\tag{7.14}
\tp
\end{align}
$$

Note that the left-hand side of <a href="#mjx-eqn-7.13">(7.13)</a> is
again linear in \( w \), the left-hand side
of <a href="#mjx-eqn-7.14">(7.14)</a> is linear in \( T \)
and the nonlinearity of \( w \) appears in the right-hand side
of  <a href="#mjx-eqn-7.14">(7.14)</a>

<h2 id="___sec293" class="anchor">Decoupled linear systems </h2>

<p>
The linear systems governing the coefficients \( c_j^{(w)} \) and
\( c_j^{(T)} \), \( j=0,\ldots,N \), are derived by inserting the
expansions <a href="#mjx-eqn-7.7">(7.7)</a> in <a href="#mjx-eqn-7.10">(7.10)</a>
and <a href="#mjx-eqn-7.11">(7.11)</a>, and choosing \( v=\baspsi_i \) for
\( i=0,\ldots,N \). The result becomes

$$
\begin{align}
\sum_{j=0}^N A^{(w)}_{i,j} c^{(w)}_j &= b_i^{(w)},\quad i=0,\ldots,N,
\tag{7.15}\\ 
\sum_{j=0}^N A^{(T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{7.16}\\ 
A^{(w)}_{i,j} &= \mu(\nabla \baspsi_j,\nabla \baspsi_i),
\tag{7.17}\\ 
b_i^{(w)} &= (\beta, \baspsi_i),
\tag{7.18}\\ 
A^{(T)}_{i,j} &= \kappa(\nabla \baspsi_j,\nabla \baspsi_i),
\tag{7.19}\\ 
b_i^{(T)} &= \mu((\sum_j c^{(w)}_j\nabla\baspsi_j)\cdot (\sum_k
c^{(w)}_k\nabla\baspsi_k), \baspsi_i)
\tp
\tag{7.20}
\end{align}
$$

<p>
It can also be instructive to write the linear systems using matrices
and vectors. Define \( K \) as the matrix corresponding to the Laplace
operator \( \nabla^2 \). That is, \( K_{i,j} = (\nabla \baspsi_j,\nabla \baspsi_i) \).
Let us introduce the vectors

$$
\begin{align*}
b^{(w)} &= (b_0^{(w)},\ldots,b_{N}^{(w)}),\\ 
b^{(T)} &= (b_0^{(T)},\ldots,b_{N}^{(T)}),\\ 
c^{(w)} &= (c_0^{(w)},\ldots,c_{N}^{(w)}),\\ 
c^{(T)} &= (c_0^{(T)},\ldots,c_{N}^{(T)})\tp
\end{align*}
$$

The system <a href="#mjx-eqn-7.15">(7.15)</a>-<a href="#mjx-eqn-7.16">(7.16)</a>
can now be expressed in matrix-vector form as

$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},
\tag{7.21}\\ 
\kappa K c^{(T)} &= b^{(T)}\tp
\tag{7.22}
\end{align}
$$

<p>
We can solve the first system for \( c^{(w)} \), and then
the right-hand side \( b^{(T)} \) is known such that we can
solve the second system for \( c^{(T)} \). Hence, the
decoupling of the unknowns \( w \) and \( T \) reduces the
system of nonlinear PDEs to two linear PDEs.

<h2 id="___sec294" class="anchor">Coupled linear systems </h2>

<p>
Despite the fact that \( w \) can be computed first, without knowing \( T \),
we shall now pretend that \( w \) and \( T \) enter a two-way coupling such
that we need to derive the
algebraic equations as <em>one system</em> for all the unknowns
\( c_j^{(w)} \) and \( c_j^{(T)} \), \( j=0,\ldots,N \). This system is
nonlinear in \( c_j^{(w)} \) because of the \( \nabla w\cdot\nabla w \) product.
To remove this nonlinearity, imagine that we introduce an iteration
method where we replace \( \nabla w\cdot\nabla w \) by
\( \nabla w_{-}\cdot\nabla w \), \( w_{-} \) being the \( w \)
computed in the previous iteration. Then the term
\( \nabla w_{-}\cdot\nabla w \) is linear in \( w \) since \( w_{-} \) is
known. The total linear system becomes

$$
\begin{align}
\sum_{j=0}^N A^{(w,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(w,T)}_{i,j} c^{(T)}_j
&= b_i^{(w)},\quad i=0,\ldots,N,
\tag{7.23}\\ 
\sum_{j=0}^N A^{(T,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(T,T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{7.24}\\ 
A^{(w,w)}_{i,j} &= \mu(\nabla \baspsi_j,\nabla \baspsi_i),
\tag{7.25}\\ 
A^{(w,T)}_{i,j} &= 0,
\tag{7.26}\\ 
b_i^{(w)} &= (\beta, \baspsi_i),
\tag{7.27}\\ 
A^{(w,T)}_{i,j} &= \mu((\nabla w_{-})\cdot\nabla\baspsi_j), \baspsi_i),
\tag{7.28}\\ 
A^{(T,T)}_{i,j} &= \kappa(\nabla \baspsi_j,\nabla \baspsi_i),
\tag{7.29}\\ 
b_i^{(T)} &= 0
\tp
\tag{7.30}
\end{align}
$$

This system can alternatively be written in matrix-vector form as

$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},
\tag{7.31}\\ 
L c^{(w)} + \kappa K c^{(T)} & =0,
\tag{7.32}
\end{align}
$$

with \( L \) as the matrix from the \( \nabla w_{-}\cdot\nabla \) operator:
\( L_{i,j} = A^{(w,T)}_{i,j} \). The matrix \( K \) is \( K_{i,j} =
A^{(w,w)}_{i,j} = A^{(T,T)}_{i,j} \).

<p>
The matrix-vector equations are often conveniently written in block form:

$$
\left(\begin{array}{cc}
\mu K & 0\\ 
L & \kappa K
\end{array}\right)
\left(\begin{array}{c}
c^{(w)}\\ 
c^{(T)}
\end{array}\right) =
\left(\begin{array}{c}
b^{(w)}\\ 
0
\end{array}\right),
$$

<p>
Note that in the general case where all unknowns enter all equations,
we have to solve the compound system
<a href="#mjx-eqn-7.23">(7.23)</a>-<a href="#mjx-eqn-7.24">(7.24)</a> since
then we cannot utilize the special property that
<a href="#mjx-eqn-7.15">(7.15)</a> does not involve \( T \) and can be solved
first.

<p>
When the viscosity depends on the temperature, the
\( \mu\nabla^2w \) term must be replaced by \( \nabla\cdot (\mu(T)\nabla w) \),
and then \( T \) enters the equation for \( w \). Now we have a two-way coupling
since both equations contain \( w \) and \( T \) and therefore
must be solved simultaneously.
The equation \( \nabla\cdot (\mu(T)\nabla w)=-\beta \) is nonlinear,
and if some iteration procedure is invoked, where we use a previously
computed \( T_{-} \) in the viscosity (\( \mu(T_{-}) \)), the coefficient is known,
and the equation involves only one unknown, \( w \). In that case we are
back to the one-way coupled set of PDEs.

<p>
We may also formulate our PDE system as a vector equation. To this end,
we introduce the vector of unknowns \( \u = (u^{(0)},u^{(1)}) \),
where \( u^{(0)}=w \) and \( u^{(1)}=T \). We then have

$$
\nabla^2 \u = \left(\begin{array}{cc}
-{\mu}^{-1}{\beta}\\ 
-{\kappa}^{-1}\mu \nabla u^{(0)}\cdot\nabla u^{(0)}
\end{array}\right)\tp
$$

<h1 id="___sec295" class="anchor">Different function spaces for the unknowns </h1>

<p>
It is easy to generalize the previous formulation to the case where
\( w\in V^{(w)} \) and \( T\in V^{(T)} \), where \( V^{(w)} \) and \( V^{(T)} \)
can be different spaces with different numbers of degrees of freedom.
For example, we may use quadratic basis functions for \( w \) and linear
for \( T \). Approximation of the unknowns by different finite element
spaces is known as <em>mixed finite element methods</em>.

<p>
We write

$$
\begin{align*}
V^{(w)} &= \hbox{span}\{\baspsi_0^{(w)},\ldots,\baspsi_{N_w}^{(w)}\},\\ 
V^{(T)} &= \hbox{span}\{\baspsi_0^{(T)},\ldots,\baspsi_{N_T}^{(T)}\}
\tp
\end{align*}
$$

The next step is to
multiply <a href="#mjx-eqn-7.5">(7.5)</a> by a test function \( v^{(w)}\in V^{(w)} \)
and <a href="#mjx-eqn-7.6">(7.6)</a> by a \( v^{(T)}\in V^{(T)} \), integrate by
parts and arrive at

$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v^{(w)} \dx &= \int_\Omega \beta v^{(w)}\dx
\quad\forall v^{(w)}\in V^{(w)},
\tag{7.33}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v^{(T)} \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v^{(T)}\dx \quad\forall v^{(T)}\in V^{(T)}
\tag{7.34}
\tp
\end{align}
$$

<p>
The compound scalar variational formulation applies a test vector function
\( \v = (v^{(w)}, v^{(T)}) \) and reads

$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v^{(w)} +
\kappa\nabla T\cdot\nabla v^{(T)})\dx
= \int_\Omega (\beta v^{(w)} + \mu\nabla w\cdot\nabla w\, v^{(T)})\dx,
\tag{7.35}
\end{equation}
$$

valid \( \forall \v\in\V = V^{(w)}\times V^{(T)} \).

<p>
As earlier, we may decoupled the system in terms
of two linear PDEs as we did with
<a href="#mjx-eqn-7.15">(7.15)</a>-<a href="#mjx-eqn-7.16">(7.16)</a>
or linearize the coupled system by introducing the previous
iterate \( w_{-} \) as in
<a href="#mjx-eqn-7.23">(7.23)</a>-<a href="#mjx-eqn-7.24">(7.24)</a>.
However, we need to distinguish between \( \baspsi_i^{(w)} \)
and \( \baspsi_i^{(T)} \), and the range in the sums over \( j \)
must match the number of degrees of freedom in the spaces \( V^{(w)} \)
and \( V^{(T)} \). The formulas become

$$
\begin{align}
\sum_{j=0}^{N_w} A^{(w)}_{i,j} c^{(w)}_j &= b_i^{(w)},\quad i=0,\ldots,N_w,
\tag{7.36}\\ 
\sum_{j=0}^{N_T} A^{(T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N_T,
\tag{7.37}\\ 
A^{(w)}_{i,j} &= \mu(\nabla \baspsi_j^{(w)},\nabla \baspsi_i^{(w)}),
\tag{7.38}\\ 
b_i^{(w)} &= (\beta, \baspsi_i^{(w)}),
\tag{7.39}\\ 
A^{(T)}_{i,j} &= \kappa(\nabla \baspsi_j^{(T)},\nabla \baspsi_i^{(T)}),
\tag{7.40}\\ 
b_i^{(T)} &= \mu(\sum_{j=0}^{N_w} c^{(w)}_j\nabla\baspsi_j^{(w)})\cdot (\sum_{k=0}^{N_w}
c^{(w)}_k\nabla\baspsi_k^{(w)}) , \baspsi_i^{(T)})
\tp
\tag{7.41}
\end{align}
$$

<p>
In the case we formulate one compound linear system involving
both \( c^{(w)}_j \), \( j=0,\ldots,N_w \), and \( c^{(T)}_j \), \( j=0,\ldots,N_T \),
<a href="#mjx-eqn-7.23">(7.23)</a>-<a href="#mjx-eqn-7.24">(7.24)</a>
becomes

$$
\begin{align}
\sum_{j=0}^{N_w} A^{(w,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^{N_T} A^{(w,T)}_{i,j} c^{(T)}_j
&= b_i^{(w)},\quad i=0,\ldots,N_w,
\tag{7.42}\\ 
\sum_{j=0}^{N_w} A^{(T,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^{N_T} A^{(T,T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N_T,
\tag{7.43}\\ 
A^{(w,w)}_{i,j} &= \mu(\nabla \baspsi_j^{(w)},\nabla \baspsi_i^{(w)}),
\tag{7.44}\\ 
A^{(w,T)}_{i,j} &= 0,
\tag{7.45}\\ 
b_i^{(w)} &= (\beta, \baspsi_i^{(w)}),
\tag{7.46}\\ 
A^{(w,T)}_{i,j} &= \mu (\nabla w_{-}\cdot\nabla\baspsi_j^{(w)}), \baspsi_i^{(T)}),
\tag{7.47}\\ 
A^{(T,T)}_{i,j} &= \kappa(\nabla \baspsi_j^{(T)},\nabla \baspsi_i^{(T)}),
\tag{7.48}\\ 
b_i^{(T)} &= 0
\tp
\tag{7.49}
\end{align}
$$

Here, we have again performed a linearization by employing a previous iterate \( w_{-} \).
The corresponding block form

$$
\left(\begin{array}{cc}
\mu K^{(w)} & 0\\ 
L & \kappa K^{(T)}
\end{array}\right)
\left(\begin{array}{c}
c^{(w)}\\ 
c^{(T)}
\end{array}\right) =
\left(\begin{array}{c}
b^{(w)}\\ 
0
\end{array}\right),
$$

has square and rectangular block matrices: \( K^{(w)} \) is \( N_w\times N_w \),
\( K^{(T)} \) is \( N_T\times N_T \), while \( L \) is \( N_T\times N_w \),

<h1 id="femsys:cooling:1D" class="anchor">Computations in 1D</h1>
<!-- 2DO -->
<!-- show analytical solution in [0,H] -->
<!-- use global polynomials (x^i(H-x)), exact sol -->
<!-- compute uncoupled and coupled discrete systems, N=4 -->
<!-- note: coupled can use exact w_{-} -->
<!-- P1-P1, n elements, 2 elements as special case -->
<!-- uncoupled and coupled (can use exercises for variants) -->
<!-- P1 for w, P2 for T or P4 for T -->
<!-- similar computations for circle can be done as project -->
<!-- extensions to time-dep versions in projects -->
<!-- any geophysical applications? flowing ice sheet ("half channel") and -->
<!-- temp gradient through, check with Jed -->
<!-- the time-dependent system can be introduced in diffusion and -->
<!-- a finite difference scheme can be devised -->

<p>
We can reduce the system <a href="#mjx-eqn-7.5">(7.5)</a>-<a href="#mjx-eqn-7.6">(7.6)</a>
to one space dimension, which corresponds to flow in a channel between
two flat plates. Alternatively, one may consider flow in a circular
pipe, introduce cylindrical coordinates, and utilize the radial symmetry
to reduce the equations to a one-dimensional problem in the radial
coordinate. The former model becomes

$$
\begin{align}
\mu w_{xx} &= -\beta,
\tag{7.50}\\ 
\kappa T_{xx} &= - \mu w_x^2,
\tag{7.51}
\end{align}
$$

while the model in the radial coordinate \( r \) reads

$$
\begin{align}
\mu\frac{1}{r}\frac{d}{dr}\left( r\frac{dw}{dr}\right) &= -\beta,
\tag{7.52}\\ 
\kappa \frac{1}{r}\frac{d}{dr}\left( r\frac{dT}{dr}\right) &= - \mu \left(
\frac{dw}{dr}\right)^2
\tp
\tag{7.53}
\end{align}
$$

<p>
The domain for <a href="#mjx-eqn-7.50">(7.50)</a>-<a href="#mjx-eqn-7.51">(7.51)</a>
is \( \Omega = [0,H] \), with boundary conditions \( w(0)=w(H)=0 \) and
\( T(0)=T(H)=T_0 \). For
<a href="#mjx-eqn-7.52">(7.52)</a>-<a href="#mjx-eqn-7.53">(7.53)</a> the domain
is \( [0,R] \) (\( R \) being the radius of the pipe) and the boundary
conditions are \( du/dr = dT/dr =0 \) for \( r=0 \), \( u(R)=0 \), and \( T(R)=T_0 \).

<p>
The exact solutions, \( w_e \) and \( T_e \),  to <a href="#mjx-eqn-7.50">(7.50)</a>
and <a href="#mjx-eqn-7.51">(7.51)</a> are computed
as
$$
\begin{align*}
w_{e,x} &= - \int \frac{\beta}{\mu} \dx + C_w, \\ 
w_e &= \int w_{e,x} \dx + D_w, \\ 
T_{e,x} &= - \int \mu w_{e,x}^2 \dx + C_T,\\ 
T_e &= \int T_{e,x} \dx + D_T, \\ 
\end{align*}
$$

where we determine the constants \( C_w \), \( D_w \), \( C_T \), and \( D_T \)
by the boundary conditions \( w(0)=w(H)=0 \) and
\( T(0)=T(H)=T_0 \). The calculations
may be performed in  <code>sympy</code> as
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

x, mu, beta, k, H, C, D, T0 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&quot;x mu beta k H C D T0&quot;</span>)
wx <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(<span style="color: #666666">-</span>beta<span style="color: #666666">/</span>mu, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> C
w <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(wx, x) <span style="color: #666666">+</span> D
s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve([w<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)<span style="color: #666666">-0</span>,  <span style="color: #408080; font-style: italic"># x=0 condition</span>
               w<span style="color: #666666">.</span>subs(x,H)<span style="color: #666666">-0</span>],  <span style="color: #408080; font-style: italic"># x=H condition</span>
               [C, D])       <span style="color: #408080; font-style: italic"># unknowns</span>
w <span style="color: #666666">=</span> w<span style="color: #666666">.</span>subs(C, s[C])<span style="color: #666666">.</span>subs(D, s[D])
w <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(w))

Tx <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(<span style="color: #666666">-</span>mu<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(w,x)<span style="color: #666666">**2</span>, x) <span style="color: #666666">+</span> C
T <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(Tx, x) <span style="color: #666666">+</span> D
s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve([T<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)<span style="color: #666666">-</span>T0,  <span style="color: #408080; font-style: italic"># x=0 condition</span>
               T<span style="color: #666666">.</span>subs(x, H)<span style="color: #666666">-</span>T0],  <span style="color: #408080; font-style: italic"># x=H condition</span>
               [C, D])       <span style="color: #408080; font-style: italic"># unknowns</span>
T <span style="color: #666666">=</span> T<span style="color: #666666">.</span>subs(C, s[C])<span style="color: #666666">.</span>subs(D, s[D])
T <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(T))
</pre></div>
<p>
We find that the solutions are
$$
\begin{align*}
w_e(x) &= \frac{\beta x}{2 \mu} \left(H - x\right), \\ 
T_e(x) &= \frac{\beta^{2}}{\mu} \left(\frac{H^{3} x}{24}  - \frac{H^{2}}{8} x^{2} + \frac{H}{6} x^{3} - \frac{ x^{4}}{12}\right)  + T_{0} \tp
\end{align*}
$$

<p>
The figure <a href="#femsys:cooling:w:plot">79</a> shows \( w \) computed by the finite element method using the  decoupled
approach with P1 elements, 
that is; implementing <a href="#mjx-eqn-7.15">(7.15)</a>. The analytical solution \( w_e \) is a quadratic
polynomial.  The linear finite elements result in a poor approximation on the
coarse meshes, \( N=2 \) and \( N=4 \), but the approximation 
improves fast and already at \( N=8 \) the 
approximation appears adequate. 
The figure <a href="#femsys:cooling:w:plot">79</a> shows the approximation of \( T \) and also here
we see that the fourth order polynomial is poorly approximated at coarse resolution, but
that the approximation quickly improves.

<p>
<center> <!-- figure label: --> <div id="femsys:cooling:w:plot"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 79:  The solution \( w \) of <a href="#mjx-eqn-7.50">(7.50)</a> with \( \beta=\mu=1 \) for different mesh resolutions.  <!-- caption label: femsys:cooling:w:plot --> </p></center>
<p><img src="fig/cooling_w.png" align="bottom" width=800></p>
</center>

<p>
The figure <a href="#femsys:cooling:T:plot">80</a> shows \( T \) for different resolutions. The same tendency is apparent
although the coarse grid solutions are worse for \( T \) than for \( w \). The solutions at \( N=16 \) and \( N=32 \), however, 
appear almost identical.

<p>
<center> <!-- figure label: --> <div id="femsys:cooling:T:plot"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 80:  The solution \( T \) of <a href="#mjx-eqn-7.51">(7.51)</a> for \( \kappa=H=1 \).  <!-- caption label: femsys:cooling:T:plot --> </p></center>
<p><img src="fig/cooling_T.png" align="bottom" width=800></p>
</center>

<p>
Below we include the code used to solve this problem in FEniCS and plot it using <code>matplotlib</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x):
  <span style="color: #008000; font-weight: bold">return</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> DOLFIN_EPS <span style="color: #AA22FF; font-weight: bold">or</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0</span> <span style="color: #666666">-</span> DOLFIN_EPS

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

Ns <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">16</span>, <span style="color: #666666">32</span>]
<span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> Ns: 
    mesh <span style="color: #666666">=</span> UnitIntervalMesh(N)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&quot;Lagrange&quot;</span>, <span style="color: #666666">1</span>)
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V) 

    beta <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    mu <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>) 

    bc <span style="color: #666666">=</span> DirichletBC(V, Constant(<span style="color: #666666">0</span>), boundary)
    a <span style="color: #666666">=</span> mu<span style="color: #666666">*</span>inner(grad(u), grad(v))<span style="color: #666666">*</span>dx 
    L <span style="color: #666666">=</span> <span style="color: #666666">-</span>beta<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx 

    w <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, w, bc)

    T0 <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    kappa <span style="color: #666666">=</span> Constant(<span style="color: #666666">1</span>)
    bc <span style="color: #666666">=</span> DirichletBC(V, T0, boundary)
    a <span style="color: #666666">=</span> kappa<span style="color: #666666">*</span>inner(grad(u), grad(v))<span style="color: #666666">*</span>dx 
    L <span style="color: #666666">=</span> <span style="color: #666666">-</span>mu<span style="color: #666666">*</span>inner(grad(w), grad(w))<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx 

    T <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, T, bc)

    x <span style="color: #666666">=</span> V<span style="color: #666666">.</span>tabulate_dof_coordinates()
    plt<span style="color: #666666">.</span>plot(x, T<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>get_local())
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&quot;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">%</span>N <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> Ns], loc<span style="color: #666666">=</span><span style="color: #BA2121">&quot;upper left&quot;</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Most of the FEniCS code should be familiar to the reader, but 
we remark that we use the function <code>V.tabulate_dof_coordinates()</code> to obtain the coordinates of the nodal points. This is a general
function that works for any finite element implemented in 
FEniCS and also in a parallel setting.

<p>
The calculations for <a href="#mjx-eqn-7.52">(7.52)</a>
and <a href="#mjx-eqn-7.53">(7.53)</a> are similar.
The <code>sympy</code> code
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

r, R, mu, beta, C, D, T0 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&quot;r R mu beta C D T0&quot;</span>)
rwr <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(<span style="color: #666666">-</span>(beta<span style="color: #666666">/</span>mu)<span style="color: #666666">*</span>r, r) <span style="color: #666666">+</span> C
w <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(rwr<span style="color: #666666">/</span>r, r) <span style="color: #666666">+</span> D
s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve([sym<span style="color: #666666">.</span>diff(w,r)<span style="color: #666666">.</span>subs(r, <span style="color: #666666">0</span>)<span style="color: #666666">-0</span>,  <span style="color: #408080; font-style: italic"># r=0 condition</span>
               w<span style="color: #666666">.</span>subs(r,R)<span style="color: #666666">-0</span>],              <span style="color: #408080; font-style: italic"># r=R condition</span>
               [C, D])                      <span style="color: #408080; font-style: italic"># unknowns</span>
w <span style="color: #666666">=</span> w<span style="color: #666666">.</span>subs(C, s[C])<span style="color: #666666">.</span>subs(D, s[D])
w <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(w))

rTr <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(<span style="color: #666666">-</span>mu<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(w,r)<span style="color: #666666">**2*</span>r, r) <span style="color: #666666">+</span> C
T <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(rTr<span style="color: #666666">/</span>r, r) <span style="color: #666666">+</span> D
s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve([sym<span style="color: #666666">.</span>diff(T,r)<span style="color: #666666">.</span>subs(r, <span style="color: #666666">0</span>)<span style="color: #666666">-</span>T0,  <span style="color: #408080; font-style: italic"># r=0 condition</span>
               T<span style="color: #666666">.</span>subs(r, R)<span style="color: #666666">-</span>T0],             <span style="color: #408080; font-style: italic"># r=R condition</span>
               [C, D])                       <span style="color: #408080; font-style: italic"># unknowns</span>
T <span style="color: #666666">=</span> T<span style="color: #666666">.</span>subs(C, s[C])<span style="color: #666666">.</span>subs(D, s[D])
T <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(T))
</pre></div>
<p>
and we obtain the solutions
$$
\begin{align*}
w(r) &= \frac{\beta \left(R^{2} - r^{2}\right)}{4 \mu}, \\ 
T(r) &= \frac{1}{64 \mu} \left(R^{4} \beta^{2} + 64 T_{0} \mu - \beta^{2} r^{4}\right)\tp
\end{align*}
$$

<p>
The radial solution corresponds to the analytical solution in 3D and is very useful for the purpose 
of verifying the code of multi-physics flow problems.

<h2 id="fem:sys:up:1D" class="anchor">Another example in 1D</h2>
Consider the problem
$$
\begin{align}
\tag{7.54}
 -(a u')' &= 0,\\ 
u(0) &= 0,
\tag{7.55}\\ 
u(1) &= 1 \tp
\tag{7.56}
\end{align}
$$

For any scalar \( a \) (larger than 0), we may easily verify that the solution is \( u(x)=x \).
In many applications, such as for example porous media flow
or heat conduction, the parameter \( a \) contains a jump that represents
the transition from one material to another. Hence,
let us consider the problem where \( a \) is on the following
form
$$
a(x) = \left\{ \begin{array}{ll}
            1 & \mbox{  if } x\le\half, \\ 
            a_0 &  \mbox{  if } x>\half\tp
           \end{array} \right.
$$

Notice that for such an \( a(x) \), the equation <a href="#mjx-eqn-7.54">(7.54)</a> does not necessarily make
sense because we cannot differentiate \( a(x) \). Strictly speaking \( a'(x) \) would
be a Dirac's delta function in \( x=\half \), that is; \( a'(x) \) is \( \infty \) at \( x=\half \) and zero
everywhere else.

<p>
Hand-calculations do however show that we may be able to
compute the solution. Integrating <a href="#mjx-eqn-7.54">(7.54)</a>
yields the expression
$$
-(a u') = C
$$

A trick now is to divide by \( a(x) \) on both sides to obtain
$$
- u' = \frac{C}{a}
$$

and since \( a \) is a piecewise constant 
$$
u(x) = \frac{C}{a(x)} x + D
$$

The boundary conditions demand that \( u(0) = 0 \), which means that \( D=0 \). 
In order to obtain an expression for \( u(1)=1 \) 
we note that \( u \) is 
a piecewise linear function 
with \( u' = C \) for \( x\in(0,0.5) \)
and \( u'=\frac{C}{a_0} \) for \( x\in(0.5,1) \). 
We may therefore express \( u(1) \) in terms of 
\( u(0) \) plus the derivatives at the midpoints of the two intervals, i.e.,  
\( u(1) = u(0) + \half u'(0.25)  + \half u'(0.75)  = 0.5 (C + \frac{C}{a_0}) = 1 \). 
In other words, \( C=\frac{2 a_0}{a_0 +1} \) and the analytical solution becomes
$$
\begin{equation}
\tag{7.57}
u_e(x) = 
\left\{ \begin{array}{ll}
\frac{2 a_0}{a_0 +1}   x & \mbox{ for } 0 < x \le 0.5 \\ 
\frac{2}{a_0 +1} x + \frac{a_0-1}{a_0 +1}  & \mbox{ for } 0.5 < x \le 1
\end{array}
\right. 
\end{equation}
$$

<p>
The variational problem derived from a standard Galerkin method reads: Find \( u \) such that
$$
\int_{\Omega} a u' v' \, \dx = \int_\Omega f v dx + \int_{\partial \Omega} a u' v \ds
$$

<p>
We observe that in this variational formulation, the discontinuity of \( a \) does not cause any problem
as the differentiation is moved from \( a \) (and \( u' \)) to \( v \) by using integration by parts (or Green's lemma).
As earlier, to include the boundary conditions,  we may use a boundary function such that 
$$ u(x) = B(x) + \sum_{j\in\If}c_j\baspsi_j(x) $$

and further letting  \( v=\baspsi_i(x) \),  the corresponding linear system is \( \sum_j A_{i,j}c_j=b_i \)
with

$$
\begin{align*}
A_{i,j} &= (a \baspsi_j', \baspsi_i') = \int_{\Omega} a(x) \baspsi_j'(x)
\baspsi_i'(x)\dx,\\ 
b_i &= -\int_{\Omega} a B' v' \dx + \int_{\partial \Omega} a \frac{\partial B'}{\partial n} v  \ds \tp
\end{align*}
$$

<p>
In FEniCS, the linear algebra approach is used and the boundary conditions are inserted 
in the element matrix as described in the section <a href="._fem-book-sol021.html#fem:bc:elmat:mod">Modification of the element matrix and vector</a>. 
The solution of the problem is shown in Figure <a href="#femsys:varcoeff:1D:Galerkin:plotu">81</a> at different mesh resolutions.
The analytical solution in <a href="#mjx-eqn-7.57">(7.57)</a> is a piecewise polynomial, linear
for \( x \) in \( [0,\half) \) and \( (\half,1] \) and it seems that the numerical strategy gives a good approximation
of the solution.
The FEniCS program generating the plot is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">uExact</span>(UserExpression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, <span style="color: #666666">**</span>kwargs):
        <span style="color: #008000">super</span>()<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>(degree<span style="color: #666666">=</span>kwargs[<span style="color: #BA2121">&quot;degree&quot;</span>])
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #666666">=</span> kwargs[<span style="color: #BA2121">&quot;a0&quot;</span>]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a  <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span>:
            value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> (<span style="color: #666666">2.0*</span><span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #666666">/</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #666666">+1</span>)) <span style="color: #666666">/</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a <span style="color: #666666">*</span> x[<span style="color: #666666">0</span>]
        <span style="color: #008000; font-weight: bold">else</span>:
            value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">2.0*</span><span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #666666">/</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #666666">+1</span>)) <span style="color: #666666">/</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a0) <span style="color: #666666">*</span> x[<span style="color: #666666">0</span>] \ 
                       <span style="color: #666666">+</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>a0<span style="color: #666666">-1</span>)<span style="color: #666666">/</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>a0<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">A</span>(UserExpression):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, <span style="color: #666666">**</span>kwargs):
        <span style="color: #008000">super</span>()<span style="color: #666666">.</span><span style="color: #0000FF">__init__</span>(degree<span style="color: #666666">=</span>kwargs[<span style="color: #BA2121">&quot;degree&quot;</span>])
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a0 <span style="color: #666666">=</span> kwargs[<span style="color: #BA2121">&quot;a0&quot;</span>]
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">eval</span>(<span style="color: #008000">self</span>, value, x):
        value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">if</span> x[<span style="color: #666666">0</span>] <span style="color: #666666">&gt;=</span> <span style="color: #666666">0.5</span>: value[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a0

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">DirichletBoundary</span>(SubDomain):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inside</span>(<span style="color: #008000">self</span>, x, on_boundary):
        <span style="color: #008000; font-weight: bold">return</span> on_boundary

p_bc <span style="color: #666666">=</span> f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;x[0]&quot;</span>, degree<span style="color: #666666">=2</span>)
Ns <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">8</span>, <span style="color: #666666">32</span>]
a0 <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
<span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> Ns:
    mesh <span style="color: #666666">=</span> UnitIntervalMesh(N)
    V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&quot;CG&quot;</span>, <span style="color: #666666">1</span>)
    Q <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&quot;DG&quot;</span>, <span style="color: #666666">0</span>)
    u <span style="color: #666666">=</span> TrialFunction(V)
    v <span style="color: #666666">=</span> TestFunction(V)
    a_coeff <span style="color: #666666">=</span> A(degree<span style="color: #666666">=2</span>, a0<span style="color: #666666">=</span>a0)
    a <span style="color: #666666">=</span> a_coeff<span style="color: #666666">*</span>inner(grad(u), grad(v))<span style="color: #666666">*</span>dx
    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
    bc <span style="color: #666666">=</span> DirichletBC(V, p_bc, DirichletBoundary())
    u <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, u, bc)

    <span style="color: #408080; font-style: italic"># plot solution on the various meshes</span>
    plt<span style="color: #666666">.</span>plot(V<span style="color: #666666">.</span>tabulate_dof_coordinates(), u<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>get_local())

<span style="color: #408080; font-style: italic"># create plot for analytical solution, plot, save</span>
u_exact <span style="color: #666666">=</span> project(uExact(a0<span style="color: #666666">=</span>a0, degree<span style="color: #666666">=1</span>), V)
plt<span style="color: #666666">.</span>plot(V<span style="color: #666666">.</span>tabulate_dof_coordinates(), u_exact<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>get_local())
legend <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">%</span>N <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> Ns]
legend<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;analytical solution&quot;</span>)
plt<span style="color: #666666">.</span>legend(legend, loc<span style="color: #666666">=</span><span style="color: #BA2121">&quot;upper left&quot;</span>)
plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;darcy_a1D.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;darcy_a1D.pdf&#39;</span>)
</pre></div>
<p>
Figure <a href="#femsys:varcoeff:1D:Galerkin:plotu">81</a> shows the solution \( u \). Clearly we have a good approximation already on a mesh with just two elements
as the solution is piecewise linear as found in <a href="#mjx-eqn-7.57">(7.57)</a>.

<p>
<center> <!-- figure label: --> <div id="femsys:varcoeff:1D:Galerkin:plotu"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 81:  Solution of the Darcy problem with discontinuous coefficient for different number of elements \( N \).  <!-- caption label: femsys:varcoeff:1D:Galerkin:plotu --> </p></center>
<p><img src="fig/darcy_a1D.png" align="bottom" width=800></p>
</center>

<p>
The flux \( a u' \) is often a quantity of interest. Because the flux involves differentiation with respect
to \( x \) we do not have an direct access to it and 
have to compute it. A natural approach is to take the Galerkin approximation,
that is we seek a \( w \approx a u' \) on the form  \( w=\sum_{j\in\If} d_j\baspsi_j \) and
require  Galerkin orthogonality. In other words, we require 
that \( w-a u' \) is orthogonal to \( \{\baspsi_i\} \). This is done by solving
the linear system  \( \sum_j M_{i,j}d_j=b_i \) with

$$
\begin{align*}
M_{i,j} &= (a \baspsi_j, \baspsi_i) = \int_{\Omega} a(x) \baspsi_j(x) \baspsi_i(x)\dx,\\ 
b_i &= (a u',\baspsi_i)=  \int_\Omega a(x)  \sum_j c_j\baspsi_j'(x) \dx\tp
\end{align*}
$$

<p>
Computing the flux by taking the Galerkin projection as described in the section <a href="._fem-book-sol015.html#fem:approx:fenics:2D">Example on approximation in 2D using FEniCS</a>
is implemented in the <code>project</code> method in FEniCS and is obtained as
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>aux <span style="color: #666666">=</span> project(<span style="color: #666666">-</span>a_coeff<span style="color: #666666">*</span>u<span style="color: #666666">.</span>dx(<span style="color: #666666">0</span>), V)
</pre></div>
<p>
As shown in Figure <a href="#femsys:varcoeff:1D:Galerkin:plotsux">82</a> this 
approach does not produce a good approximation of the flux.
Moreover, the approximate solution does not seem to 
improve close to the jump as the mesh is refined. The problem is that we try to approximate a 
discontinuous function with a continuous basis and this may often cause
spurious oscillations. In this case, we may fix the problem by alternative post-processing 
methods for calculating the flux. For instance, we may project onto piecewise constant 
functions instead. However, in general, we would still loose accuracy as the first order derivative involved
in the flux calculation lower the order of accuracy by one.

<p>
<center> <!-- figure label: --> <div id="femsys:varcoeff:1D:Galerkin:plotsux"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 82:  The corresponding flux \( a u' \) for the Darcy problem with discontinuous coefficient for different number of elements \( N \).  <!-- caption label: femsys:varcoeff:1D:Galerkin:plotsux --> </p></center>
<p><img src="fig/darcy_adx1D.png" align="bottom" width=800></p>
</center>

<p>
An alternative method that makes the flux approximation \( w \) more accurate than
the underlying \( u \) is an equivalent form
of <a href="#mjx-eqn-7.54">(7.54)</a> where the flux is one of the unknowns.
This formulation is usually called the mixed formulation. 
The equations reads:
$$
\begin{align}
\frac{\partial w}{\partial x} &= 0,
\tag{7.58}\\ 
w &=-a\frac{\partial u}{\partial x}
\tag{7.59}
\tp
\end{align}
$$

Equation <a href="#mjx-eqn-7.59">(7.59)</a> is Darcy's law for a porous media. 
A straightforward calculation shows that inserting <a href="#mjx-eqn-7.59">(7.59)</a> into <a href="#mjx-eqn-7.58">(7.58)</a> yields
the equation <a href="#mjx-eqn-7.54">(7.54)</a>. We also note that we have replaced the second order differential
equation with a system of two first order differential equations.

<p>
It is common to swap the order of the equations and also divide equation
<a href="#mjx-eqn-7.59">(7.59)</a> by \( a \). 
Then variational formulation of the problem, having the two unknowns \( w \) and \( u \)
and corresponding test functions  \( v^{(w)} \) and \( v^{(u)} \),
 becomes
$$
\begin{align}
\tag{7.60}
\int_\Omega \frac{1}{a} w v^{(w)} + \frac{\partial u}{\partial x} v^{(w)} \dx &=0, \\ 
\tag{7.61}
\int_\Omega \frac{\partial w}{\partial x} v^{(u)} \dx &= 0\tp
\end{align}
$$

To obtain a suitable variation formulation we perform integration by parts on
the last term of <a href="#mjx-eqn-7.60">(7.60)</a> to 
obtain
$$
\int_\Omega  \frac{\partial u}{\partial x} v^{(w)} \dx  = 
- \int_\Omega  u \frac{\partial v^{(w)}}{\partial x} \dx 
+ \int_{\partial\Omega}  u v^{(w)} \dx
$$

Notice that the Dirichlet conditions of 
<a href="#mjx-eqn-7.54">(7.54)</a> becomes a Neumann condition in this mixed formulation. 
Vice versa, a Neumann condition in <a href="#mjx-eqn-7.54">(7.54)</a> 
becomes a Dirichlet condition in the mixed case.

<p>
To obtain a linear system of equation, let 
\( u=\sum_{j\in\If} c_j\baspsi_j^{(u)} \),
\( w=\sum_{j\in\If} c_j\baspsi_j^{(w)} \),
\( v^{(u)} =  \baspsi_i^{(u)} \), and
\( v^{(w)} =  \baspsi_i^{(w)} \). We obtain the following system
of linear equations
$$
A\, c = \left[ \begin{array}{cc} A^{(w,w)} & A^{(w,u)}\\ A^{(u,w)} & 0 \end{array} \right]
\left[ \begin{array}{c} c^{(w)} \\ c^{(u)} \end{array} \right] =
\left[ \begin{array}{c} b^{(w)} \\ b^{(u)} \end{array} \right]
= b,
$$

where
$$
\begin{align*}
A^{(w,w)}_{i,j} &=  \int_{\Omega} \frac{1}{a(x)} \baspsi^{(w)}_j(x) \baspsi^{(w)}_i(x)\dx & i,j = 0\ldots N^{(w)}-1, \\ 
A^{(w,u)}_{i,j} &=  -\int_{\Omega} \frac{\partial}{\partial x} \baspsi^{(w)}_j(x) \baspsi^{(u)}_i(x)\dx &  i=0\ldots N^{(w)}-1, j=0, \ldots N^{(u)}-1, \\ 
A^{(u,w)}_{i,j} &= -A^{(w,u)}_{j,i}, \\ 
b^{(w)}_i &= \int_\Omega a B \frac{\partial}{\partial x}\baspsi^{(w)}_i) - [a B\baspsi^{(w)}_i]^1_0, \\ 
b^{(u)}_i &= (0,\baspsi^{(u)}_i)= 0 \tp
\end{align*}
$$

<p>
<center> <!-- figure label: --> <div id="femsys:varcoeff:1D:Galerkin:plotu:mx"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 83:  Solution of the mixed Darcy problem with discontinuous coefficient for different number of elements \( N \).  <!-- caption label: femsys:varcoeff:1D:Galerkin:plotu:mx --> </p></center>
<p><img src="fig/darcy_a1D_mx.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="femsys:varcoeff:1D:Galerkin:plotsux:mx"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 84:  The corresponding flux \( a u' \) for the mixed Darcy problem with discontinuous coefficient for different number of elements \( N \).  <!-- caption label: femsys:varcoeff:1D:Galerkin:plotsux:mx --> </p></center>
<p><img src="fig/darcy_adx1D_mx.png" align="bottom" width=800></p>
</center>

<p>
In Figure <a href="#femsys:varcoeff:1D:Galerkin:plotu:mx">83</a> the solution 
\( u \) obtained by solving the of system  <a href="#mjx-eqn-7.59">(7.59)</a>
using piecewise linear elements for \( w \) and piecewise constants for \( u \). 
Clearly, \( u \) converges towards the analytical solution as the mesh 
is refined, although in a staggered way. In Figure <a href="#femsys:varcoeff:1D:Galerkin:plotsux:mx">84</a>
we display the flux \( a u' \). The flux appears to be a constant  
as predicted by our analytical solution <a href="#mjx-eqn-7.57">(7.57)</a>
and in our case \( a_0=0.1 \) which makes \( C=\frac{2 a_0}{a_0 +1} \approx 0.18 \), which is
quite close to the estimate provided in  Figure <a href="#femsys:varcoeff:1D:Galerkin:plotsux:mx">84</a>.

<p>
It is interesting to note that the standard Galerkin formulation
of the problem results in a perfect approximation of \( u \), while
the flux \( -a u' \) is badly represented. On the other hand,
for the mixed formulation, the flux is well approximated but
\( u \) is approximated only to first order yielding a staircase
approximation. These observations naturally suggest
that we should employ P1 approximation of both \( u \) and
its flux. We should then get a perfect approximation of
both unknowns. This is however not possible. The
linear system we obtain with P1 elements for both variables is singular.

<p>
This example shows that when we are solving systems of PDEs with
several unknowns, we can not choose the approximation arbitrary.
The polynomial spaces of the different unknowns have to be compatible
and the accuracy of the different unknowns depend on each other. 
We will not discuss the reasons for the need of compatibility here
as it is rather theoretical and beyond the scope of this book. Instead we 
refer the interested reader to <a href="._fem-book-sol037.html#brezzi2012mixed">[23]</a> <a href="._fem-book-sol037.html#Brenner_Scott">[2]</a> <a href="._fem-book-sol037.html#Braess">[1]</a> <a href="._fem-book-sol037.html#Silvester_et_al_2015">[3]</a>.

<p>
The complete code for the mixed Darcy example is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> Ns:
    mesh <span style="color: #666666">=</span> UnitIntervalMesh(N)
    P1 <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&quot;CG&quot;</span>, mesh<span style="color: #666666">.</span>ufl_cell(), <span style="color: #666666">1</span>)
    P2 <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&quot;DG&quot;</span>, mesh<span style="color: #666666">.</span>ufl_cell(), <span style="color: #666666">0</span>)
    P1xP2 <span style="color: #666666">=</span> P1 <span style="color: #666666">*</span> P2
    W <span style="color: #666666">=</span> FunctionSpace(mesh, P1xP2)
    u, p <span style="color: #666666">=</span> TrialFunctions(W)
    v, q <span style="color: #666666">=</span> TestFunctions(W)

    f <span style="color: #666666">=</span> Constant(<span style="color: #666666">0</span>)
    n <span style="color: #666666">=</span> FacetNormal(mesh)
    a_coeff <span style="color: #666666">=</span> A(degree<span style="color: #666666">=1</span>, a0<span style="color: #666666">=</span>a0)

    a <span style="color: #666666">=</span> (<span style="color: #666666">1/</span>a_coeff)<span style="color: #666666">*</span>u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> u<span style="color: #666666">.</span>dx(<span style="color: #666666">0</span>)<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> v<span style="color: #666666">.</span>dx(<span style="color: #666666">0</span>)<span style="color: #666666">*</span>p<span style="color: #666666">*</span>dx
    L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>q<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> p_bc<span style="color: #666666">*</span>v<span style="color: #666666">*</span>n[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>ds

    up <span style="color: #666666">=</span> Function(W)
    solve(a <span style="color: #666666">==</span> L, up)

    u, p <span style="color: #666666">=</span> up<span style="color: #666666">.</span>split()

    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span>
    a <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>array([<span style="color: #666666">0.0</span>])
    b <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>array([<span style="color: #666666">0.0</span>])
    xs <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>arange(<span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">0.001</span>)
    ps <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>arange(<span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">0.001</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,<span style="color: #008000">len</span>(xs)):
        a[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> xs[i]
        p<span style="color: #666666">.</span>eval(b, a)
        ps[i] <span style="color: #666666">=</span> b
    plt<span style="color: #666666">.</span>plot(xs, ps)


CG1 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&quot;CG&quot;</span>, <span style="color: #666666">1</span>)
p_exact <span style="color: #666666">=</span> project(uExact(a0<span style="color: #666666">=</span>a0, degree<span style="color: #666666">=1</span>), CG1)
p_exact4plot <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>array([p_exact(x) <span style="color: #008000; font-weight: bold">for</span> x <span style="color: #AA22FF; font-weight: bold">in</span> xs])
plt<span style="color: #666666">.</span>plot(xs, p_exact4plot)
legend <span style="color: #666666">=</span> [<span style="color: #BA2121">&quot;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">%</span>N <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> Ns]
legend<span style="color: #666666">.</span>append(<span style="color: #BA2121">&quot;analytical solution&quot;</span>)

plt<span style="color: #666666">.</span>legend(legend, loc<span style="color: #666666">=</span><span style="color: #BA2121">&quot;upper left&quot;</span>)
plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;darcy_a1D_mx.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;darcy_a1D_mx.pdf&#39;</span>);
</pre></div>
<p>
Here, we remark that we in order to plot the discontinuous solution
properly we re-sampled the solution on a fine mesh. In general for discontinuous elements one should be careful with the way the solution is plotted. Interpolating into a continuous field may not be desirable.

<h1 id="___sec298" class="anchor">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="femsys:exer:cooling:1" class="anchor">Problem 41: Estimate order of convergence for the Cooling law</h2>

<p>
Consider the 1D Example of the fluid flow in a straight pipe 
coupled to heat conduction in the section <a href="#femsys:cooling:1D">Computations in 1D</a>. 
The example demonstrated fast convergence when using linear elements
for both variables \( w \) and \( T \). In this exercise we quantify the order 
of convergence. That is, we expect that
$$
\begin{align*}
\|w - w_e \|_{L_2} &\le C_w h^{\beta_w}, \\ 
\|T - T_e \|_{L_2} &\le C_T h^{\beta_T},
\end{align*}
$$

for some \( C_w \), \( C_T \), \( \beta_w \) and \( \beta_T \). 
Assume therefore that
$$
\begin{align*}
\|w - w_e \|_{L_2} &= C_w h^{\beta_w},\\ 
\|T - T_e \|_{L_2} &= C_T h^{\beta_T},
\end{align*}
$$

and estimate  \( C_w \), \( C_T \), \( \beta_w \) and \( \beta_T \).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="femsys:exer:cooling:2" class="anchor">Problem 42: Estimate order of convergence for the Cooling law</h2>

<p>
Repeat <a href="#femsys:exer:cooling:1">Problem 41: Estimate order of convergence for the Cooling law</a> with quadratic finite
elements for both \( w \) and \( T \).

<p>
<!-- 2DO -->

<p>
<b>Calculations to be continued...</b>

<p>
<!-- --- end exercise --- -->

<p>

<center><h1 id="ch:nitsche" class="anchor">Flexible implementations of boundary conditions</h1></center> <!-- chapter heading -->

<p>
One quickly gets the impression that variational forms can handle only
two types of boundary conditions: essential conditions where the
unknown is prescribed, and natural conditions where flux terms
integrated by parts allow specification of flux conditions. However,
it is possible to treat much more general boundary conditions by
adding their weak form.  That is, one simply adds the variational
formulation of some boundary condition \( \mathcal{B}(u)=0 \):
\( \int_{\Omega_B}\mathcal{B}(u)v\dx \), where \( \Omega_B \) is some
boundary, to the variational formulation of the PDE problem.  Or using
the terminology from the chapter <a href="._fem-book-sol003.html#ch:approx:global">Function approximation by global functions</a>: the residual of
the boundary condition when the discrete solution is inserted is added
to the residual of the entire problem. The present chapter shows
underlying mathematical details.

<h1 id="nitsche:fxy:opt" class="anchor">Optimization with constraint</h1>

<p>
\newcommand{\uN}{u_N}
Suppose we have a function

$$ f(x,y) = x^2 + y^2 \tp$$

and want to optimize its values, i.e., find minima and maxima.
The condition for an optimum is that the derivatives vanish in all
directions, which implies

$$ \boldsymbol{n}\cdot\nabla f = 0\quad\forall\boldsymbol{n} \in \Real^2,$$

which further implies
$$
\frac{\partial f}{\partial x} = 0,\quad \frac{\partial f}{\partial y} = 0\tp
$$

These two equations are in general nonlinear and can have many solutions,
one unique solution, or none.
In our specific example, there is only one solution: \( x=0 \), \( y=0 \).

<p>
Now we want to optimize \( f(x,y) \) under the constraint \( y=2-x \).
This means that only \( f \) values along the line \( y=2-x \) are relevant,
and we can imagine we view \( f(x,y) \) along this line and want to find
the optimum value.

<h2 id="___sec303" class="anchor">Elimination of variables </h2>

<p>
Our \( f \) is obviously a function of one variable along the line.
Inserting \( y=2-x \) in \( f(x,y) \) eliminates \( y \) and leads to \( f \) as
function of \( x \) alone:

$$ f(x,y=2-x) = 4 - 4x + 2x^2\tp$$

The condition for an optimum is

$$ \frac{d}{dx}(4 - 4x + 2x^2) = -4 + 4x = 0,$$

so \( x=1 \) and \( y=2-x=1 \).

<p>
In the general case we have a scalar function \( f(\x) \),
\( \x=(x_0,\ldots,x_m) \) with \( n+1 \) constraints \( g_i(\x)=0 \),
\( i=0,\ldots,n \). In theory, we could use the constraints to
express \( n+1 \) variables in terms of the remaining \( m-n \) variables,
but this is very seldom possible, because it requires us to solve
the \( g_i=0 \) symbolically with respect to \( n+1 \) different variables.

<h2 id="nitsche:fxy:opt:Lagrange" class="anchor">Lagrange multiplier method</h2>

<p>
When we cannot easily eliminate variables using the constraint(s),
the Lagrange multiplier method come to aid. Optimization of \( f(x,y) \)
under the constraint \( g(x,y)=0 \) then consists in formulating
the <em>Lagrangian</em>

$$ \ell(x,y,\lambda) = f(x,y) + \lambda g(x,y),$$

where \( \lambda \) is the Lagrange multiplier, which is unknown.
The conditions for an optimum is that

$$ \frac{\partial\ell}{\partial x}=0,\quad
\frac{\partial\ell}{\partial y}=0,\quad
\frac{\partial\ell}{\partial \lambda}=0\tp$$

In our example, we have

$$ \ell(x,y,\lambda) = x^2 + y^2 + \lambda(y - 2 + x),$$

leading to the conditions

$$ 2x + \lambda = 0,\quad 2y + \lambda = 0,\quad y - 2+ x = 0\tp$$

This is a system of three linear equations in three unknowns with
the solution

$$ x = 1,\quad y = 1,\quad \lambda =2\tp$$

<p>
In the general case with optimizing \( f(\x) \) subject to
the constraints \( g_i(\x)=0 \), \( i=0,\ldots,n \), the Lagrangian becomes

$$ \ell(\x,\boldsymbol{\lambda}) = f(\x) + \sum_{j=0}^n\lambda_jg_j(\x),$$

with \( \x=(x_0,\ldots,x_m) \) and \( \boldsymbol{\lambda}=(\lambda_0,\ldots,\lambda_n) \).
The conditions for an optimum are

$$ \frac{\partial f}{\partial\x}=0,\quad
\frac{\partial f}{\partial\boldsymbol{\lambda}}=0\tp,$$

where
$$ \frac{\partial f}{\partial\x}=0\Rightarrow
\frac{\partial f}{\partial x_i}=0,\ i=0,\ldots,m\tp$$

Similarly, \( \partial f/\partial\boldsymbol{\lambda}=0 \) leads to
\( n+1 \) equations \( \partial f/\partial\lambda_i=0 \), \( i=0,\ldots,n \).

<h2 id="nitsche:fxy:opt:penalty" class="anchor">Penalty method</h2>

<p>
Instead of incorporating the constraint exactly, as in the
Lagrange multiplier method, the penalty method employs an approximation
at the benefit of avoiding the extra Lagrange multiplier as unknown.
The idea is to add the constraint squared, multiplied by a large
prescribed number \( \lambda \), called the penalty parameter,

$$ \ell_\lambda (x,y) = f(x,y) + \frac{1}{2}\lambda(y-2+x)^2\tp$$

Note that \( \lambda \) is now a given (chosen) number.
The \( \ell_\lambda \) function is just a function of two variables,
so the optimum is found
by solving

$$ \frac{\partial \ell_\lambda}{\partial x} =0,\quad
\frac{\partial \ell_\lambda}{\partial y} =0\tp$$

Here we get

$$ 2x +\lambda (y-2+x)=0,\quad
2y + \lambda (y-2+x)=0\tp$$

The solution becomes

$$ x = y = \frac{1}{1-\frac{1}{2}\lambda^{-1}},$$

which we see approaches the correct solution \( x=y=1 \)
as \( \lambda\rightarrow\infty \).

<p>
The penalty method for optimization of a multi-variate function
\( f(\x) \) with constraints \( g_i(\x)=0 \), \( i=0,\ldots,n \),
can be formulated as optimization of the unconstrained function

$$ \ell_\lambda(\x) = f(\x) + \frac{1}{2}\lambda\sum_{j=0}^n (g_i(\x))^2\tp$$

Sometimes the symbol \( \epsilon^{-1} \) is used for \( \lambda \) in the
penalty method.

<h1 id="nitsche:pde:opt" class="anchor">Optimization of functionals</h1>

<p>
The methods above for optimization of scalar functions of a finite
number of variables can be generalized to optimization of
functionals (functions of functions).
We start with the specific example of optimizing

$$
\begin{equation} F(u) =
\int\limits_\Omega ||\nabla u||^2 \dx -
\int\limits_\Omega fu \dx -
\int\limits_{\partial\Omega_N}gu \ds,\quad
u\in V,
\tag{8.1}
\end{equation}
$$

where \( \Omega\subset \Real^2 \), and \( u \) and \( f \) are functions of \( x \)
and \( y \) in \( \Omega \). The norm \( ||\nabla u||^2 \) is defined as \( u_{x}^2
+ u_{y}^2 \), with \( u_x \) denoting the derivative with respect to \( x \).
The vector space \( V \) contains the relevant functions for this problem,
and more specifically, \( V \) is the Hilbert space \( H^1_0 \) consisting of
all functions for which \( \int\limits_\Omega (u^2 + ||\nabla u||^2)\dx \)
is finite and \( u=0 \) on \( \partial\Omega_D \), which is some part of the
boundary \( \partial\Omega \) of \( \Omega \).  The remaining part of the
boundary is denoted by \( \partial\Omega_N \)
(\( \partial\Omega_N\cup\partial\Omega_D=\partial\Omega \),
\( \partial\Omega_N\cap\partial\Omega_D=\emptyset \)), over which \( F(u) \)
involves a line integral.  Note that \( F \) is a mapping from any \( u\in
V \) to a real number in \( \Real \).

<h2 id="nitsche:pde:opt:varcalculus" class="anchor">Classical calculus of variations</h2>

<p>
Optimization of the functional
\( F \) makes use of the machinery from <a href="http://en.wikipedia.org/wiki/Variational_calculus" target="_self">variational calculus</a>. The essence is to demand that the
functional derivative of \( F \) with respect to \( u \) is zero.
Technically, this is carried out by writing a general function \( \tilde u\in V \)
as \( \tilde u=u+\epsilon v \), where \( u \) is the exact solution of the optimization
problem, \( v \) is an arbitrary function in \( V \),
and \( \epsilon \) is a scalar parameter. The
functional derivative in the direction of \( v \) (also known as the
<a href="http://en.wikipedia.org/wiki/G%C3%A2teaux_derivative" target="_self">Gateaux derivative</a>)
is defined as

$$
\begin{equation}
\frac{\delta F}{\delta u} = \lim_{\epsilon\rightarrow 0}\frac{d}{d\epsilon}
F(u+\epsilon v)
\tp
\tag{8.2}
\end{equation}
$$

<p>
As an example,
the functional derivative to the term
\( \int\limits_\Omega fu\dx \) in \( F(u) \)
is computed by finding

$$
\begin{equation}
\frac{d}{d\epsilon} \int\limits_\Omega f\cdot(u+\epsilon v)\dx
= \int\limits_\Omega fv \dx,
\tag{8.3}
\end{equation}
$$

and then let \( \epsilon \) go to zero (not strictly needed in this case
because the term is linear in \( \epsilon \)), which just results in \( \int\limits_\Omega fv\dx \).
The functional derivative of the other area integral becomes

$$
\frac{d}{d\epsilon} \int\limits_\Omega ((u_x + \epsilon v_x)^2 +
(u_y + \epsilon v_y)^2)\dx = \int\limits_\Omega (2(u_x + \epsilon v_x)v_x
+ 2(u_v+\epsilon v_y)v_y)\dx,
$$

which leads to

$$
\begin{equation}
\int\limits_\Omega (u_xv_x + u_yv_y)\dx = \int\limits_\Omega \nabla u\cdot\nabla v \dx,
\tag{8.4}
\end{equation}
$$

as \( \epsilon\rightarrow 0 \).

<p>
The functional derivative of the boundary term
becomes

$$
\begin{equation}
\frac{d}{d\epsilon} \int\limits_{\partial\Omega_N} g \cdot (u+\epsilon v) \ds
= \int\limits_{\partial\Omega_N} g v \ds,
\tag{8.5}
\end{equation}
$$

for any \( \epsilon \). From <a href="#mjx-eqn-8.3">(8.3)</a>-<a href="#mjx-eqn-8.5">(8.5)</a> we then get the result

$$
\begin{equation}
\frac{\delta F}{\delta u} =
\int\limits_\Omega \nabla u\cdot\nabla v \dx -
\int\limits_\Omega fv \dx -
\int\limits_{\partial\Omega_N} g v \ds =0\tp
\tag{8.6}
\end{equation}
$$

Since \( v \) is arbitrary, this equation must hold \( \forall v\in V \). Many
will recognize <a href="#mjx-eqn-8.6">(8.6)</a> as the variational
formulation of a Poisson problem, which can be directly discretized
and solved by a finite element method.

<p>
Variational calculus goes one more step and derives a partial differential
equation problem from <a href="#mjx-eqn-8.6">(8.6)</a>, known as the
<a href="http://en.wikipedia.org/wiki/Euler-Lagrange_equation" target="_self">Euler-Lagrange equation</a> corresponding to optimization of \( F(u) \). To find the differential
equation, one manipulates the variational form
<a href="#mjx-eqn-8.6">(8.6)</a> such that no derivatives of \( v \)
appear and the equation <a href="#mjx-eqn-8.6">(8.6)</a> can be
written as \( \int\limits_\Omega \mathcal{L}v\dx =0 \), \( \forall v\in \), from which
it follows that \( \mathcal{L}=0 \) is the differential equation.

<p>
Performing integration by parts of the term
\( \int\limits_\Omega\nabla u\cdot\nabla v \dx \) in <a href="#mjx-eqn-8.6">(8.6)</a>
moves the derivatives of \( v \) over to \( u \):

$$
\begin{align*}
 \int\limits_\Omega\nabla u\cdot\nabla v \dx &=
-\int\limits_\Omega (\nabla^2 u)v\dx + \int\limits_{\partial\Omega}\frac{\partial u}{\partial n}v \ds\\ 
& = -\int\limits_\Omega (\nabla^2 u)v\dx +
\int\limits_{\partial\Omega_D}\frac{\partial u}{\partial n}v \ds +
\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v \ds\\ 
& = -\int\limits_\Omega (\nabla^2 u)v\dx +
\int\limits_{\partial\Omega_D}\frac{\partial u}{\partial n}0 \ds +
\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v \ds\\ 
& = -\int\limits_\Omega (\nabla^2 u)v\dx +
\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v \ds\tp
\end{align*}
$$

Using this rewrite in <a href="#mjx-eqn-8.6">(8.6)</a> gives

$$
-\int\limits_\Omega (\nabla^2 u)v\dx +
\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v \ds
-\int\limits_\Omega fv\dx
-\int\limits_{\partial\Omega_N} g v \ds,
$$

which equals

$$\int\limits_\Omega (\nabla^2 u + f)v\dx +
\int\limits_{\partial\Omega_N}\left(\frac{\partial u}{\partial n}-g\right)v \ds
=0\tp
$$

This is to hold for any \( v\in V \), which means that the integrands
must vanish, and we get the famous Poisson problem

$$
\begin{align*}
-\nabla^2u &= f,\quad (x,y)\in\Omega,\\ 
u &=0,\quad (x,y)\in\partial\Omega_D,\\ 
\frac{\partial u}{\partial n} &=g,\quad (x,y)\in\partial\Omega_N\tp
\end{align*}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Some remarks.</b>

<ul>
 <li> Specifying \( u \) on some part of the boundary (\( \partial\Omega_D \))
   implies a specification of \( \partial u/\partial n \) on the rest
   of the boundary. In particular, if such a specification is not
   explicitly done, the mathematics above implies \( \partial u/\partial n=0 \)
   on \( \partial\Omega_N \).</li>
 <li> If a non-zero condition on \( u=u_0 \) on \( \partial\Omega_D \) is wanted, one
   can write \( u = u_0 + \bar u \) and express the functional
   \( F \) in terms of \( \bar u \), which obviously must vanish on
   \( \partial\Omega_D \) since \( u \) is the exact solution that is \( u_0 \)
   on \( \partial\Omega_D \).</li>
 <li> The boundary conditions on \( u \) must be implemented in the space \( V \),
   i.e., we can only work with functions that <em>must</em> be zero on
   \( \partial\Omega_D \) (so-called <em>essential boundary condition</em>).
   The condition involving \( \partial u/\partial n \) is easier to
   implement since it is just a matter of computing a line integral.</li>
 <li> The solution is not unique if \( \partial\Omega_D = \emptyset \)
   (any solution \( u+\hbox{const} \) is also a solution).</li>
</ul>
</div>


<h2 id="nitsche:pde:opt:penalty" class="anchor">Penalty and Nitsche's methods for optimization with constraints</h2>

<p>
The attention is now on optimization of a functional \( F(u) \)
with a given constraint that \( u=\uN \) on \( \partial\Omega_N \).
That is, we want to set Dirichlet conditions weakly 
on the Neumann part of the boundary. 
We could, of course, just extend the Dirichlet condition on \( u \) in the
previous set-up by saying that \( \partial\Omega_D \) is the
complete boundary \( \partial\Omega \) and that \( u \) takes on
the values of \( 0 \) and \( \uN \) at the different parts of the
boundary. However, this also implies that all the functions
in \( V \) must vanish on the entire boundary. We want to relax
this condition (and by relaxing it, we will derive a method
that can be used for many other types of boundary conditions!).
The goal is, therefore, to incorporate \( u=\uN \) on
\( \partial\Omega_N \) without demanding anything from the functions
in \( V \). We can achieve this by enforcing the constraint

$$
\begin{equation}
\int\limits_{\partial\Omega_N} |u-\uN| \ds = 0\tp
\tag{8.7}
\end{equation}
$$

However, this constraint is cumbersome to implement. Note that
the absolute sign here is needed as in general there
are many functions \( u \) such that
\( \int\limits_{\partial\Omega_N} u-\uN \ds = 0 \).

<p>
<b>A penalty method.</b>
The idea is to add a penalization term \( \frac{1}{2}\lambda(u-\uN)^2 \),
integrated over the boundary \( \partial\Omega_N \), to
the functional \( F(u) \), just as we do in the penalty method (the
factor \( \frac{1}{2} \) can be incorporated in \( \lambda \), but we keep it
because it makes the
final result look nicer).

<p>
The condition \( \partial u/\partial n=g \)
on \( \partial\Omega_N \) is no longer relevant, so we replace
the \( g \) by the unknown \( \partial u/\partial n \) in the
boundary integral term in <a href="#mjx-eqn-8.1">(8.1)</a>.
The new functional becomes
$$
\begin{equation} F(u) =
\int\limits_\Omega ||\nabla u||^2 \dx -
\int\limits_\Omega fu \dx -
\frac{1}{2}\int\limits_{\partial\Omega_N}\lambda (u-\uN)^2 \ds,\quad
u\in V,
\tag{8.8}
\end{equation}
$$

In \( F(\tilde u) \), insert \( \tilde u=u+\epsilon v \),
differentiate with respect
to \( \epsilon \), and let \( \epsilon\rightarrow 0 \).
The result becomes

$$
\begin{equation} \frac{\delta F}{\delta u} =
\int\limits_\Omega \nabla u\cdot\nabla v \dx -
\int\limits_\Omega fv \dx -
\int\limits_{\partial\Omega_N}\lambda (u-\uN)v \ds
=0\tp
\tag{8.9}
\end{equation}
$$

<p>
We may then ask ourselves which equation and which boundary conditions
is solved for when minimizing this functional. We therefore do integration
by parts in order to obtain the strong formulation. We remember the Gauss-Green's 
lemma: 
$$ \int\limits_\Omega (\nabla^2 u)v\dx =
-\int\limits_\Omega \nabla u\cdot \nabla v\dx
+ \int\limits_{\partial\Omega_N} \frac{\partial u}{\partial n}v\ds\tp
$$

Hence, from <a href="#mjx-eqn-8.9">(8.9)</a>
and using Gauss-Green's lemma, we obtain: 
$$
\begin{equation} \frac{\delta F}{\delta u} =
\int\limits_\Omega - \Delta u \, v \dx -
\int\limits_\Omega fv \dx -
\int\limits_{\partial\Omega_N}\lambda (u-\uN)v \ds
+ \int\limits_{\partial\Omega} \frac{\partial u}{\partial n}v\ds
=0\tp
\tag{8.10}
\end{equation}
$$

In other words, our problem on strong form reads: 
$$
\begin{align*}
-\Delta u &= f, \quad x \in \Omega, \\ 
\frac{\partial u}{\partial n} &= \lambda (u-\uN) , \quad x \in \partial \Omega_N \tp 
\end{align*}
$$

This means that the minimizing problem corresponds to solving a problem with Robin conditions.

<p>
Nitsche's method consists of changing the above functional in order to obtain the
<em>true Dirichlet conditions</em>. As we saw in the previous calculations, integration by parts 
introduced the term \( \frac{\partial u}{\partial n} \) in the strong formulations.   
Hence, a natural idea is to subtract such a term from the functional. 

$$
\begin{equation} F(u) =
\int\limits_\Omega ||\nabla u||^2 \dx -
\int\limits_\Omega fu \dx -
\int\limits_{\partial\Omega_N} \frac{\partial u}{\partial n}  (u -\uN) \ds + \,
\frac{1}{2}\int\limits_{\partial\Omega_N}\lambda (u-\uN)^2 \ds \tp
\tag{8.11}
\end{equation}
$$

In \( F(\tilde u) \), insert \( \tilde u=u+\epsilon v \),
differentiate with respect
to \( \epsilon \), and let \( \epsilon\rightarrow 0 \).
The result becomes

$$
\begin{align*} \frac{\delta F}{\delta u} &=
\int\limits_\Omega \nabla u\cdot\nabla v \dx -
\int\limits_\Omega fv \dx \\ 
&-
\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v \ds  +  
\int\limits_{\partial\Omega_N}\frac{\partial v}{\partial n}(u-\uN) \ds +
\int\limits_{\partial\Omega_N}\lambda (u-\uN)v \ds
=0\tp
\end{align*}
$$

<p>
If we again perform integration by parts to obtain the strong form and boundary conditions, 
we get 

$$
\begin{align*} \frac{\delta F}{\delta u} =
\int\limits_\Omega -\Delta u\, v \dx -
\int\limits_\Omega fv \dx -
\int\limits_{\partial\Omega_N}\frac{\partial v}{\partial n}(u-\uN) \ds +
\int\limits_{\partial\Omega_N}\lambda (u-\uN)v \ds
=0\tp
\end{align*}
$$

<p>
In other words, our problem on strong form reads: 
$$
\begin{align*}
-\Delta u &= f, \quad x \in \Omega,  \\ 
u &= \uN, \quad x \in \partial \Omega_N \tp   
\end{align*}
$$

and the condition \( u=\uN \) is enforced both in terms of the penalty parameter \( \lambda \)
by the term 
\( \int\limits_{\partial\Omega_N}\lambda (u-\uN)v \ds \)
and in terms of equations involving the derivatives of the test function \( v \),  
\( \int\limits_{\partial\Omega_N}\frac{\partial v}{\partial n}(u-\uN) \ds \).

<p>
One may question why two terms are needed in order to enforce the boundary condition. 
In general this may not be needed and the penalty term may sometimes be dropped. 
However, the advantage of including the penalty term is that it keeps the functional
convex and the bilinear form becomes both positive and symmetric.

<p>
We summarize the final formulation in terms of a weak formulation: 

$$
\begin{align}
a(u,v) &=
\int\limits_\Omega \nabla u\cdot\nabla v \dx
-\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v \ds
- \int\limits_{\partial\Omega_N}\frac{\partial v}{\partial n}u \ds
+ \int\limits_{\partial\Omega_N}\lambda uv \ds,   \tag{8.12} \\ 
L(v) &= \int\limits_\Omega fv \dx
- \int\limits_{\partial\Omega_N}\frac{\partial v}{\partial n}\uN \ds
+ \int\limits_{\partial\Omega_N}\lambda \uN v \ds \tag{8.13} \tp 
\end{align}
$$

<h2 id="nitsche:pde:opt:Lagrange" class="anchor">Lagrange multiplier method for optimization with constraints</h2>

<p>
We consider the same problem as in the section <a href="#nitsche:pde:opt:penalty">Penalty and Nitsche's methods for optimization with constraints</a>,
but this time we want to apply a Lagrange multiplier method so we can
solve for a <em>multiplier function</em> rather than specifying a large number for a
penalty parameter and getting an approximate result.

<p>
The functional to be optimized reads

$$
F(u) =
\int\limits_\Omega ||\nabla u||^2 \dx -
\int\limits_\Omega fu \dx -
\int\limits_{\partial\Omega_N}\uN \ds +
\int\limits_{\partial\Omega_N}\lambda(u-\uN)\ds,\quad
u\in V\tp
$$

Here we have two unknown functions: \( u\in V \) in \( \Omega \) and \( \lambda\in Q \) on
\( \partial\Omega_N \). The optimization criteria are

$$ \frac{\delta F}{\delta u} = 0,\quad\frac{\delta F}{\delta\lambda} = 0\tp$$

We write \( \tilde u = u + \epsilon_u v \) and \( \tilde\lambda = \lambda +
\epsilon_\lambda p \), where \( v \) is an arbitrary function in \( V \) and \( p \) is an
arbitrary function in \( Q \). Notice that \( V \) is here a usual
function space with functions defined on \( \Omega \), while on 
the other hand is a function space defined only on the
surface \( \Omega_N \). 
We insert the expressions for \( \tilde u \) and
\( \tilde\lambda \) for \( u \) and \( \lambda \) and compute

$$
\begin{align*}
\frac{\delta F}{\delta u} &=
\lim_{\epsilon_u\rightarrow 0}\frac{dF}{d\epsilon_u} =
\int\limits_{\Omega}\nabla u\cdot\nabla v\dx -
\int\limits_\Omega fv \dx -
\int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v\ds  +
\int\limits_{\partial\Omega_N}\lambda(u-\uN)\ds = 0,\\ 
\frac{\delta F}{\delta \lambda} &=
\lim_{\epsilon_\lambda\rightarrow 0}\frac{dF}{d\epsilon_\lambda} =
\int\limits_{\partial\Omega_N} (u-\uN) p\ds = 0 \tp
\end{align*}
$$

<p>
These equations can be written as a linear system of equations: 
Find \( u, \lambda \in V\times Q \) such that  
$$
\begin{align*}
a(u,v) + b(\lambda, v) &= L_u(v),   \\ 
b(u, p)                &= L_\lambda(\lambda) ,  
\end{align*}
$$

for all test functions \( v\in V \) and \( p \in Q \) and 
$$
\begin{align*}
a(u,v)        &= \int\limits_{\Omega}\nabla u\cdot\nabla v\dx - \int\limits_{\partial\Omega_N}\frac{\partial u}{\partial n}v\ds, \\ 
b(\lambda, v) &= \int\limits_{\partial \Omega_N} \lambda v \ds, \\ 
L_u(v)          &= \int\limits_\Omega fv \dx, \\ 
L_\lambda(\lambda)    &= \int\limits_{\partial\Omega_N} \uN \lambda \ds . 
\end{align*}
$$

<p>
Letting 
\( u=\sum_{j\in\If} c_j\baspsi^{(u)}_j \), 
\( \lambda=\sum_{j\in\If} c_j\baspsi^{(\lambda)}_j \), 
\( v =  \baspsi^{(v)}_i \), and 
\( p =  \baspsi^{(p)}_i \), we obtain the following system 
of linear equations   
$$
A\, c = \left[ \begin{array}{cc} A^{(u,u)} & A^{(\lambda,u)}\\ A^{(u,\lambda)} & 0 \end{array} \right]
\left[ \begin{array}{c} c^{(u)} \\ c^{(\lambda)} \end{array} \right] =  
\left[ \begin{array}{c} b^{(u)} \\ b^{(\lambda)} \end{array} \right] 
= b, 
$$

where 
$$
\begin{align*}
A^{(u,u)}_{i,j} &=  a(\baspsi^{(u)}_j, \baspsi^{(u)}_i),  \\ 
A^{(u,\lambda)}_{i,j} &=  b(\baspsi^{(u)}_j, \baspsi^{(\lambda)}_i),  \\ 
A^{(\lambda,u)}_{i,j} &= A^{(u,\lambda)}_{j,i}, \\ 
b^{(u)}_i &= L_u(\baspsi^{(u)}_i), \\ 
b^{(\lambda)}_i &= L_\lambda(\baspsi^{(\lambda)}_i), \tp
\end{align*}
$$

<h2 id="nitsche:pde:opt:1Dex" class="anchor">Example: 1D problem</h2>
<b>Nitsche method.</b>

<p>
Let us do hand calculations to demonstrate weakly enforced boundary
conditions via a Nitsche's method and via the Lagrange multiplier method.
We study the simple problem \( -u'' = 2 \) on \( [0,1] \), c.f. <a href="#mjx-eqn-8.12">(8.12)</a>-<a href="#mjx-eqn-8.13">(8.13)</a>, with boundary
conditions \( u(0)=0 \) and \( u(1)=1 \).
$$
\begin{align*}
a(u,v) &=
\int_0^1  u_x \, v_x \dx
-[u_x v]_0^1
-[v_x u]_0^1
+[\lambda uv]_0^1  \\ 
L(v) &= \int_0^1 fv \dx
- [v_x \uN]_0^1
+ [\lambda \uN v]_0^1
\tp
\end{align*}
$$

<p>
A uniform mesh with nodes
\( x_i=i\Delta x \) is introduced, numbered from left to right:
\( i=0,\ldots,N_x \). The approximate value of \( u \) at \( x_i \) is denoted
by \( c_i \), and in general the approximation to \( u \) is \( \sum_{i=0}^{N_x}
\varphi_i(x)c_i \).

<p>
The elements at the boundaries needs special attention. Let us consider 
the element 0 defined on \( [0,h] \). The basis functions are 
\( \varphi_0(x) = 1 - x/h \) and 
\( \varphi_1(x) = x/h \). Hence, 
\( \varphi_0|_{x=0} = 1 \), 
\( \varphi'_0|_{x=0} = -1/h \), 
\( \varphi_1|_{x=0} = 0 \), and  
\( \varphi'_1|_{x=0} = 1/h \). Therefore, for element 0 we obtain the element matrix
$$
\begin{align*}
A^{(0)}_{0, 0} &= \lambda + \frac{3}{h}, \\ 
A^{(0)}_{0, 1} &= - \frac{2}{h}, \\ 
A^{(0)}_{1, 0} &= - \frac{2}{h}, \\ 
A^{(0)}_{1, 1} &= \frac{1}{h} \tp
\end{align*}
$$

The interior elements (\( e=1\ldots N_e-2 \)) result in the following element matrices
$$
\begin{align*}
A^{(e)}_{0, 0} &= \frac{1}{h}, 
&A^{(e)}_{0, 1} = - \frac{1}{h},\\ 
A^{(e)}_{1, 0} &= - \frac{1}{h}, 
&A^{(e)}_{1, 1} = \frac{1}{h} \tp
\end{align*}
$$

While the element at the boundary \( x=1 \) result in a element matrix similar to \( A^0 \)
except that 0 and 1 are swapped. The calculations are straightforward in <code>sympy</code>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span> 
x, h, lam <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&quot;x h \lambda&quot;</span>)
basis <span style="color: #666666">=</span> [<span style="color: #666666">1</span> <span style="color: #666666">-</span> x<span style="color: #666666">/</span>h, x<span style="color: #666666">/</span>h]

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(basis)): 
  phi_i <span style="color: #666666">=</span> basis[i]
  <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(basis)): 
    phi_j <span style="color: #666666">=</span> basis[j]
    a  <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(sym<span style="color: #666666">.</span>diff(phi_i, x)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(phi_j, x), (x, <span style="color: #666666">0</span>, h))
    a <span style="color: #666666">-=</span> (sym<span style="color: #666666">.</span>diff(phi_i, x)<span style="color: #666666">*</span>phi_j)<span style="color: #666666">.</span>subs(x,<span style="color: #666666">0</span>) 
    a <span style="color: #666666">-=</span> (sym<span style="color: #666666">.</span>diff(phi_j, x)<span style="color: #666666">*</span>phi_i)<span style="color: #666666">.</span>subs(x,<span style="color: #666666">0</span>) 
    a <span style="color: #666666">+=</span> (lam<span style="color: #666666">*</span>phi_j<span style="color: #666666">*</span>phi_i)<span style="color: #666666">.</span>subs(x,<span style="color: #666666">0</span>) 
</pre></div>
<p>
In the symmetric variant of Nitsche's method that we have presented here, there is a need for a
positive penalty parameter \( \lambda \) in order for the method to work. A natural question 
is therefore how sensitive the results are to this penalty parameter.    
The following code implements Nitsche's method in FEniCS and tests various penalty parameters.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span> 

mesh <span style="color: #666666">=</span> UnitIntervalMesh(<span style="color: #666666">100</span>) 
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&quot;Lagrange&quot;</span>, <span style="color: #666666">1</span>) 
u <span style="color: #666666">=</span> TrialFunction(V) 
v <span style="color: #666666">=</span> TestFunction(V)

lams <span style="color: #666666">=</span> [<span style="color: #666666">1.001</span>, <span style="color: #666666">1.01</span>, <span style="color: #666666">1.1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">10</span>, <span style="color: #666666">100</span>]
<span style="color: #008000; font-weight: bold">for</span> lam <span style="color: #AA22FF; font-weight: bold">in</span> lams: 
    lam <span style="color: #666666">=</span> Constant(lam) 
    h <span style="color: #666666">=</span> CellDiameter(mesh)
    n <span style="color: #666666">=</span> FacetNormal(mesh)
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;-12*pow(x[0], 2)&quot;</span>, degree<span style="color: #666666">=2</span>) 
    u0 <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;pow(x[0],4)&quot;</span>, degree<span style="color: #666666">=4</span>)

    a <span style="color: #666666">=</span> dot(grad(v), grad(u))<span style="color: #666666">*</span>dx \
       <span style="color: #666666">-</span> dot(grad(v), u<span style="color: #666666">*</span>n)<span style="color: #666666">*</span>ds \
       <span style="color: #666666">-</span> dot(v<span style="color: #666666">*</span>n, grad(u))<span style="color: #666666">*</span>ds \
       <span style="color: #666666">+</span> (lam<span style="color: #666666">/</span>h)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>u<span style="color: #666666">*</span>ds
    L <span style="color: #666666">=</span> v<span style="color: #666666">*</span>f<span style="color: #666666">*</span>dx <span style="color: #666666">-</span> u0<span style="color: #666666">*</span>dot(grad(v), n)<span style="color: #666666">*</span>ds <span style="color: #666666">+</span> (lam<span style="color: #666666">/</span>h)<span style="color: #666666">*</span>u0<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds

    U <span style="color: #666666">=</span> Function(V)
    solve(a <span style="color: #666666">==</span> L, U) 

    plt<span style="color: #666666">.</span>plot(V<span style="color: #666666">.</span>tabulate_dof_coordinates(), U<span style="color: #666666">.</span>vector()<span style="color: #666666">.</span>get_local())

plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&quot;lam=</span><span style="color: #BB6688; font-weight: bold">%4.3f</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">%</span>lam <span style="color: #008000; font-weight: bold">for</span> lam <span style="color: #AA22FF; font-weight: bold">in</span> lams], loc<span style="color: #666666">=2</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Figure <a href="#nitsche:fig:penalty">85</a> displays the results obtained by running the above script.  
As we see in Figure <a href="#nitsche:fig:penalty">85</a> and the zoom in Figure <a href="#nitsche:fig:penalty:zoom">86</a>, Nitsche's method
is not very sensitive to the value of the penalty parameter as long as it is above a certain threshold. In 
our 1D example, the threshold seems to be \( 1/h \). Setting the parameter to \( 1/h \) or lower makes the solution
blow up and there are some artifacts when setting the parameter very close to \( 1/h \) but 
we see that \( 2/h \), \( 10/h \) and \( 100/h \) gives produce visually identical solutions. This is generally, the
case with Nitsche's method although the threshold may depend on the application.

<p>
<center> <!-- figure label: --> <div id="nitsche:fig:penalty"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 85:  Solution of the Poisson problem using Nitsche's method for various penalty parameters.  <!-- caption label: nitsche:fig:penalty --> </p></center>
<p><img src="fig/nitsche1D.png" align="bottom" width=200></p>
</center>

<p>
<center> <!-- figure label: --> <div id="nitsche:fig:penalty:zoom"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 86:  A zoom towards the right boundary of the figure in <a href="#nitsche:fig:penalty">85</a>.  <!-- caption label: nitsche:fig:penalty:zoom --> </p></center>
<p><img src="fig/nitsche1D_zoom.png" align="bottom" width=200></p>
</center>

<p>
<b>Lagrange multiplier method.</b>

<p>
For the Lagrange multiplier method we need a function space \( Q \) defined on the boundary 
of the domain. In 1D with \( \Omega=(0,1) \) the boundary is \( x=0 \) and \( x=1 \). Hence, \( Q \)
can be spanned by two basis functions \( \lambda_0 \) and \( \lambda_1 \). These functions
should be such that \( \lambda_0=1 \) for \( x=0 \) and zero everywhere else, while
\( \lambda_1=1 \) for \( x=1 \) and zero everywhere else. 
Hence, we may use the following function

$$ \lambda(x) = \lambda_0 \varphi_0(x) + \lambda_{N_x}\varphi_{N_x}(x)\tp
$$

<h2 id="___sec311" class="anchor">Example: adding a constraint in a Neumann problem </h2>

<p>
The Poisson Neumann problem reads:  
$$
\begin{align*}
-\Delta u &= f, \quad x\in\Omega&, \\ 
\frac{\partial u}{\partial n} &= 0,  \quad x\in \partial \Omega&,   
\end{align*}
$$

It is a singular problem with a one-dimensional kernel. To see this, we
remark that if \( u \) is a solution to the problem then \( \hat{u} = u + C \), 
where \( C \) is any number, is also a solution since
\( -\Delta \hat{u} = -\Delta u - \Delta C = -\Delta u = f \) and
$ \frac{\partial \hat{u}}{\partial n} =  \frac{\partial {u}}{\partial n}+  \frac{\partial C}{\partial n}    
= \frac{\partial {u}}{\partial n} = 0 $. As the PDE is singular, also the corresponding finite element matrix
will be singular and this frequently (but not always) cause problems when solving the linear system.

<p>
There are two main remedies for this problem 1) to add an equation that fixates the solution in one point
to the linear system, i.e., set \( u(x) = 0 \) in some point \( x \) either at the boundary or in the interior  
and 2) to enforce that \( \int_\Omega u \dx =  0 \) by using a Lagrange multiplier. The first method is
the most used method as it is easy to implement. The method often works well but 
it is not a bullet-proof procedure, as we will  illustrate.

<p>
The following code implements the Poisson Neumann problem in FEniCS and fixates the solution in one point. 
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span> 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">boundary</span>(x, on_boundary): 
  <span style="color: #008000; font-weight: bold">if</span> near(x[<span style="color: #666666">0</span>],<span style="color: #666666">0.3</span>) <span style="color: #AA22FF; font-weight: bold">and</span> near(x[<span style="color: #666666">1</span>],<span style="color: #666666">0</span>): <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>

mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">10</span>,<span style="color: #666666">10</span>) 
V <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&quot;Lagrange&quot;</span>, <span style="color: #666666">1</span>) 
u <span style="color: #666666">=</span> TrialFunction(V) 
v <span style="color: #666666">=</span> TestFunction(V)

n <span style="color: #666666">=</span> FacetNormal(mesh)
f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;pow(3.14,2)*cos(3.14*x[0])+1&quot;</span>, degree<span style="color: #666666">=4</span>) 
ue <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;cos(3.14*x[0])-1&quot;</span>, degree<span style="color: #666666">=4</span>)
du <span style="color: #666666">=</span> Expression([<span style="color: #BA2121">&quot;3.14*sin(3.14*x[0])&quot;</span>, <span style="color: #BA2121">&quot;0&quot;</span>], degree<span style="color: #666666">=4</span>)

a <span style="color: #666666">=</span> dot(grad(v), grad(u))<span style="color: #666666">*</span>dx 
L <span style="color: #666666">=</span> v<span style="color: #666666">*</span>f<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> inner(du,n)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds 

point_condition <span style="color: #666666">=</span> DirichletBC(V, ue, boundary, <span style="color: #BA2121">&quot;pointwise&quot;</span>)
u <span style="color: #666666">=</span> Function(V, name<span style="color: #666666">=</span><span style="color: #BA2121">&quot;u&quot;</span>)
solve(a <span style="color: #666666">==</span> L, u, point_condition)
</pre></div>
<p>
We remark that we fixate the solution in one point here by using <code>DirichletBC</code> where we specify <code>pointwise</code> application 
and further that we in this example know that \( (0.3,0) \) is a vertex in the mesh.

<p>
<center> <!-- figure label: --> <div id="nitsche:fig:fixpoint:exact"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 87:  The exact solution of the Poisson Neumann problem.   <!-- caption label: nitsche:fig:fixpoint:exact --> </p></center>
<p><img src="fig/neumann_fixpoint_exact.png" align="bottom" width=200></p>
</center>

<p>
<center> <!-- figure label: --> <div id="nitsche:fig:fixpoint"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 88:  The computed solution of the Poisson Neumann problem with \( u \) being fixated at \( (0.3,0) \).  <!-- caption label: nitsche:fig:fixpoint --> </p></center>
<p><img src="fig/neumann_fixpoint.png" align="bottom" width=200></p>
</center>

<p>
Figure <a href="#nitsche:fig:fixpoint:exact">87</a> displays the exact solution the Poisson problem while Figure <a href="#nitsche:fig:fixpoint">88</a> shows the resulting solution of the problem implemented in the FEniCS code listed above. Clearly, the numerical solution is wrong and 
our approach of fixating the solution in (0.3,0) has destroyed the solution in large parts of the domain. In our case the problem is however easily fixed
by ensuring that the true solution \( u \) and right-hand side \( f \) satisfy \( \int_\Omega u \dx = 0 \) and \( \int_\Omega f \dx = 0 \), respectively, and 
that the fixation is compatible with this. While ensuring compatibility is quite easy for scalar PDE problems, it may be more difficult 
for systems of PDEs where determining the appropriate conditions is more involved.

<p>
\newcommand{\R}{\mathbb{R}}
A more general strategy is to remove the kernel by a Lagrange multiplier, requiring that 
\( \int_\Omega u \dx = 0 \).  The resulting equations can be written as a linear system of equations: 
Find \( u, \lambda \in V\times \R \) such that  
$$
\begin{align*}
a(u,v) + b(v, c) &= L_u(v),   \\ 
b(u, d)                &= L_c(d) ,  
\end{align*}
$$

for all test functions \( v\in V \) and \( d\in \R \) and 
$$
\begin{align*}
a(u,v)        &= \int\limits_{\Omega}\nabla u\cdot\nabla v\dx  \\ 
b(v, c) &= \int\limits_\Omega c v \dx, \\ 
L_u(v)          &= \int\limits_\Omega fv \dx, \\ 
L_c(d)    &= 0  . 
\end{align*}
$$

<p>
Letting 
\( u=\sum_{j\in\If} c_j\baspsi^{(u)}_j \), 
\( v =  \baspsi^{(v)}_i \), and 
\( c, d \) be two arbitrary constants, we obtain the following system 
of linear equations   
$$
A\, c = \left[ \begin{array}{cc} A^{(u,u)} & A^{(c,u)}\\ A^{(u,c)} & 0 \end{array} \right]
\left[ \begin{array}{c} c^{(u)} \\ c \end{array} \right] =  
\left[ \begin{array}{c} b^{(u)} \\ 0 \end{array} \right] 
= b, 
$$

where 
$$
\begin{align*}
A^{(u,u)}_{i,j} &=  a(\baspsi^{(u)}_j, \baspsi^{(u)}_i),  \\ 
A^{(u,c)}_{i,j} &=  b(\baspsi^{(u)}_j, c),  \\ 
A^{(c,u)}_{i,j} &= A^{(u,c)}_{j,i}, \\ 
b^{(u)}_i &= L_u(\baspsi^{(u)}_i) \tp \\ 
\end{align*}
$$

<p>
The corresponding code in FEniCS resembles the mathematical problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dolfin</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span> 

mesh <span style="color: #666666">=</span> UnitSquareMesh(<span style="color: #666666">10</span>,<span style="color: #666666">10</span>) 
L <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&quot;Lagrange&quot;</span>, mesh<span style="color: #666666">.</span>ufl_cell(), <span style="color: #666666">1</span>) 
R <span style="color: #666666">=</span> FiniteElement(<span style="color: #BA2121">&quot;R&quot;</span>, mesh<span style="color: #666666">.</span>ufl_cell(),  <span style="color: #666666">0</span>)
W <span style="color: #666666">=</span> FunctionSpace(mesh, L<span style="color: #666666">*</span>R)

(u,c) <span style="color: #666666">=</span> TrialFunction(W) 
(v,d) <span style="color: #666666">=</span> TestFunction(W)

n <span style="color: #666666">=</span> FacetNormal(mesh)

f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;pow(3.14,2)*cos(3.14*x[0])+1&quot;</span>, degree<span style="color: #666666">=4</span>) 
ue <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&quot;cos(3.14*x[0])-1&quot;</span>, degree<span style="color: #666666">=4</span>)
du <span style="color: #666666">=</span> Expression([<span style="color: #BA2121">&quot;3.14*sin(3.14*x[0])&quot;</span>, <span style="color: #BA2121">&quot;0&quot;</span>], degree<span style="color: #666666">=4</span>)

a <span style="color: #666666">=</span> dot(grad(v), grad(u))<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> c<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx  <span style="color: #666666">+</span> d<span style="color: #666666">*</span>u<span style="color: #666666">*</span>dx  
L <span style="color: #666666">=</span> v<span style="color: #666666">*</span>f<span style="color: #666666">*</span>dx <span style="color: #666666">+</span> inner(du,n)<span style="color: #666666">*</span>v<span style="color: #666666">*</span>ds 

w <span style="color: #666666">=</span> Function(W)
solve(a <span style="color: #666666">==</span> L, w) 
(u,c) <span style="color: #666666">=</span> w<span style="color: #666666">.</span>split()
</pre></div>
<p>
The solution produced by running this script is visually identical to the exact solution.

<p>

<center><h1 id="ch:nonlin" class="anchor">Nonlinear problems</h1></center> <!-- chapter heading -->

<h1 id="nonlin:timediscrete:logistic" class="anchor">Introduction of basic concepts</h1>

<h2 id="___sec314" class="anchor">Linear versus nonlinear equations </h2>

<h3 id="___sec315" class="anchor">Algebraic equations </h3>

<p>
A linear, scalar, algebraic equation in \( x \) has the form

$$ ax + b = 0,$$

for arbitrary real constants \( a \) and \( b \). The unknown is a number \( x \).
All other algebraic equations, e.g., \( x^2 + ax + b = 0 \), are nonlinear.
The typical feature in a nonlinear algebraic equation is that the unknown
appears in products with itself, like \( x^2 \) or
in functions that are infinite sums of products, like \( e^x = 1 + x +\half x^2 +
\frac{1}{3!}x^3 + \cdots \).

<p>
We know how to solve a linear algebraic equation, \( x=-b/a \), but there are
no general closed formulas for finding the exact solutions of
nonlinear algebraic equations, except for very special cases (quadratic
equations constitute a primary example). A nonlinear algebraic equation
may have no solution, one solution, or many solutions. The tools for
solving nonlinear algebraic equations are <em>iterative methods</em>, where
we construct a series of linear equations, which we know how to solve,
and hope that the solutions of the linear equations converge to a
solution of the nonlinear equation we want to solve.
Typical methods for nonlinear algebraic equation equations are
Newton's method, the Bisection method, and the Secant method.

<h3 id="___sec316" class="anchor">Differential equations </h3>

<p>
The unknown in a differential equation is a function and not a number.
In a linear differential equation, all terms involving the unknown function
are linear in the unknown function or its derivatives. Linear here means that
the unknown function, or a derivative of it, is multiplied by a number or
a known function. All other differential equations are non-linear.

<p>
The easiest way to see if an equation is nonlinear, is to spot nonlinear terms
where the unknown function or its derivatives are multiplied by
each other. For example, in

$$ u^{\prime}(t) = -a(t)u(t) + b(t),$$

the terms involving the unknown function \( u \) are linear: \( u^{\prime} \) contains
the derivative of the unknown function multiplied by unity, and \( au \) contains
the unknown function multiplied by a known function.
However,
$$ u^{\prime}(t) = u(t)(1 - u(t)),$$

is nonlinear because of the term \( -u^2 \) where the unknown function is
multiplied by itself. Also

$$ \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0,$$

is nonlinear because of the term \( uu_x \) where the unknown
function appears in a product with its derivative.
(Note here that we use different notations for derivatives: \( u^{\prime} \)
or \( du/dt \) for a function \( u(t) \) of one variable,
\( \frac{\partial u}{\partial t} \) or \( u_t \) for a function of more than one
variable.)

<p>
Another example of a nonlinear equation is

$$ u^{\prime\prime} + \sin(u) =0,$$

because \( \sin(u) \) contains products of \( u \), which becomes clear
if we expand the function in a Taylor series:

$$ \sin(u) = u - \frac{1}{3} u^3 + \ldots$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Mathematical proof of linearity.</b>
To really prove mathematically that some differential equation
in an unknown \( u \) is linear,
show for each term \( T(u) \) that with \( u = au_1 + bu_2 \) for
constants \( a \) and \( b \),

$$ T(au_1 + bu_2) = aT(u_1) + bT(u_2)\tp $$

<p>
For example, the term \( T(u) = (\sin^2 t)u'(t) \) is linear because

$$
\begin{align*}
T(au_1 + bu_2) &= (\sin^2 t)(au_1(t) + b u_2(t))'\\ 
& = a(\sin^2 t)u_1'(t) + b(\sin^2 t)u_2'(t)\\ 
& =aT(u_1) + bT(u_2)\tp
\end{align*}
$$

However, \( T(u)=\sin u \) is nonlinear because

$$ T(au_1 + bu_2) = \sin (au_1 + bu_2) \neq a\sin u_1 + b\sin u_2\tp$$
</div>


<h2 id="___sec317" class="anchor">A simple model problem </h2>

<p>
A series of forthcoming examples will explain how to tackle
nonlinear differential equations with various techniques.
We start with the (scaled) logistic equation as model problem:

$$
\begin{equation}
u^{\prime}(t) = u(t)(1 - u(t)) \tp
\tag{9.1}
\end{equation}
$$

This is a nonlinear ordinary differential equation (ODE)
which will be solved by
different strategies in the following.
Depending on the chosen
time discretization of <a href="#mjx-eqn-9.1">(9.1)</a>,
the mathematical problem to be solved at every time level will
either be a linear algebraic equation or a nonlinear
algebraic equation.
In the former case, the time discretization method transforms
the nonlinear ODE into linear subproblems at each time level, and
the solution is straightforward to find since linear algebraic equations
are easy to solve. However,
when the time discretization leads to nonlinear algebraic equations, we
cannot (except in very rare cases) solve these without turning to
approximate, iterative solution methods.

<p>
The next subsections introduce various methods
for solving nonlinear differential equations,
using <a href="#mjx-eqn-9.1">(9.1)</a> as model. We shall go through
the following set of cases:

<ul>
 <li> explicit time discretization methods (with no need to
   solve nonlinear algebraic equations)</li>
 <li> implicit Backward Euler time discretization, leading to nonlinear
   algebraic equations solved by</li>

<ul>
  <li> an exact analytical technique</li>
  <li> Picard iteration based on manual linearization</li>
  <li> a single Picard step</li>
  <li> Newton's method</li>
</ul>

 <li> implicit Crank-Nicolson time discretization and linearization
   via a geometric mean formula</li>
</ul>

Thereafter, we compare the performance of the various approaches. Despite
the simplicity of <a href="#mjx-eqn-9.1">(9.1)</a>, the conclusions
reveal typical features of the various methods in much more complicated
nonlinear PDE problems.

<h2 id="nonlin:timediscrete:logistic:FE" class="anchor">Linearization by explicit time discretization</h2>

<p>
Time discretization methods are divided into explicit and implicit
methods. Explicit methods lead to a closed-form formula for
finding new values of the unknowns, while implicit methods give
a linear or nonlinear system of equations that couples (all) the
unknowns at a new time level. Here we shall demonstrate that
explicit methods may constitute an efficient way to deal with nonlinear
differential equations.

<p>
The Forward Euler
method is an explicit method. When applied to
<a href="#mjx-eqn-9.1">(9.1)</a>, sampled at \( t=t_n \), it results in

$$ \frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n),$$

which is a <em>linear</em> algebraic
equation for the unknown value \( u^{n+1} \) that we can easily solve:

$$ u^{n+1} = u^n + \Delta t\,u^n(1 - u^n)\tp$$

The nonlinearity in the original equation poses in this case no difficulty
in the discrete algebraic equation.
Any other explicit scheme in time will also give only linear
algebraic equations
to solve. For example, a typical 2nd-order Runge-Kutta method
for <a href="#mjx-eqn-9.1">(9.1)</a> leads to the following
formulas:

$$
\begin{align*}
u^* &= u^n + \Delta t u^n(1 - u^n),\\ 
u^{n+1} &= u^n + \Delta t \half \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right)\tp
\end{align*}
$$

The first step is linear in the unknown \( u^* \). Then \( u^* \) is
known in the next step, which is linear in the unknown \( u^{n+1} \) .
For this scheme we have an explicit formula for the unknown 
and the scheme is therefore called an <em>explicit scheme</em>.

<h2 id="nonlin:timediscrete:logistic:roots" class="anchor">Exact solution of nonlinear algebraic equations</h2>

<p>
Switching to a Backward Euler scheme for
<a href="#mjx-eqn-9.1">(9.1)</a>,

$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n),
\tag{9.2}
\end{equation}
$$

results in a nonlinear algebraic equation for the unknown value \( u^n \).
The equation is of quadratic type:

$$ \Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0, $$

and may be solved exactly by the well-known formula for such equations.
Before we do so, however, we will
introduce a shorter, and often cleaner, notation for
nonlinear algebraic equations at a given time level. The notation is
inspired by the natural notation (i.e., variable names) used in a
program, especially in more advanced partial differential equation
problems. The unknown in the algebraic equation is denoted by \( u \),
while \( u^{(1)} \) is the value of the unknown at the previous time level
(in general, \( u^{(\ell)} \) is the value of the unknown \( \ell \) levels
back in time). The notation will be frequently used in later
sections. What is meant by \( u \) should be evident from the context: \( u \)
may be 1) the exact solution of the ODE/PDE problem,
2) the numerical approximation to the exact solution, or 3) the unknown
solution at a certain time level.

<p>
The quadratic equation for the unknown \( u^n \) in
<a href="#mjx-eqn-9.2">(9.2)</a> can, with the new
notation, be written

$$
\begin{equation}
F(u) = \Delta t u^2 + (1-\Delta t)u - u^{(1)} = 0\tp
\tag{9.3}
\end{equation}
$$

The solution is readily found to be

$$
\begin{equation}
u = \frac{1}{2\Delta t}
\left(-1+\Delta t \pm \sqrt{(1-\Delta t)^2 - 4\Delta t u^{(1)}}\right)
\tp
\tag{9.4}
\end{equation}
$$

<p>
Now we encounter a fundamental challenge with nonlinear
algebraic equations:
the equation may have more than one solution. How do we pick the right
solution? This is in general a hard problem.
In the present simple case, however, we can analyze the roots mathematically
and provide an answer. The idea is to expand the roots
in a series in \( \Delta t \) and truncate after the linear term since
the Backward Euler scheme will introduce an error proportional to
\( \Delta t \) anyway. Using <code>sympy</code> we find the following Taylor series
expansions of the roots:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dt, u_1, u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;dt u_1 u&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> r1, r2 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve(dt<span style="color: #666666">*</span>u<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>dt)<span style="color: #666666">*</span>u <span style="color: #666666">-</span> u_1, u)  <span style="color: #408080; font-style: italic"># find roots</span>
<span style="color: #666666">&gt;&gt;&gt;</span> r1
(dt <span style="color: #666666">-</span> sqrt(dt<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">4*</span>dt<span style="color: #666666">*</span>u_1 <span style="color: #666666">-</span> <span style="color: #666666">2*</span>dt <span style="color: #666666">+</span> <span style="color: #666666">1</span>) <span style="color: #666666">-</span> <span style="color: #666666">1</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>dt)
<span style="color: #666666">&gt;&gt;&gt;</span> r2
(dt <span style="color: #666666">+</span> sqrt(dt<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">4*</span>dt<span style="color: #666666">*</span>u_1 <span style="color: #666666">-</span> <span style="color: #666666">2*</span>dt <span style="color: #666666">+</span> <span style="color: #666666">1</span>) <span style="color: #666666">-</span> <span style="color: #666666">1</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>dt)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span>(r1<span style="color: #666666">.</span>series(dt, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>))    <span style="color: #408080; font-style: italic"># 2 terms in dt, around dt=0</span>
<span style="color: #666666">-1/</span>dt <span style="color: #666666">+</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> u_1 <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(u_1<span style="color: #666666">**2</span> <span style="color: #666666">-</span> u_1) <span style="color: #666666">+</span> O(dt<span style="color: #666666">**2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span>(r2<span style="color: #666666">.</span>series(dt, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>))
u_1 <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">-</span>u_1<span style="color: #666666">**2</span> <span style="color: #666666">+</span> u_1) <span style="color: #666666">+</span> O(dt<span style="color: #666666">**2</span>)
</pre></div>
<p>
We see that the <code>r1</code> root, corresponding to
a minus sign in front of the square root in
<a href="#mjx-eqn-9.4">(9.4)</a>,
behaves as \( 1/\Delta t \) and will therefore
blow up as \( \Delta t\rightarrow 0 \)! Since we know that \( u \) takes on
finite values, actually it is less than or equal to 1,
only the <code>r2</code> root is of relevance in this case: as \( \Delta t\rightarrow 0 \),
\( u\rightarrow u^{(1)} \), which is the expected result.

<p>
For those who are not well experienced with approximating mathematical
formulas by series expansion, an alternative method of investigation
is simply to compute the limits of the two roots as \( \Delta t\rightarrow 0 \)
and see if a limit unreasonable:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span>(r1<span style="color: #666666">.</span>limit(dt, <span style="color: #666666">0</span>))
<span style="color: #666666">-</span>oo
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span>(r2<span style="color: #666666">.</span>limit(dt, <span style="color: #666666">0</span>))
u_1
</pre></div>

<h2 id="___sec320" class="anchor">Linearization </h2>

<p>
When the time integration of an ODE results in a nonlinear algebraic
equation, we must normally find its solution by defining a sequence
of linear equations and hope that the solutions of these linear equations
converge to the desired solution of the nonlinear algebraic equation.
Usually, this means solving the linear equation repeatedly in an
iterative fashion.
Alternatively, the nonlinear equation can sometimes be approximated by one
linear equation, and consequently there is no need for iteration.

<p>
Constructing a linear equation from a nonlinear one requires
<em>linearization</em> of each nonlinear term. This can be done manually
as in Picard iteration, or fully algorithmically as in Newton's method.
Examples will best illustrate how to linearize nonlinear problems.

<h2 id="nonlin:timediscrete:logistic:Picard" class="anchor">Picard iteration</h2>

<p>
Let us write <a href="#mjx-eqn-9.3">(9.3)</a> in a
more compact form

$$ F(u) = au^2 + bu + c = 0,$$

with \( a=\Delta t \), \( b=1-\Delta t \), and \( c=-u^{(1)} \).
Let \( u^{-} \) be an available approximation of the unknown \( u \).

<p>
Then we can linearize the term \( u^2 \) simply by writing
\( u^{-}u \). The resulting equation, \( \hat F(u)=0 \), is now linear
and hence easy to solve:

$$ F(u)\approx\hat F(u) = au^{-}u + bu + c = 0\tp$$

Since the equation \( \hat F=0 \) is only approximate, the solution \( u \)
does not equal the exact solution \( \uex \) of the exact
equation \( F(\uex)=0 \), but we can hope that \( u \) is closer to
\( \uex \) than \( u^{-} \) is, and hence it makes sense to repeat the
procedure, i.e., set \( u^{-}=u \) and solve \( \hat F(u)=0 \) again.
There is no guarantee that \( u \) is closer to \( \uex \) than \( u^{-} \),
but this approach has proven to be effective in a wide range of
applications.

<p>
The idea of turning a nonlinear equation into a linear one by
using an approximation \( u^{-} \) of \( u \) in the nonlinear terms is
a widely used approach that goes under many names:
<em>fixed-point iteration</em>, the method of <em>successive substitutions</em>,
<em>nonlinear Richardson iteration</em>, and <em>Picard iteration</em>.
We will stick to the latter name.

<p>
Picard iteration for solving the nonlinear equation
arising from the Backward Euler discretization of the logistic
equation can be written as

$$ u = -\frac{c}{au^{-} + b},\quad u^{-}\ \leftarrow\ u\tp$$

The \( \leftarrow \) symbols means assignment (we set \( u^{-} \) equal to
the value of \( u \)).
The iteration is started with the value of the unknown at the
previous time level: \( u^{-}=u^{(1)} \).

<p>
Some prefer an explicit iteration counter as superscript
in the mathematical notation. Let \( u^k \) be the computed approximation
to the solution in iteration \( k \). In iteration \( k+1 \) we want
to solve

$$ au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots$$

Since we need to perform the iteration at every time level, the
time level counter is often also included:

$$ au^{n,k} u^{n,k+1} + bu^{n,k+1} - u^{n-1} = 0\quad\Rightarrow\quad u^{n,k+1}
= \frac{u^{n-1}}{au^{n,k} + b},\quad k=0,1,\ldots,$$

with the start value \( u^{n,0}=u^{n-1} \) and the final converged value
\( u^{n}=u^{n,k} \) for sufficiently large \( k \).

<p>
However, we will normally apply a mathematical notation in our
final formulas that is as close as possible to what we aim to write
in a computer code and then it becomes natural to use \( u \) and \( u^{-} \)
instead of \( u^{k+1} \) and \( u^k \) or \( u^{n,k+1} \) and \( u^{n,k} \).

<h3 id="___sec322" class="anchor">Stopping criteria </h3>

<p>
The iteration method can typically be terminated when the change
in the solution is smaller than a tolerance \( \epsilon_u \):

$$ |u - u^{-}| \leq\epsilon_u,$$

or when the residual in the equation is sufficiently small (\( < \epsilon_r \)),
$$ |F(u)|= |au^2+bu + c| < \epsilon_r\tp$$

<h3 id="___sec323" class="anchor">A single Picard iteration </h3>

<p>
Instead of iterating until a stopping criterion is fulfilled, one may
iterate a specific number of times. Just one Picard iteration is
popular as this corresponds to the intuitive idea of approximating a
nonlinear term like \( (u^n)^2 \) by \( u^{n-1}u^n \). This follows from the
linearization \( u^{-}u^n \) and the initial choice of \( u^{-}=u^{n-1} \) at
time level \( t_n \). In other words, a single Picard iteration
corresponds to using the solution at the previous time level to
linearize nonlinear terms. The resulting discretization becomes (using
proper values for \( a \), \( b \), and \( c \))

$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^{n-1}),
\tag{9.5}
\end{equation}
$$

which is a linear algebraic equation in the unknown \( u^n \), making
it easy to solve for \( u^n \) without any need for
any alternative notation.

<p>
We shall later refer to the strategy of taking one Picard step, or
equivalently, linearizing terms with use of the solution at the
previous time step, as the <em>Picard1</em> method. It is a widely used
approach in science and technology, but with some limitations if
\( \Delta t \) is not sufficiently small (as will be illustrated later).

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>

<p>
Equation <a href="#mjx-eqn-9.5">(9.5)</a> does not
correspond to a &quot;pure&quot; finite difference method where the equation
is sampled at a point and derivatives replaced by differences (because
the \( u^{n-1} \) term on the right-hand side must then be \( u^n \)). The
best interpretation of the scheme
<a href="#mjx-eqn-9.5">(9.5)</a> is a Backward Euler
difference combined with a single (perhaps insufficient) Picard
iteration at each time level, with the value at the previous time
level as start for the Picard iteration.

<p>
</div>


<h2 id="nonlin:timediscrete:logistic:geometric:mean" class="anchor">Linearization by a geometric mean</h2>

<p>
We consider now a Crank-Nicolson discretization of
<a href="#mjx-eqn-9.1">(9.1)</a>. This means that the
time derivative is approximated by a centered
difference,

$$ [D_t u = u(1-u)]^{n+\half},$$

written out as

$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = u^{n+\half} -
(u^{n+\half})^2\tp
\tag{9.6}
\end{equation}
$$

The first term \( u^{n+\half} \) is normally approximated by an arithmetic
mean,

$$ u^{n+\half}\approx \half(u^n + u^{n+1}),$$

such that the scheme involves the unknown function only at the time levels
where we actually compute it.
The same arithmetic mean applied to the second term gives

$$ (u^{n+\half})^2\approx \frac{1}{4}(u^n + u^{n+1})^2,$$

which is nonlinear in the unknown \( u^{n+1} \).
However, using a <em>geometric mean</em> for \( (u^{n+\half})^2 \)
is a way of linearizing the nonlinear term in
<a href="#mjx-eqn-9.6">(9.6)</a>:

$$ (u^{n+\half})^2\approx u^nu^{n+1}\tp$$

Using an arithmetic mean on the linear \( u^{n+\frac{1}{2}} \) term in
<a href="#mjx-eqn-9.6">(9.6)</a> and a geometric
mean for the second term, results in a linearized equation for the
unknown \( u^{n+1} \):

$$ \frac{u^{n+1}-u^n}{\Delta t} =
\half(u^n + u^{n+1}) - u^nu^{n+1},$$

which can readily be solved:

$$
u^{n+1} = \frac{1 + \half\Delta t}{1+\Delta t u^n - \half\Delta t}
u^n\tp$$

This scheme can be coded directly, and since
there is no nonlinear algebraic equation to iterate over,
we skip the simplified notation with \( u \) for \( u^{n+1} \)
and \( u^{(1)} \) for \( u^n \). The technique with using
a geometric average is an example of transforming a nonlinear
algebraic equation to a linear one, without any need for iterations.

<p>
The geometric mean approximation is often very effective for
linearizing quadratic nonlinearities. Both the arithmetic and geometric mean
approximations have truncation errors of order \( \Delta t^2 \) and are
therefore compatible with the truncation error \( \Oof{\Delta t^2} \)
of the centered difference approximation for \( u^\prime \) in the Crank-Nicolson
method.

<p>
Applying the operator notation for the means and finite differences,
the linearized Crank-Nicolson scheme for the logistic equation can be
compactly expressed as

$$ [D_t u = \overline{u}^{t} + \overline{u^2}^{t,g}]^{n+\half}\tp$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark.</b>
If we use an arithmetic instead of a geometric mean
for the nonlinear term in
<a href="#mjx-eqn-9.6">(9.6)</a>,
we end up with a nonlinear term \( (u^{n+1})^2 \).
This term can be linearized as \( u^{-}u^{n+1} \) in a Picard iteration
approach and in particular as
\( u^nu^{n+1} \) in a Picard1 iteration approach.
The latter gives a scheme almost identical to the one arising from
a geometric mean (the difference in \( u^{n+1} \)
being \( \frac{1}{4}\Delta t u^n(u^{n+1}-u^n)\approx \frac{1}{4}\Delta t^2
u^\prime u \), i.e., a difference of size \( \Delta t^2 \)).
</div>


<h2 id="nonlin:timediscrete:logistic:Newton" class="anchor">Newton's method</h2>

<p>
The Backward Euler scheme <a href="#mjx-eqn-9.2">(9.2)</a>
for the logistic equation leads to a nonlinear algebraic equation
<a href="#mjx-eqn-9.3">(9.3)</a>. Now we write any nonlinear
algebraic equation in the general and compact form

$$ F(u) = 0\tp$$

Newton's method linearizes this equation by approximating \( F(u) \) by
its Taylor series expansion around a computed value \( u^{-} \)
and keeping only the linear part:

$$
\begin{align*}
F(u) &= F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) + {\half}F^{\prime\prime}(u^{-})(u-u^{-})^2
+\cdots\\ 
& \approx F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) = \hat F(u)\tp
\end{align*}
$$

The linear equation \( \hat F(u)=0 \) has the solution

$$ u = u^{-} - \frac{F(u^{-})}{F^{\prime}(u^{-})}\tp$$

Expressed with an iteration index in the unknown, Newton's method takes
on the more familiar mathematical form

$$ u^{k+1} = u^k - \frac{F(u^k)}{F^{\prime}(u^k)},\quad k=0,1,\ldots$$

<p>
When the method converges, it can be shown that the error in iteration \( k+1 \) of Newton's method is
proportional to
the square of the error in iteration \( k \), a result referred to as
<em>quadratic convergence</em>. This means that for
small errors the method converges very fast, and in particular much
faster than Picard iteration and other iteration methods.
(The proof of this result is found in most textbooks on numerical analysis.)
However, the quadratic convergence appears only if \( u^k \) is sufficiently
close to the solution. Further away from the solution the method can
easily converge very slowly or diverge. The reader is encouraged to do
<a href="._fem-book-sol033.html#nonlin:exer:Newton:problems1">Problem 45: Experience the behavior of Newton's method</a> to get a better understanding
for the behavior of the method.

<p>
Application of Newton's method to the logistic equation discretized
by the Backward Euler method is straightforward
as we have

$$ F(u) = au^2 + bu + c,\quad a=\Delta t,\ b = 1-\Delta t,\ c=-u^{(1)},$$

and then

$$ F^{\prime}(u) = 2au + b\tp$$

The iteration method becomes

$$
\begin{equation}
u = u^{-} + \frac{a(u^{-})^2 + bu^{-} + c}{2au^{-} + b},\quad
u^{-}\ \leftarrow u\tp
\tag{9.7}
\end{equation}
$$

At each time level, we start the iteration by setting \( u^{-}=u^{(1)} \).
Stopping criteria as listed for the Picard iteration can be used also
for Newton's method.

<p>
An alternative mathematical form, where we write out \( a \), \( b \), and \( c \),
and use a time level counter \( n \) and an iteration counter \( k \), takes
the form

$$
\begin{equation}
u^{n,k+1} = u^{n,k} +
\frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
{2\Delta t u^{n,k} + 1 - \Delta t},\quad u^{n,0}=u^{n-1},
\tag{9.8}
\end{equation}
$$

for \( k=0,1,\ldots \).
A program implementation is much closer to <a href="#mjx-eqn-9.7">(9.7)</a> than to <a href="#mjx-eqn-9.8">(9.8)</a>, but
the latter is better aligned with the established mathematical
notation used in the literature.

<h2 id="nonlin:timediscrete:logistic:relaxation" class="anchor">Relaxation</h2>

<p>
One iteration in Newton's method or
Picard iteration consists of solving a linear problem \( \hat F(u)=0 \).
Sometimes convergence problems arise because the new solution \( u \)
of \( \hat F(u)=0 \) is &quot;too far away&quot; from the previously computed
solution \( u^{-} \). A remedy is to introduce a relaxation, meaning that
we first solve \( \hat F(u^*)=0 \) for a suggested value \( u^* \) and
then we take \( u \) as a weighted mean of what we had, \( u^{-} \), and
what our linearized equation \( \hat F=0 \) suggests, \( u^* \):

$$ u = \omega u^* + (1-\omega) u^{-}\tp$$

The parameter \( \omega \)
is known as a <em>relaxation parameter</em>, and a choice \( \omega < 1 \)
may prevent divergent iterations.

<p>
Relaxation in Newton's method can be directly incorporated
in the basic iteration formula:

$$
\begin{equation}
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}\tp
\tag{9.9}
\end{equation}
$$

<h2 id="nonlin:timediscrete:logistic:impl" class="anchor">Implementation and experiments</h2>

<p>
The program <a href="http://tinyurl.com/znpudbt/logistic.py" target="_self"><tt>logistic.py</tt></a> contains
implementations of all the methods described above.
Below is an extract of the file showing how the Picard and Newton
methods are implemented for a Backward Euler discretization of
the logistic equation.

<p>
<!-- @@@CODE src/logistic.py fromto: def BE_logistic@def CN_logistic -->

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">BE_logistic</span>(u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
                eps_r<span style="color: #666666">=1E-3</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>):
    <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard1&#39;</span>:
        choice <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Picard&#39;</span>
        max_iter <span style="color: #666666">=</span> <span style="color: #666666">1</span>

    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    iterations <span style="color: #666666">=</span> []
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt<span style="color: #666666">+1</span>):
        a <span style="color: #666666">=</span> dt
        b <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> dt
        c <span style="color: #666666">=</span> <span style="color: #666666">-</span>u[n<span style="color: #666666">-1</span>]

        <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard&#39;</span>:

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> a<span style="color: #666666">*</span>u<span style="color: #666666">**2</span> <span style="color: #666666">+</span> b<span style="color: #666666">*</span>u <span style="color: #666666">+</span> c

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                u_ <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>(<span style="color: #666666">-</span>c<span style="color: #666666">/</span>(a<span style="color: #666666">*</span>u_ <span style="color: #666666">+</span> b)) <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)

        <span style="color: #008000; font-weight: bold">elif</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Newton&#39;</span>:

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> a<span style="color: #666666">*</span>u<span style="color: #666666">**2</span> <span style="color: #666666">+</span> b<span style="color: #666666">*</span>u <span style="color: #666666">+</span> c

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dF</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>a<span style="color: #666666">*</span>u <span style="color: #666666">+</span> b

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                u_ <span style="color: #666666">=</span> u_ <span style="color: #666666">-</span> F(u_)<span style="color: #666666">/</span>dF(u_)
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)
    <span style="color: #008000; font-weight: bold">return</span> u, iterations
</pre></div>
<p>
The Crank-Nicolson method utilizing a linearization based on the
geometric mean gives a simpler algorithm:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">CN_logistic</span>(u0, dt, Nt):
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>u[n] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt)<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
We may run experiments with the model problem
<a href="#mjx-eqn-9.1">(9.1)</a> and the different strategies for
dealing with nonlinearities as described above. For a quite coarse
time resolution, \( \Delta t=0.9 \), use of a tolerance \( \epsilon_r=0.05 \)
in the stopping criterion introduces an iteration error, especially in
the Picard iterations, that is visibly much larger than the
time discretization error due to a large \( \Delta t \). This is illustrated
by comparing the upper two plots in
Figure <a href="#nonlin:timediscrete:logistic:impl:fig:u">89</a>. The one to
the right has a stricter tolerance \( \epsilon = 10^{-3} \), which leads
to all the curves involving backward Euler, using iterative solution by
either Picard or Newton iterations, to be
on top of each other (and no changes can be visually observed by
reducing \( \epsilon_r \) further). The reason why Newton's method does
much better than Picard iteration in the upper left plot is that
Newton's method with one step comes far below the \( \epsilon_r \) tolerance,
while the Picard iteration needs on average 7 iterations to bring the
residual down to \( \epsilon_r=10^{-1} \), which gives insufficient
accuracy in the solution of the nonlinear equation. It is obvious
that the Picard1 method gives significant errors in addition to
the time discretization unless the time step is as small as in
the lower right plot.

<p>
The <em>BE exact</em> curve corresponds to using the exact solution of the
quadratic equation at each time level, so this curve is only affected
by the Backward Euler time discretization.  The <em>CN gm</em> curve
corresponds to the theoretically more accurate Crank-Nicolson
discretization, combined with a geometric mean for linearization.
Visually, this curve appears more accurate in all the plots, especially if we take the plot in
the lower right with a small \( \Delta t \) and an appropriately small
\( \epsilon_r \) value as the reference curve.

<p>
When it comes to the need for iterations, Figure
<a href="#nonlin:timediscrete:logistic:impl:fig:iter">90</a> displays the number of
iterations required at each time level for Newton's method and
Picard iteration. The smaller \( \Delta t \) is, the better starting value
we have for the iteration, and the faster the convergence is.
With \( \Delta t = 0.9 \) Picard iteration requires on average 32 iterations
per time step for the stricter convergence criterion, but this number is dramatically reduced as \( \Delta t \)
is reduced.

<p>
However, introducing relaxation and a parameter \( \omega=0.8 \)
immediately reduces the average of 32 to 7, indicating that for the large
\( \Delta t=0.9 \), Picard iteration takes too long steps. An approximately optimal
value for \( \omega \) in this case is 0.5, which results in an average of only
2 iterations! An even more dramatic impact of \( \omega \) appears when
\( \Delta t = 1 \): Picard iteration does not convergence in 1000 iterations,
but \( \omega=0.5 \) again brings the average number of iterations down to 2.

<p>
<center> <!-- figure label: --> <div id="nonlin:timediscrete:logistic:impl:fig:u"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 89:  Impact of solution strategy and time step length on the solution.  <!-- caption label: nonlin:timediscrete:logistic:impl:fig:u --> </p></center>
<p><img src="fig/logistic_u.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="nonlin:timediscrete:logistic:impl:fig:iter"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 90:  Comparison of the number of iterations at various time levels for Picard and Newton iteration.  <!-- caption label: nonlin:timediscrete:logistic:impl:fig:iter --> </p></center>
<p><img src="fig/logistic_iter.png" align="bottom" width=800></p>
</center>

<h2 id="nonlin:ode:generic" class="anchor">Generalization to a general nonlinear ODE</h2>

<p>
Let us see how the various methods in the previous sections
can be applied to the more generic model

$$
\begin{equation}
u^{\prime} = f(u, t),
\tag{9.10}
\end{equation}
$$

where \( f \) is a nonlinear function of \( u \).

<h3 id="___sec329" class="anchor">Explicit time discretization </h3>

<p>
Explicit ODE methods like the Forward Euler scheme, various Runge-Kutta methods,
Adams-Bashforth methods all evaluate \( f \) at time levels where
\( u \) is already computed, so nonlinearities in \( f \) do not
pose any difficulties.

<h3 id="___sec330" class="anchor">Backward Euler discretization </h3>

<p>
Approximating \( u^{\prime} \) by a backward difference leads to a Backward Euler
scheme, which can be written as

$$ F(u^n) = u^{n} - \Delta t\, f(u^n, t_n) - u^{n-1}=0,$$

or alternatively

$$ F(u) = u - \Delta t\, f(u, t_n) - u^{(1)} = 0\tp$$

A simple Picard iteration, not knowing anything about the nonlinear
structure of \( f \), must approximate \( f(u,t_n) \) by \( f(u^{-},t_n) \):

$$ \hat F(u) = u - \Delta t\, f(u^{-},t_n) - u^{(1)}\tp$$

The iteration starts with \( u^{-}=u^{(1)} \) and proceeds with repeating

$$ u^* = \Delta t\, f(u^{-},t_n) + u^{(1)},\quad u = \omega u^* + (1-\omega)u^{-},
\quad u^{-}\ \leftarrow\ u,$$

until a stopping criterion is fulfilled.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Explicit vs implicit treatment of nonlinear terms.</b>
Evaluating \( f \) for a known \( u^{-} \) is referred to as <em>explicit</em> treatment of
\( f \), while if \( f(u,t) \) has some structure, say \( f(u,t) = u^3 \), parts of
\( f \) can involve the unknown \( u \), as in the manual linearization
like \( (u^{-})^2u \), and then the treatment of \( f \) is &quot;more implicit&quot;
and &quot;less explicit&quot;. This terminology is inspired by time discretization
of \( u^{\prime}=f(u,t) \), where evaluating \( f \) for known \( u \) values gives
explicit formulas for the unknown and hence explicit schemes, while treating \( f \) 
or parts of \( f \) implicitly, meaning that equations must be solved in terms of the 
unknown, makes \( f \) contribute to the unknown terms in the equation at the new
time level.

<p>
Explicit treatment of \( f \) usually means stricter conditions on
\( \Delta t \) to achieve stability of time discretization schemes. The same
applies to iteration techniques for nonlinear algebraic equations: the &quot;less&quot;
we linearize \( f \) (i.e., the more we keep of \( u \) in the original formula),
the faster the convergence may be.

<p>
We may say that \( f(u,t)=u^3 \) is treated explicitly if we evaluate \( f \)
as \( (u^{-})^3 \), semi or partially implicit if we linearize as \( (u^{-})^2u \)
and fully implicit if we represent \( f \) by \( u^3 \). (Of course, the
fully implicit representation will require further linearization,
but with \( f(u,t)=u^2 \) a fully implicit treatment is possible if
the resulting quadratic equation is solved with a formula.)

<p>
For the ODE \( u^{\prime}=-u^3 \) with \( f(u,t)=-u^3 \) and coarse
time resolution \( \Delta t = 0.4 \), Picard iteration with \( (u^{-})^2u \)
requires 8 iterations with \( \epsilon_r = 10^{-3} \) for the first
time step, while \( (u^{-})^3 \) leads to 22 iterations. After about 10
time steps both approaches are down to about 2 iterations per time
step, but this example shows a potential of treating \( f \) more
implicitly.

<p>
A trick to treat \( f \) implicitly in Picard iteration is to
evaluate it as \( f(u^{-},t)u/u^{-} \). For a polynomial \( f \), \( f(u,t)=u^m \),
this corresponds to \( (u^{-})^{m}u/u^{-}=(u^{-})^{m-1}u \). Sometimes this more implicit
treatment has no effect, as with \( f(u,t)=\exp(-u) \) and \( f(u,t)=\ln (1+u) \),
but with \( f(u,t)=\sin(2(u+1)) \), the \( f(u^{-},t)u/u^{-} \) trick
leads to 7, 9, and 11 iterations during the first three steps, while
\( f(u^{-},t) \) demands 17, 21, and 20 iterations.
(Experiments can be done with the code <a href="http://tinyurl.com/znpudbt/ODE_Picard_tricks.py" target="_self"><tt>ODE_Picard_tricks.py</tt></a>.)
</div>


<p>
Newton's method applied to a Backward Euler discretization of
\( u^{\prime}=f(u,t) \)
requires the computation of the derivative

$$ F^{\prime}(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n)\tp$$

Starting with the solution at the previous time level, \( u^{-}=u^{(1)} \),
we can just use the standard formula

$$
\begin{equation}
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
= u^{-} - \omega \frac{u^{-} - \Delta t\, f(u^{-}, t_n) - u^{(1)}}{1 - \Delta t
\frac{\partial}{\partial u}f(u^{-},t_n)}
\tp
\tag{9.11}
\end{equation}
$$

<p>
<!-- The geometric mean trick cannot be used unless we know that \( f \) has -->
<!-- a special structure with quadratic expressions in \( u \). -->

<h3 id="___sec331" class="anchor">Crank-Nicolson discretization </h3>

<p>
The standard Crank-Nicolson scheme with arithmetic mean approximation of
\( f \) takes the form

$$ \frac{u^{n+1} - u^n}{\Delta t} = \half(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n))\tp$$

We can write the scheme as a nonlinear algebraic equation

$$
\begin{equation}
F(u) = u - u^{(1)} - \Delta t{\half}f(u,t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n}) = 0\tp
\tag{9.12}
\end{equation}
$$

A Picard iteration scheme must in general employ the linearization

$$ \hat F(u) = u - u^{(1)} - \Delta t{\half}f(u^{-},t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n}),$$

while Newton's method can apply the general formula
<a href="#mjx-eqn-9.11">(9.11)</a> with \( F(u) \) given in
<a href="#mjx-eqn-9.12">(9.12)</a> and

$$ F^{\prime}(u)= 1 - \half\Delta t\frac{\partial f}{\partial u}(u,t_{n+1})\tp$$

<p>
<!-- What about pendulum sin(u) as u/u_ sin(u_)? Check in odespy if it -->
<!-- converges faster (should be able to store the no of Newton and -->
<!-- Picard iterations in the classes and poll afterwards). It the trick -->
<!-- pays off, describe it here. Can odespy be used here? That is, can we -->
<!-- provide the linearization? No...? -->

<h2 id="nonlin:ode:generic:sys:pendulum" class="anchor">Systems of ODEs</h2>

<p>
We may write a system of ODEs

$$
\begin{align*}
\frac{d}{dt}u_0(t) &= f_0(u_0(t),u_1(t),\ldots,u_N(t),t),\\ 
\frac{d}{dt}u_1(t) &= f_1(u_0(t),u_1(t),\ldots,u_N(t),t),\\ 
&\vdots\\ 
\frac{d}{dt}u_m(t) &= f_m(u_0(t),u_1(t),\ldots,u_N(t),t),
\end{align*}
$$

as

$$
\begin{equation}
u^{\prime} = f(u,t),\quad u(0)=U_0,
\tag{9.13}
\end{equation}
$$

if we interpret \( u \) as a vector \( u=(u_0(t),u_1(t),\ldots,u_N(t)) \)
and \( f \) as a vector function with components
\( (f_0(u,t),f_1(u,t),\ldots,f_N(u,t)) \).

<p>
Most solution methods for scalar ODEs, including
the Forward and Backward Euler schemes and the
Crank-Nicolson method, generalize in a
straightforward way to systems of ODEs simply by using vector
arithmetics instead of scalar arithmetics, which corresponds to
applying the scalar scheme to each component of the system.  For
example, here is a backward difference scheme applied to each
component,

$$
\begin{align*}
\frac{u_0^n- u_0^{n-1}}{\Delta t} &= f_0(u^n,t_n),\\ 
\frac{u_1^n- u_1^{n-1}}{\Delta t} &= f_1(u^n,t_n),\\ 
&\vdots\\ 
\frac{u_N^n- u_N^{n-1}}{\Delta t} &= f_N(u^n,t_n),
\end{align*}
$$

which can be written more compactly in vector form as

$$ \frac{u^n- u^{n-1}}{\Delta t} = f(u^n,t_n)\tp$$

This is a <em>system of algebraic equations</em>,

$$ u^n - \Delta t\,f(u^n,t_n) - u^{n-1}=0,$$

or written out

$$
\begin{align*}
u_0^n - \Delta t\, f_0(u^n,t_n) - u_0^{n-1} &= 0,\\ 
&\vdots\\ 
u_N^n - \Delta t\, f_N(u^n,t_n) - u_N^{n-1} &= 0\tp
\end{align*}
$$

<h3 id="___sec333" class="anchor">Example </h3>

<p>
We shall address the \( 2\times 2 \) ODE system for
oscillations of a pendulum
subject to gravity and air drag. The system can be written as

$$
\begin{align}
\dot\omega &= -\sin\theta -\beta \omega |\omega|,
\tag{9.14}\\ 
\dot\theta &= \omega,
\tag{9.15}
\end{align}
$$

where \( \beta \) is a dimensionless parameter (this is the scaled, dimensionless
version of the original, physical model). The unknown components of the
system are the
angle \( \theta(t) \) and the angular velocity \( \omega(t) \).
We introduce \( u_0=\omega \) and \( u_1=\theta \), which leads to

$$
\begin{align*}
u_0^{\prime} = f_0(u,t) &= -\sin u_1 - \beta u_0|u_0|,\\ 
u_1^{\prime} = f_1(u,t) &= u_0\tp
\end{align*}
$$

A Crank-Nicolson scheme reads

$$
\begin{align}
\frac{u_0^{n+1}-u_0^{n}}{\Delta t} &= -\sin u_1^{n+\frac{1}{2}}
- \beta u_0^{n+\frac{1}{2}}|u_0^{n+\frac{1}{2}}|\nonumber\\ 
& \approx -\sin\left(\frac{1}{2}(u_1^{n+1} + u_1^n)\right)
- \beta\frac{1}{4} (u_0^{n+1} + u_0^n)|u_0^{n+1}+u_0^n|,
\tag{9.16}\\ 
\frac{u_1^{n+1}-u_1^n}{\Delta t} &= u_0^{n+\frac{1}{2}}\approx
\frac{1}{2} (u_0^{n+1}+u_0^n)\tp
\tag{9.17}
\end{align}
$$

This is a <em>coupled system</em> of two nonlinear algebraic equations
in two unknowns \( u_0^{n+1} \) and \( u_1^{n+1} \).

<p>
Using the notation \( u_0 \) and \( u_1 \) for the unknowns \( u_0^{n+1} \) and
\( u_1^{n+1} \) in this system, writing \( u_0^{(1)} \) and
\( u_1^{(1)} \) for the previous values \( u_0^n \) and \( u_1^n \), multiplying
by \( \Delta t \) and moving the terms to the left-hand sides, gives

$$
\begin{align}
u_0 - u_0^{(1)} + \Delta t\,\sin\left(\frac{1}{2}(u_1 + u_1^{(1)})\right)
+ \frac{1}{4}\Delta t\beta (u_0 + u_0^{(1)})|u_0 + u_0^{(1)}| &=0,
\tag{9.18}\\ 
u_1 - u_1^{(1)} -\frac{1}{2}\Delta t(u_0 + u_0^{(1)}) &=0\tp
\tag{9.19}
\end{align}
$$

Obviously, we have a need for solving systems of nonlinear algebraic
equations, which is the topic of the next section.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">

  <li class="previous">
    <a href="._fem-book-sol027.html">&larr; Prev</a>
  </li>

  <li class="next">
    <a href="._fem-book-sol029.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

