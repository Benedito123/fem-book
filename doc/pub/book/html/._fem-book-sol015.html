<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:64px;      /* fixed header height for style bootswatch_readable */
  margin:-64px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              ('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Contents', 3, None, '___sec1'),
              ('Supplementary materials', 3, None, '___sec2'),
              ('Quick overview of the finite element method',
               0,
               'ch:overview',
               'ch:overview'),
              ('Function approximation by global functions',
               0,
               'ch:approx:global',
               'ch:approx:global'),
              ('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec7'),
              ('The projection method', 3, None, '___sec8'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec10'),
              ('The Galerkin or projection method', 3, None, '___sec11'),
              ('Approximation principles',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method', 2, 'fem:approx:LS', 'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec14'),
              ('Example on linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec17'),
              ('Fall back on numerical integration', 3, None, '___sec18'),
              ('Plotting the approximation', 3, None, '___sec19'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact1',
               'fem:approx:global:exact1'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec22'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              ('Implementation', 3, None, '___sec24'),
              ('Example', 3, None, '___sec25'),
              ('Orthogonal basis functions', 1, None, '___sec26'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec30'),
              ('Interpolation', 1, None, '___sec31'),
              ('The interpolation (or collocation) principle',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec33'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec35'),
              ('Successful example', 3, None, '___sec36'),
              ('Less successful example', 3, None, '___sec37'),
              ('Remedy for strong oscillations', 3, None, '___sec38'),
              ('Bernstein polynomials',
               2,
               'fem:approx:global:Bernstein',
               'fem:approx:global:Bernstein'),
              ('Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              ('Approximation of functions in higher dimensions',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example on polynomial basis in 2D', 2, None, '___sec43'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Exercises', 1, None, '___sec46'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power '
               'functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec53'),
              ('Problem 7: Approximate a steep function by sines with boundary '
               'adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec55'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange '
               'polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange '
               'polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Function approximation by finite elements',
               0,
               'ch:approx:fe',
               'ch:approx:fe'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec62'),
              ('The basis functions', 2, None, '___sec63'),
              ('Construction principles', 3, None, '___sec64'),
              ('Properties of $\\basphi_i$', 3, None, '___sec65'),
              ('Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              ('Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              ('Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec70'),
              ('Calculating a general row in the matrix', 3, None, '___sec71'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec73'),
              ('Assembly of element matrices', 3, None, '___sec74'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              ('The element vector', 3, None, '___sec76'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec78'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              ('Formulas for local basis functions', 3, None, '___sec80'),
              ('Example on integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation', 1, 'fem:approx:fe:impl', 'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite elements and finite differences',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Interpretation of a finite element approximation in terms of '
               'finite difference operators',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fdm',
               'fem:deq:1D:approx:fem_vs_fdm'),
              ('Computations in physical space', 3, None, '___sec95'),
              ('Elementwise computations', 3, None, '___sec96'),
              ('Terminology', 3, None, '___sec97'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example on cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec104'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              ('Finite elements in 2D and 3D', 1, None, '___sec107'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              ('Element matrices and vectors', 3, None, '___sec109'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              ('Affine mapping of the reference cell', 2, None, '___sec111'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              ('Computing integrals', 2, None, '___sec113'),
              ('Implementation', 1, 'fe:approx:fenics', 'fe:approx:fenics'),
              ('Example on approximation in 2D using FEniCS',
               2,
               'fem:approx:fenics:2D',
               'fem:approx:fenics:2D'),
              ('Mathematical problem', 3, None, '___sec116'),
              ('The code', 3, None, '___sec117'),
              ('Dissection of the code', 3, None, '___sec118'),
              ('Integrating SymPy and FEniCS', 3, None, '___sec119'),
              ('Refined code with curve plotting',
               2,
               'fem:approx:fenics:2D:2',
               'fem:approx:fenics:2D:2'),
              ('Interpolation and projection', 3, None, '___sec121'),
              ('Plotting the solution along a line', 3, None, '___sec122'),
              ('Integrating plotting and computations', 3, None, '___sec123'),
              ('Exercises', 1, None, '___sec124'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite '
               'elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis '
               'functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Exercise 24: Make a 3D code for Lagrange elements of arbitrary '
               'order',
               2,
               None,
               '___sec138'),
              ('Variational formulations with global basis functions',
               0,
               'ch:varform:global',
               'ch:varform:global'),
              ('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('Differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Simple model problems and their solutions',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              ('Forming the residual',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec144'),
              ('The Galerkin method', 2, None, '___sec145'),
              ('The method of weighted residuals', 2, None, '___sec146'),
              ('The method of weighted residual and the truncation error',
               2,
               'varform:trunc',
               'varform:trunc'),
              ('Test and trial functions', 2, None, '___sec148'),
              ('The collocation method', 2, None, '___sec149'),
              ('The subdomain collocation method', 3, None, '___sec150'),
              ('Examples on using the principles',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The model problem', 3, None, '___sec152'),
              ('Basis functions', 3, None, '___sec153'),
              ('The residual', 3, None, '___sec154'),
              ('The least squares method', 3, None, '___sec155'),
              ('The Galerkin method', 3, None, '___sec156'),
              ('The collocation method', 3, None, '___sec157'),
              ('Comparison', 3, None, '___sec158'),
              ('Integration by parts',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('Weak form', 3, None, '___sec160'),
              ('Boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Computing with global polynomials', 1, None, '___sec162'),
              ('Computing with Dirichlet and Neumann conditions',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              ('When the numerical method is exact', 2, None, '___sec164'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Variational problems and minimization of functionals',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              ('Example', 3, None, '___sec167'),
              ('The general minimization problem', 3, None, '___sec168'),
              ('Derivation', 3, None, '___sec169'),
              ('Minimization of the discretized functional',
               3,
               None,
               '___sec170'),
              ('Calculus of variations', 3, None, '___sec171'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient', 2, None, '___sec173'),
              ('First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec174'),
              ('Nonlinear coefficient', 2, None, '___sec175'),
              ('Implementation of the algorithms',
               1,
               'fem:global:deq:1D:code',
               'fem:global:deq:1D:code'),
              ('Extensions of the code for approximation',
               2,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              ('Fallback to numerical methods', 2, None, '___sec178'),
              ('Example with constant right-hand side', 2, None, '___sec179'),
              ('Approximations may fail: convection-diffusion',
               1,
               'ch:convdiff',
               'ch:convdiff'),
              ('Exercises', 1, None, '___sec181'),
              ('Exercise 25: Refactor functions into a more general class',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              ('Exercise 26: Compute the deflection of a cable with sine '
               'functions',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              ('Exercise 27: Compute the deflection of a cable with power '
               'functions',
               2,
               'fem:deq:exer:tension:cable_xn',
               'fem:deq:exer:tension:cable_xn'),
              ('Exercise 28: Check integration by parts',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Variational formulations with finite elements',
               0,
               'ch:varform:fe',
               'ch:varform:fe'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Finite element mesh and basis functions', 2, None, '___sec188'),
              ('Computation in the global physical domain',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              ('Comparison with a finite difference discretization',
               2,
               'fem:deq:1D:fdm_vs_fem',
               'fem:deq:1D:fdm_vs_fem'),
              ('Cellwise computations',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('The integral for the element matrix', 3, None, '___sec192'),
              ('The integral for the element vector', 3, None, '___sec193'),
              ('Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec194'),
              ('Contributions from the first and last cell',
               3,
               None,
               '___sec195'),
              ('Assembly', 3, None, '___sec196'),
              ('Boundary conditions: specified nonzero value',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              ('Example on computing with a finite element-based boundary '
               'function',
               2,
               None,
               '___sec199'),
              ('Computations in physical coordinates', 3, None, '___sec200'),
              ('Cellwise computations on the reference element',
               3,
               None,
               '___sec201'),
              ('Modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Computations in the physical system', 3, None, '___sec203'),
              ('Symmetric modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              ('Modification of the element matrix and vector',
               2,
               'fem:bc:elmat:mod',
               'fem:bc:elmat:mod'),
              ('Boundary conditions: specified derivative',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec207'),
              ('Boundary term vanishes because of the test functions',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              ('Boundary term vanishes because of linear system modifications',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              ('Direct computation of the global linear system',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              ('Cellwise computations', 2, None, '___sec211'),
              ('Implementation of finite element algorithms',
               1,
               'fem:deq:1D:code',
               'fem:deq:1D:code'),
              ('Extensions of the code for approximation',
               2,
               'fem:deq:1D:code:fe',
               'fem:deq:1D:code:fe'),
              ('Utilizing a sparse matrix',
               2,
               'fem:deq:1D:code:fe_sparse',
               'fem:deq:1D:code:fe_sparse'),
              ('Application to our model problem', 2, None, '___sec215'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Integration by parts', 2, None, '___sec217'),
              ('Example on a multi-dimensional variational problem',
               2,
               'sec:varform:general:convdiff',
               'sec:varform:general:convdiff'),
              ('Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec219'),
              ('Numerical integration', 2, None, '___sec220'),
              ('Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec221'),
              ('A glimpse of the mathematical theory of the finite element '
               'method',
               2,
               None,
               '___sec222'),
              ('Abstract variational forms', 3, None, '___sec223'),
              ('Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec224'),
              ('Assumptions', 3, None, '___sec225'),
              ('Existence and uniqueness', 3, None, '___sec226'),
              ('Stability', 3, None, '___sec227'),
              ('Equivalent minimization problem', 3, None, '___sec228'),
              ('Best approximation principle', 3, None, '___sec229'),
              ('Best approximation property in the norm of the space',
               3,
               None,
               '___sec230'),
              ('Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec231'),
              ('Equivalent matrix minimization problem', 3, None, '___sec232'),
              ('A priori error estimate for the derivative',
               3,
               None,
               '___sec233'),
              ('A priori error estimate for the solution',
               3,
               None,
               '___sec234'),
              ('Implementation in 2D and 3D via FEniCS',
               1,
               'fem:varform:fenics',
               'fem:varform:fenics'),
              ('Mathematical problem',
               2,
               'fem:varform:fenics:problem',
               'fem:varform:fenics:problem'),
              ('Symmetry', 3, None, '___sec237'),
              ('Variational formulation',
               2,
               'fem:varform:fenics:varform',
               'fem:varform:fenics:varform'),
              ('The FEniCS solver', 2, None, '___sec239'),
              ('Making the mesh', 2, None, '___sec240'),
              ('Solving a problem', 2, None, '___sec241'),
              ('Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec242'),
              ('Summary', 1, None, '___sec243'),
              ('Exercises', 1, None, '___sec244'),
              ('Exercise 29: Compute the deflection of a cable with 2 P1 '
               'elements',
               2,
               'fem:deq:exer:cable:2P1',
               'fem:deq:exer:cable:2P1'),
              ('Exercise 30: Compute the deflection of a cable with 1 P2 '
               'element',
               2,
               'fem:deq:exer:cable:1P2',
               'fem:deq:exer:cable:1P2'),
              ('Exercise 31: Compute the deflection of a cable with a step '
               'load',
               2,
               'fem:deq:exer:cable:stepload',
               'fem:deq:exer:cable:stepload'),
              ('Exercise 32: Compute with a non-uniform mesh',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              ('Problem 33: Solve a 1D finite element problem by hand',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              ('Exercise 34: Investigate exact finite element solutions',
               2,
               'fem:deq:exer:1D:exact_numerics',
               'fem:deq:exer:1D:exact_numerics'),
              ('Exercise 35: Compare finite elements and differences for a '
               'radially symmetric Poisson equation',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              ('Exercise 36: Compute with variable coefficients and P1 '
               'elements by hand',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              ('Exercise 37: Solve a 2D Poisson equation using polynomials and '
               'sines',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              ('Exercise 38: Solve a 3D Laplace problem with FEniCS',
               2,
               'fem:fenics:borehole:exer:3D',
               'fem:fenics:borehole:exer:3D'),
              ('Exercise 39: Solve a 1D Laplace problem with FEniCS',
               2,
               'fem:fenics:borehole:exer:1D',
               'fem:fenics:borehole:exer:1D'),
              ('Time-dependent variational forms',
               0,
               'ch:femtime',
               'ch:femtime'),
              ('Discretization in time by a Forward Euler scheme',
               1,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              ('Time discretization', 2, None, '___sec258'),
              ('Space discretization', 2, None, '___sec259'),
              ('Variational forms', 2, None, '___sec260'),
              ('Notation for the solution at recent time levels',
               2,
               None,
               '___sec261'),
              ('Deriving the linear systems', 2, None, '___sec262'),
              ('Computational algorithm', 2, None, '___sec263'),
              ('Example using cosinusoidal basis functions',
               2,
               'fem:deq:diffu:FE:cosex',
               'fem:deq:diffu:FE:cosex'),
              ('Comparing P1 elements with the finite difference method',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              ('Lumping the mass matrix', 3, None, '___sec266'),
              ('Discretization in time by a Backward Euler scheme',
               1,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              ('Time discretization', 2, None, '___sec268'),
              ('Variational forms', 2, None, '___sec269'),
              ('Linear systems', 2, None, '___sec270'),
              ('Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec271'),
              ('Dirichlet boundary conditions',
               1,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              ('Boundary function', 2, None, '___sec273'),
              ('Finite element basis functions', 2, None, '___sec274'),
              ('Modification of the linear system', 2, None, '___sec275'),
              ('Example: Oscillating Dirichlet boundary condition',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              ('Accuracy of the finite element solution',
               1,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              ('Methods of analysis', 2, None, '___sec278'),
              ('Fourier components and dispersion relations',
               2,
               None,
               '___sec279'),
              ('Forward Euler discretization', 2, None, '___sec280'),
              ('Backward Euler discretization', 2, None, '___sec281'),
              ('Comparing amplification factors', 2, None, '___sec282'),
              ('Exercises', 1, None, '___sec283'),
              ('Exercise 40: Analyze a Crank-Nicolson scheme for the diffusion '
               'equation',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              ('Variational forms for systems of PDEs',
               0,
               'ch:femsys',
               'ch:femsys'),
              ('Variational forms', 1, 'fem:sys:vform', 'fem:sys:vform'),
              ('Sequence of scalar PDEs formulation', 2, None, '___sec287'),
              ('Vector PDE formulation', 2, None, '___sec288'),
              ('A worked example', 1, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              ('Identical function spaces for the unknowns',
               1,
               None,
               '___sec290'),
              ('Variational form of each individual PDE', 2, None, '___sec291'),
              ('Compound scalar variational form', 2, None, '___sec292'),
              ('Decoupled linear systems', 2, None, '___sec293'),
              ('Coupled linear systems', 2, None, '___sec294'),
              ('Different function spaces for the unknowns',
               1,
               None,
               '___sec295'),
              ('Computations in 1D',
               1,
               'femsys:cooling:1D',
               'femsys:cooling:1D'),
              ('Another example in 1D', 2, 'fem:sys:up:1D', 'fem:sys:up:1D'),
              ('Exercises', 1, None, '___sec298'),
              ('Problem 41: Estimate order of convergence for the Cooling law',
               2,
               'femsys:exer:cooling:1',
               'femsys:exer:cooling:1'),
              ('Problem 42: Estimate order of convergence for the Cooling law',
               2,
               'femsys:exer:cooling:2',
               'femsys:exer:cooling:2'),
              ('Flexible implementations of boundary conditions',
               0,
               'ch:nitsche',
               'ch:nitsche'),
              ('Optimization with constraint',
               1,
               'nitsche:fxy:opt',
               'nitsche:fxy:opt'),
              ('Elimination of variables', 2, None, '___sec303'),
              ('Lagrange multiplier method',
               2,
               'nitsche:fxy:opt:Lagrange',
               'nitsche:fxy:opt:Lagrange'),
              ('Penalty method',
               2,
               'nitsche:fxy:opt:penalty',
               'nitsche:fxy:opt:penalty'),
              ('Optimization of functionals',
               1,
               'nitsche:pde:opt',
               'nitsche:pde:opt'),
              ('Classical calculus of variations',
               2,
               'nitsche:pde:opt:varcalculus',
               'nitsche:pde:opt:varcalculus'),
              ("Penalty and Nitsche's methods for optimization with "
               'constraints',
               2,
               'nitsche:pde:opt:penalty',
               'nitsche:pde:opt:penalty'),
              ('Lagrange multiplier method for optimization with constraints',
               2,
               'nitsche:pde:opt:Lagrange',
               'nitsche:pde:opt:Lagrange'),
              ('Example: 1D problem',
               2,
               'nitsche:pde:opt:1Dex',
               'nitsche:pde:opt:1Dex'),
              ('Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec311'),
              ('Nonlinear problems', 0, 'ch:nonlin', 'ch:nonlin'),
              ('Introduction of basic concepts',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              ('Linear versus nonlinear equations', 2, None, '___sec314'),
              ('Algebraic equations', 3, None, '___sec315'),
              ('Differential equations', 3, None, '___sec316'),
              ('A simple model problem', 2, None, '___sec317'),
              ('Linearization by explicit time discretization',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              ('Exact solution of nonlinear algebraic equations',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              ('Linearization', 2, None, '___sec320'),
              ('Picard iteration',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              ('Stopping criteria', 3, None, '___sec322'),
              ('A single Picard iteration', 3, None, '___sec323'),
              ('Linearization by a geometric mean',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              ("Newton's method",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              ('Relaxation',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              ('Implementation and experiments',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              ('Generalization to a general nonlinear ODE',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              ('Explicit time discretization', 3, None, '___sec329'),
              ('Backward Euler discretization', 3, None, '___sec330'),
              ('Crank-Nicolson discretization', 3, None, '___sec331'),
              ('Systems of ODEs',
               2,
               'nonlin:ode:generic:sys:pendulum',
               'nonlin:ode:generic:sys:pendulum'),
              ('Example', 3, None, '___sec333'),
              ('Systems of nonlinear algebraic equations',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              ('Picard iteration',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              ("Newton's method",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              ('Stopping criteria',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              ('Example: A nonlinear ODE model from epidemiology',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              ('Implicit time discretization', 3, None, '___sec339'),
              ('A Picard iteration', 3, None, '___sec340'),
              ("Newton's method", 3, None, '___sec341'),
              ('Linearization at the differential equation level',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              ('Explicit time integration',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              ('Backward Euler scheme and Picard iteration',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              ("Backward Euler scheme and Newton's method",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              ('Linearization via Taylor expansions', 3, None, '___sec346'),
              ('Similarity with Picard iteration', 3, None, '___sec347'),
              ('Implementation', 3, None, '___sec348'),
              ('Derivation with alternative notation', 3, None, '___sec349'),
              ('Crank-Nicolson discretization',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              ('1D stationary nonlinear differential equations',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              ('Solution of algebraic equations', 2, None, '___sec353'),
              ('The structure of the equation system', 3, None, '___sec354'),
              ('Picard iteration', 3, None, '___sec355'),
              ('Mesh with two cells', 3, None, '___sec356'),
              ("Newton's method", 3, None, '___sec357'),
              ('Multi-dimensional PDE problems', 1, None, '___sec358'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:dD:fd',
               'nonlin:alglevel:dD:fd'),
              ('Picard iteration', 3, None, '___sec360'),
              ("Newton's method", 3, None, '___sec361'),
              ('Continuation methods', 2, None, '___sec362'),
              ('Exercises', 1, 'nonlin:exer', 'nonlin:exer'),
              ('Problem 43: Determine if equations are nonlinear or not',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              ('Exercise 44: Derive and investigate a generalized logistic '
               'model',
               2,
               'nonlin:exer:logistic:gen',
               'nonlin:exer:logistic:gen'),
              ("Problem 45: Experience the behavior of Newton's method",
               2,
               'nonlin:exer:Newton:problems1',
               'nonlin:exer:Newton:problems1'),
              ('Problem 46: Compute the Jacobian of a $2\\times 2$ system',
               2,
               'nonlin:exer:vib:Jacobian',
               'nonlin:exer:vib:Jacobian'),
              ('Problem 47: Solve nonlinear equations arising from a vibration '
               'ODE',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              ('Exercise 48: Find the truncation error of arithmetic mean of '
               'products',
               2,
               'nonlin:exer:products:arith:mean',
               'nonlin:exer:products:arith:mean'),
              ("Problem 49: Newton's method for linear problems",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              ('Exercise 50: Discretize a 1D problem with a nonlinear '
               'coefficient',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              ('Exercise 51: Linearize a 1D problem with a nonlinear '
               'coefficient',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              ('Problem 52: Finite differences for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              ('Exercise 53: Discretize a nonlinear 1D heat conduction PDE by '
               'finite differences',
               2,
               'nonlin:exer:1D:heat:nonlinear:fdm',
               'nonlin:exer:1D:heat:nonlinear:fdm'),
              ('Exercise 54: Differentiate a highly nonlinear term',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              ('Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion '
               'equation',
               2,
               'nonlin:exer:2D:heat:nonlinear:fd',
               'nonlin:exer:2D:heat:nonlinear:fd'),
              ('Exercise 56: Find the sparsity of the Jacobian',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              ('Problem 57: Investigate a 1D problem with a continuation '
               'method',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              ('Symbolic nonlinear finite element equations',
               1,
               'nonlin:app:fem_vs_fdm',
               'nonlin:app:fem_vs_fdm'),
              ('Finite element basis functions',
               2,
               'nonlin:alglevel:1D:fe_basis',
               'nonlin:alglevel:1D:fe_basis'),
              ('The group finite element method',
               2,
               'nonlin:alglevel:1D:fe:group',
               'nonlin:alglevel:1D:fe:group'),
              ('Finite element approximation of functions of $u$',
               3,
               None,
               '___sec382'),
              ('Simplified problem', 3, None, '___sec383'),
              ('Integrating nonlinear functions', 3, None, '___sec384'),
              ('Application of the group finite element method',
               3,
               None,
               '___sec385'),
              ('Numerical integration of nonlinear terms by hand',
               2,
               'nonlin:alglevel:1D:fe:f',
               'nonlin:alglevel:1D:fe:f'),
              ('Discretization of a variable coefficient Laplace term',
               2,
               'nonlin:alglevel:1D:fe:Laplace',
               'nonlin:alglevel:1D:fe:Laplace'),
              ('Group finite element method', 3, None, '___sec388'),
              ('Numerical integration at the nodes', 3, None, '___sec389'),
              ('Variational methods for linear systems', 0, 'ch:cg', 'ch:cg'),
              ('Conjugate gradient-like iterative methods',
               1,
               'ch:linalg:CGmethods',
               'ch:linalg:CGmethods'),
              ('The Galerkin method', 2, None, '___sec392'),
              ('The least squares method', 2, None, '___sec393'),
              ('Krylov subspaces', 2, None, '___sec394'),
              ('Computation of the basis vectors', 2, None, '___sec395'),
              ('Computation of a new solution vector', 2, None, '___sec396'),
              ('Summary of the least squares method', 2, None, '___sec397'),
              ('Remark', 3, None, '___sec398'),
              ('Truncation and restart', 2, None, '___sec399'),
              ('Summary of the Galerkin method', 2, None, '___sec400'),
              ('A framework based on the error', 2, None, '___sec401'),
              ('Preconditioning',
               1,
               'ch:linalg2:preconditioning',
               'ch:linalg2:preconditioning'),
              ('Motivation and Basic Principles', 2, None, '___sec403'),
              ('Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec404'),
              ('Classical iterative methods as preconditioners',
               2,
               'ch:linalg:SORprecond',
               'ch:linalg:SORprecond'),
              ('Incomplete factorization preconditioners',
               2,
               'linalg:ILU',
               'linalg:ILU'),
              ('Preconditioners developed for solving PDE problems',
               2,
               None,
               '___sec407'),
              ('Appendix: Useful formulas', 0, 'ch:formulas', 'ch:formulas'),
              ('Finite difference operator notation',
               1,
               'sec:form:fdop',
               'sec:form:fdop'),
              ('Truncation errors of finite difference approximations',
               1,
               'sec:form:truncerr',
               'sec:form:truncerr'),
              ('Finite differences of exponential functions',
               1,
               'sec:form:fdexp',
               'sec:form:fdexp'),
              ('Complex exponentials', 3, None, '___sec412'),
              ('Real exponentials', 3, None, '___sec413'),
              ('Finite differences of $t^n$',
               1,
               'sec:form:fdtn',
               'sec:form:fdtn'),
              ('Software', 2, None, '___sec415'),
              ('References', 1, None, '___sec416')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="fem-book-sol.html">Introduction to Numerical Methods for Variational Problems</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._fem-book-sol002.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#ch:preface" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol001.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplementary materials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol003.html#ch:overview" style="font-size: 80%;"><b>Quick overview of the finite element method</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol003.html#ch:approx:global" style="font-size: 80%;"><b>Function approximation by global functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec:plane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of planar vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#fem:approx:vec:Np1dim" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of general vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol004.html#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin or projection method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:LS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection (or Galerkin) method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on linear approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:LS:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbolic integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fall back on numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:exact1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perfect approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#fem:approx:global:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The regression method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overdetermined equation system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The normal equations derived from a least squares principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol005.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:illconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ill-conditioning</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fourier series</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#fem:approx:global:orth" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol006.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The interpolation (or collocation) principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of a polynomial</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Successful example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less successful example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remedy for strong oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#fem:approx:global:Bernstein" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bernstein polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol007.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation properties and convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of functions in higher dimensions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D basis functions as tensor products of 1D functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on polynomial basis in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:2D:global:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol008.html#fem:approx:3D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension to 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:linalg1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 1: Linear algebra refresher</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:vec:3Dby2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2: Approximate a three-dimensional vector in a plane</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:parabola_sine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 3: Approximate a parabola by a sine</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:exp:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 4: Approximate the exponential function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:sin:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 5: Approximate the sine function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:sine1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6: Approximate a steep function by sines</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:sine3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 7: Approximate a steep function by sines with boundary adjustment</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 8: Fourier series as a least squares approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 9: Approximate a steep function by Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol009.html#fem:approx:exer:tanh:Lagrange:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 10: Approximate a steep function by Lagrange polynomials and regression</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#ch:approx:fe" style="font-size: 80%;"><b>Function approximation by finite elements</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:def:elements:nodes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec62" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec64" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construction principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec65" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties of \( \basphi_i \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on quadratic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on linear finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on cubic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:global:linearsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating specific matrix entries</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating a general row in the matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:elementwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of element matrices</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of irregularly numbered elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:mapping" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mapping to a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The coordinate transformation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for the element matrix and vector entries</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for local basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol010.html#fem:approx:fe:intg:ref" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on integration over a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:intg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:linsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear system assembly and solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing symbolic approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:collocation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using interpolation instead of least squares</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex1:numeric" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing numerical approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:A:structure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:ex2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applications</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol011.html#fem:approx:fe:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sparse matrix storage and solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Comparison of finite elements and finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd:fdproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference approximation of given functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:approx:fe:fd:feproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpretation of a finite element approximation in terms of finite difference operators</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#fem:deq:1D:approx:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making finite elements behave as finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical space</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol012.html#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminology</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:terminology" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cells, vertices, and degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:def" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended finite element concept</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the error of the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol013.html#fem:approx:fe:element:impl:Hermite" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on cubic Hermite polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#fem:approx:fe:numint1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton-Cotes rules</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol014.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gauss-Legendre rules with optimized points</a></li>
     <!-- navigation toc: --> <li><a href="#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions over triangles in the physical domain</a></li>
     <!-- navigation toc: --> <li><a href="#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element matrices and vectors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions over triangles in the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Affine mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Isoparametric mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing integrals</a></li>
     <!-- navigation toc: --> <li><a href="#fe:approx:fenics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fenics:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on approximation in 2D using FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating SymPy and FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fenics:2D:2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refined code with curve plotting</a></li>
     <!-- navigation toc: --> <li><a href="#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpolation and projection</a></li>
     <!-- navigation toc: --> <li><a href="#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the solution along a line</a></li>
     <!-- navigation toc: --> <li><a href="#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating plotting and computations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec124" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:mesh1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 11: Define nodes and elements</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:mesh2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 12: Define vertices, cells, and dof maps</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:defmesh:sparsity" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 13: Construct matrix sparsity patterns</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:Asinwt:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 14: Perform symbolic finite element computations</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:exer:tanh:P1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 15: Approximate a steep function by P1 and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:exer:tanh:P3P4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 16: Approximate a steep function by P3 and P4 elements</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:Asinwt:interpol:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 17: Investigate the approximation error in finite elements</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:Heaviside" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 18: Approximate a step function by finite elements</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:2Dsines:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 19: 2D approximation with orthogonal functions</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:1D:trapez" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 20: Use the Trapezoidal rule and P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:1D:P1:vs:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 21: Compare P1 elements and interpolation</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:3D:approx3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 22: Implement 3D computations with global basis functions</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:exer:1D:simpson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 23: Use Simpson's rule and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 24: Make a 3D code for Lagrange elements of arbitrary order</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#ch:varform:global" style="font-size: 80%;"><b>Variational formulations with global basis functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:principles" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basic principles for approximating differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:models" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equation models</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:models:simple" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple model problems and their solutions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:residual:min" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forming the residual</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec146" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method of weighted residuals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#varform:trunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method of weighted residual and the truncation error</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test and trial functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The subdomain collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:ex:sines" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples on using the principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec152" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The residual</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec155" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec156" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec157" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The collocation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec158" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Weak form</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:essBC:Bfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec162" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing with global polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#fem:deq:1D:varform:ex:DN:case" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing with Dirichlet and Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol016.html#___sec164" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the numerical method is exact</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#fem:deq:1D:varform:abstract" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract notation for variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#fem:deq:1D:optimization" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational problems and minimization of functionals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec167" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec168" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The general minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec169" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec170" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimization of the discretized functional</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol017.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculus of variations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:deq:1D:varform:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Examples on variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variable coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec174" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First-order derivative in the equation and boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec175" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:global:deq:1D:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of the algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#fem:deq:1D:code:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extensions of the code for approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fallback to numerical methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#___sec179" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example with constant right-hand side</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol018.html#ch:convdiff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximations may fail: convection-diffusion</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#___sec181" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:BVP1D:class" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 25: Refactor functions into a more general class</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:tension:cable" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 26: Compute the deflection of a cable with sine functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:tension:cable_xn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 27: Compute the deflection of a cable with power functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol019.html#fem:deq:exer:intg:parts" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 28: Check integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#ch:varform:fe" style="font-size: 80%;"><b>Variational formulations with finite elements</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:fem1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing with finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec188" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element mesh and basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:comp:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation in the global physical domain</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:fdm_vs_fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison with a finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#fem:deq:1D:comp:elmwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The integral for the element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The integral for the element vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec194" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Detailed calculations of the element matrix and vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec195" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contributions from the first and last cell</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol020.html#___sec196" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:essBC" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Boundary conditions: specified nonzero value</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;General construction of a boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec199" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on computing with a finite element-based boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec200" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical coordinates</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec201" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations on the reference element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc:modsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#___sec203" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in the physical system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:deq:1D:fem:essBC:Bfunc:modsys:symm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetric modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol021.html#fem:bc:elmat:mod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the element matrix and vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Boundary conditions: specified derivative</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#___sec207" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:uLtest" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary term vanishes because of the test functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:uLmod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary term vanishes because of linear system modifications</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#fem:deq:1D:BC:nat:Aub" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct computation of the global linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol022.html#___sec211" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cellwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of finite element algorithms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extensions of the code for approximation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#fem:deq:1D:code:fe_sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utilizing a sparse matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol023.html#___sec215" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application to our model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:deq:2D:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational formulations in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec217" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integration by parts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#sec:varform:general:convdiff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on a multi-dimensional variational problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec219" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transformation to a reference cell in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec220" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec221" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenient formulas for P1 elements in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec222" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A glimpse of the mathematical theory of the finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec223" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec224" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example on an abstract variational form and associated spaces</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec225" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assumptions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec226" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Existence and uniqueness</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec227" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec228" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec229" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Best approximation principle</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec230" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Best approximation property in the norm of the space</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec231" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetric, positive definite coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec232" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent matrix minimization problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec233" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A priori error estimate for the derivative</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec234" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A priori error estimate for the solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation in 2D and 3D via FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics:problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec237" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symmetry</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#fem:varform:fenics:varform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec239" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The FEniCS solver</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec240" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making the mesh</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol024.html#___sec241" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving a problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol025.html#___sec242" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Convection-diffusion and Petrov-Galerkin methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol025.html#___sec243" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Summary</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#___sec244" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:2P1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 29: Compute the deflection of a cable with 2 P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 30: Compute the deflection of a cable with 1 P2 element</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:cable:stepload" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 31: Compute the deflection of a cable with a step load</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:mesh:nonuniform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 32: Compute with a non-uniform mesh</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:gen:problem1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 33: Solve a 1D finite element problem by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:exact_numerics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 34: Investigate exact finite element solutions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:Poisson:polar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:1D:gen:problem2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 36: Compute with variable coefficients and P1 elements by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:deq:exer:2D:torsion:xy:sin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 37: Solve a 2D Poisson equation using polynomials and sines</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:fenics:borehole:exer:3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 38: Solve a 3D Laplace problem with FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol026.html#fem:fenics:borehole:exer:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 39: Solve a 1D Laplace problem with FEniCS</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#ch:femtime" style="font-size: 80%;"><b>Time-dependent variational forms</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization in time by a Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec258" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec259" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Space discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec260" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec261" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notation for the solution at recent time levels</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec262" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving the linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec263" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computational algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE:cosex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example using cosinusoidal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:FE:fdvsP1fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing P1 elements with the finite difference method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec266" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lumping the mass matrix</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization in time by a Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec268" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec269" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec270" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec271" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference operators corresponding to P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:Dirichlet" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Dirichlet boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec273" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary function</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec274" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec275" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modification of the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:Dirichlet:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: Oscillating Dirichlet boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:diffu:anal" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Accuracy of the finite element solution</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec278" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Methods of analysis</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec279" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fourier components and dispersion relations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec280" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec281" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec282" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing amplification factors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#___sec283" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol027.html#fem:deq:exer:diffu:analysis:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 40: Analyze a Crank-Nicolson scheme for the diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#ch:femsys" style="font-size: 80%;"><b>Variational forms for systems of PDEs</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#fem:sys:vform" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Variational forms</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec287" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence of scalar PDEs formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec288" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector PDE formulation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#fem:sys:uT:ex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A worked example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec290" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Identical function spaces for the unknowns</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec291" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variational form of each individual PDE</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec292" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compound scalar variational form</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec293" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decoupled linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec294" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coupled linear systems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec295" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Different function spaces for the unknowns</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#femsys:cooling:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computations in 1D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#fem:sys:up:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Another example in 1D</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec298" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#femsys:exer:cooling:1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 41: Estimate order of convergence for the Cooling law</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#femsys:exer:cooling:2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 42: Estimate order of convergence for the Cooling law</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#ch:nitsche" style="font-size: 80%;"><b>Flexible implementations of boundary conditions</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:fxy:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization with constraint</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec303" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elimination of variables</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:fxy:opt:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange multiplier method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:fxy:opt:penalty" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Penalty method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Optimization of functionals</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:varcalculus" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classical calculus of variations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:penalty" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Penalty and Nitsche's methods for optimization with constraints</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lagrange multiplier method for optimization with constraints</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nitsche:pde:opt:1Dex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: 1D problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec311" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: adding a constraint in a Neumann problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#ch:nonlin" style="font-size: 80%;"><b>Nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Introduction of basic concepts</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec314" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear versus nonlinear equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec315" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec316" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec317" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple model problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:roots" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact solution of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec320" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec322" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec323" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A single Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by a geometric mean</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:relaxation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:timediscrete:logistic:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation and experiments</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:ode:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization to a general nonlinear ODE</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec329" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec330" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec331" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#nonlin:ode:generic:sys:pendulum" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Systems of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol028.html#___sec333" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Systems of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:terminate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#nonlin:systems:alg:SI" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: A nonlinear ODE model from epidemiology</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec339" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec340" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol029.html#___sec341" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization at the differential equation level</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:explicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time integration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec346" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization via Taylor expansions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec347" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity with Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec348" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#___sec349" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation with alternative notation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol030.html#nonlin:pdelevel:Picard:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#nonlin:alglevel:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;1D stationary nonlinear differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#nonlin:alglevel:1D:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec353" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution of algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec354" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the equation system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec355" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec356" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh with two cells</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol031.html#___sec357" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec358" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multi-dimensional PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#nonlin:alglevel:dD:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec360" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec361" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol032.html#___sec362" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continuation methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:lin:vs:nonlin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 43: Determine if equations are nonlinear or not</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:logistic:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 44: Derive and investigate a generalized logistic model</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:Newton:problems1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 45: Experience the behavior of Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:vib:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 46: Compute the Jacobian of a \( 2\times 2 \) system</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:vib:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 47: Solve nonlinear equations arising from a vibration ODE</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:products:arith:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 48: Find the truncation error of arithmetic mean of products</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:Newton:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 49: Newton's method for linear problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:1pu2:fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 50: Discretize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:1pu2:PicardNewton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 51: Linearize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:fu:discretize:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 52: Finite differences for the 1D Bratu problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:1D:heat:nonlinear:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 53: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:grad:pow:term" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 54: Differentiate a highly nonlinear term</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:2D:heat:nonlinear:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 55: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:sparsity:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 56: Find the sparsity of the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:exer:continuation:1DnNflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 57: Investigate a 1D problem with a continuation method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:app:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Symbolic nonlinear finite element equations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe_basis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe:group" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec382" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element approximation of functions of \( u \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec383" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified problem</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec384" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating nonlinear functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec385" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application of the group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe:f" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration of nonlinear terms by hand</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#nonlin:alglevel:1D:fe:Laplace" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization of a variable coefficient Laplace term</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec388" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol033.html#___sec389" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration at the nodes</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:cg" style="font-size: 80%;"><b>Variational methods for linear systems</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg:CGmethods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Conjugate gradient-like iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec392" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec393" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec394" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Krylov subspaces</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec395" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation of the basis vectors</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec396" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computation of a new solution vector</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec397" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec398" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec399" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation and restart</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec400" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of the Galerkin method</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec401" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A framework based on the error</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg2:preconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Preconditioning</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec403" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motivation and Basic Principles</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec404" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use of the preconditioning matrix in the iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#ch:linalg:SORprecond" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classical iterative methods as preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#linalg:ILU" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incomplete factorization preconditioners</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol035.html#___sec407" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preconditioners developed for solving PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#ch:formulas" style="font-size: 80%;"><b>Appendix: Useful formulas</b></a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdop" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference operator notation</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:truncerr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors of finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdexp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of exponential functions</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec412" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complex exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec413" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Real exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#sec:form:fdtn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of \( t^n \)</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol036.html#___sec415" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software</a></li>
     <!-- navigation toc: --> <li><a href="._fem-book-sol037.html#___sec416" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0015"></a>
<!-- !split -->

<h1 id="___sec107" class="anchor">Finite elements in 2D and 3D </h1>

<p>
Finite element approximation is particularly powerful in 2D and 3D because
the method can handle a geometrically complex domain \( \Omega \) with ease.
The principal idea is, as in 1D, to divide the domain into cells
and use polynomials for approximating a function over a cell.
Two popular cell shapes are triangles and quadrilaterals.
It is common to denote finite elements on triangles and tetrahedrons as P while
elements defined in terms of quadrilaterals and boxes are denoted by Q.
Figures <a href="#fem:approx:fe:2D:fig:rectP1">49</a>, <a href="#fem:approx:fe:2D:fig:circP1">50</a>,
and <a href="#fem:approx:fe:2D:fig:rectQ1">51</a> provide examples. P1 elements
means linear functions (\( a_0 + a_1x + a_2y \)) over triangles, while Q1 elements
have bilinear functions (\( a_0 + a_1x + a_2y + a_3xy \)) over rectangular cells.
Higher-order elements can easily be defined.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:rectP1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 49:  Example on 2D P1 elements.  <!-- caption label: fem:approx:fe:2D:fig:rectP1 --> </p></center>
<p><img src="fig/mesh2D_rect_P1.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:circP1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 50:  Example on 2D P1 elements in a deformed geometry.  <!-- caption label: fem:approx:fe:2D:fig:circP1 --> </p></center>
<p><img src="fig/mesh2D_quarter_circle.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:rectQ1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 51:  Example on 2D Q1 elements.  <!-- caption label: fem:approx:fe:2D:fig:rectQ1 --> </p></center>
<p><img src="fig/mesh2D_rect_Q1.png" align="bottom" width=400></p>
</center>

<h2 id="___sec108" class="anchor">Basis functions over triangles in the physical domain </h2>

<p>
Cells with triangular shape will be in main focus here.  With the P1
triangular element, \( u \) is a linear function over each cell, as
depicted in Figure <a href="#fem:approx:fe:2D:fig:femfunc">52</a>, with
discontinuous derivatives at the cell boundaries.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:femfunc"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 52:  Example on scalar function defined in terms of piecewise linear 2D functions defined on triangles.  <!-- caption label: fem:approx:fe:2D:fig:femfunc --> </p></center>
<p><img src="fig/demo2D_4x3r.png" align="bottom" width=400></p>
</center>

<p>
We give the vertices of the cells global and local numbers as in 1D.
The degrees of freedom in the P1 element are the function values at
a set of nodes, which are the three vertices.
The basis function \( \basphi_i(x,y) \) is then 1 at the vertex with global vertex
number \( i \) and zero at all other vertices.
On an element, the three degrees of freedom uniquely determine
the linear basis functions in that element, as usual.
The global
\( \basphi_i(x,y) \) function is then a combination of the linear functions
(planar surfaces)
over all the neighboring cells
that have vertex number \( i \) in common. Figure <a href="#fem:approx:fe:2D:fig:basphi">53</a>
tries to illustrate the shape of such a &quot;pyramid&quot;-like function.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:basphi"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 53:  Example on a piecewise linear 2D basis function over a patch of triangles.  <!-- caption label: fem:approx:fe:2D:fig:basphi --> </p></center>
<p><img src="fig/demo2D_basisfunc.png" align="bottom" width=400></p>
</center>

<h3 id="___sec109" class="anchor">Element matrices and vectors </h3>

<p>
As in 1D, we split the integral over \( \Omega \) into a sum of integrals
over cells. Also as in 1D, \( \basphi_i \) overlaps \( \basphi_j \)
(i.e., \( \basphi_i\basphi_j\neq 0 \)) if and only if
\( i \) and \( j \) are vertices in the same cell. Therefore, the integral
of \( \basphi_i\basphi_j \) over an element is nonzero only when \( i \) and \( j \)
run over the vertex numbers in the element. These nonzero contributions
to the coefficient matrix are, as in 1D, collected in an element matrix.
The size of the element matrix becomes \( 3\times 3 \) since there are
three degrees of freedom
that \( i \) and \( j \) run over. Again, as in 1D, we number the
local vertices in a cell, starting at 0, and add the entries in
the element matrix into the global system matrix, exactly as in 1D.
All details and code appear below.

<h2 id="___sec110" class="anchor">Basis functions over triangles in the reference cell </h2>

<p>
As in 1D, we can define the basis functions and the degrees of freedom
in a reference cell and then use a mapping from the reference coordinate
system to the physical coordinate system.
We also need a mapping of local degrees of freedom numbers to global degrees
of freedom numbers.
<!-- (<code>dof_map</code>). -->

<p>
The reference cell in an \( (X,Y) \) coordinate system has vertices
\( (0,0) \), \( (1,0) \), and \( (0,1) \), corresponding to local vertex numbers
0, 1, and 2, respectively. The P1 element has linear functions
\( \refphi_r(X,Y) \) as basis functions, \( r=0,1,2 \).
Since a linear function \( \refphi_r(X,Y) \) in 2D is on
the form \( C_{r,0} + C_{r,1}X + C_{r,2}Y \), and hence has three
parameters \( C_{r,0} \), \( C_{r,1} \), and \( C_{r,2} \), we need three
degrees of freedom. These are in general taken as the function values at a
set of nodes. For the P1 element the set of nodes is the three vertices.
Figure <a href="#fem:approx:fe:2D:fig:P12D">54</a> displays the geometry of the
element and the location of the nodes.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:P12D"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 54:  2D P1 element.  <!-- caption label: fem:approx:fe:2D:fig:P12D --> </p></center>
<p><img src="fig/fenics-book/elements/P1_2d.png" align="bottom" width=100></p>
</center>

<p>
Requiring \( \refphi_r=1 \) at node number \( r \) and
\( \refphi_r=0 \) at the two other nodes, gives three linear equations to
determine \( C_{r,0} \), \( C_{r,1} \), and \( C_{r,2} \). The result is

$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y,
\tag{3.55}\\ 
\refphi_1(X,Y) &= X,
\tag{3.56}\\ 
\refphi_2(X,Y) &= Y
\tag{3.57}
\end{align}
$$

<p>
Higher-order approximations are obtained by increasing the polynomial order,
adding additional nodes, and letting the degrees of freedom be
function values at the nodes. Figure <a href="#fem:approx:fe:2D:fig:P22D">55</a>
shows the location of the six nodes in the P2 element.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:P22D"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 55:  2D P2 element.  <!-- caption label: fem:approx:fe:2D:fig:P22D --> </p></center>
<p><img src="fig/fenics-book/elements/P2_2d.png" align="bottom" width=100></p>
</center>

<p>
<!-- 2DO: write up local basis funcs for P2 -->

<p>
A polynomial of degree \( p \) in \( X \) and \( Y \) has \( n_p=(p+1)(p+2)/2 \) terms
and hence needs \( n_p \) nodes. The values at the nodes constitute \( n_p \)
degrees of freedom. The location of the nodes for
\( \refphi_r \) up to degree 6 is displayed in Figure
<a href="#fem:approx:fe:2D:fig:P162D">56</a>.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:P162D"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 56:  2D P1, P2, P3, P4, P5, and P6 elements.  <!-- caption label: fem:approx:fe:2D:fig:P162D --> </p></center>
<p><img src="fig/fenics-book/elements/P1-6_2d.png" align="bottom" width=400></p>
</center>

<p>
The generalization to 3D is straightforward: the reference element is a
<a href="http://en.wikipedia.org/wiki/Tetrahedron" target="_self">tetrahedron</a>
with vertices \( (0,0,0) \), \( (1,0,0) \), \( (0,1,0) \), and \( (0,0,1) \)
in a \( X,Y,Z \) reference coordinate system. The P1 element has its degrees
of freedom as four nodes, which are the four vertices, see Figure
<a href="#fem:approx:fe:2D:fig:P1:123D">57</a>. The P2 element adds additional
nodes along the edges of the cell, yielding a total of 10 nodes and
degrees of freedom, see
Figure <a href="#fem:approx:fe:2D:fig:P2:123D">58</a>.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:P1:123D"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 57:  P1 elements in 1D, 2D, and 3D.  <!-- caption label: fem:approx:fe:2D:fig:P1:123D --> </p></center>
<p><img src="fig/fenics-book/elements/P1-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:2D:fig:P2:123D"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 58:  P2 elements in 1D, 2D, and 3D.  <!-- caption label: fem:approx:fe:2D:fig:P2:123D --> </p></center>
<p><img src="fig/fenics-book/elements/P2-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>
The interval in 1D, the triangle in 2D, the tetrahedron in 3D, and
its generalizations to higher space dimensions are known
as <em>simplex</em> cells (the geometry) or <em>simplex</em> elements (the geometry,
basis functions, degrees of freedom, etc.). The plural forms
<a href="http://en.wikipedia.org/wiki/Simplex" target="_self">simplices</a> and
simplexes are
also a much used shorter terms when referring to this type of cells or elements.
The side of a simplex is called a <em>face</em>, while the tetrahedron also
has <em>edges</em>.

<p>
<b>Acknowledgment.</b>
Figures <a href="#fem:approx:fe:2D:fig:P12D">54</a>-<a href="#fem:approx:fe:2D:fig:P2:123D">58</a>
are created by Anders Logg and taken from the <a href="https://launchpad.net/fenics-book" target="_self">FEniCS book</a>: <em>Automated Solution of Differential Equations by the Finite Element Method</em>, edited by A. Logg, K.-A. Mardal, and G. N. Wells, published
by <a href="http://goo.gl/lbyVMH" target="_self">Springer</a>, 2012.

<h2 id="___sec111" class="anchor">Affine mapping of the reference cell </h2>

<p>
Let \( \refphi_r^{(1)} \) denote the basis functions associated
with the P1 element in 1D, 2D, or 3D, and let \( \xdno{q(e,r)} \) be
the physical coordinates of local vertex number \( r \) in cell \( e \).
Furthermore,
let \( \X \) be a point in the reference coordinate system corresponding
to the point \( \x \) in the physical coordinate system.
The affine mapping of any \( \X \) onto \( \x \) is
then defined by

$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)},
\tag{3.58}
\end{equation}
$$

where \( r \) runs over the local vertex numbers in the cell.
The affine mapping essentially stretches, translates, and rotates
the triangle. Straight or planar faces of the reference cell are
therefore mapped onto
straight or planar faces in the physical coordinate system. The mapping can
be used for both P1 and higher-order elements, but note that the
mapping itself always applies the P1 basis functions.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:map:fig:2DP1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 59:  Affine mapping of a P1 element.  <!-- caption label: fem:approx:fe:map:fig:2DP1 --> </p></center>
<p><img src="fig/ElmT3n2D_map.png" align="bottom" width=400></p>
</center>

<h2 id="___sec112" class="anchor">Isoparametric mapping of the reference cell </h2>

<p>
Instead of using the P1 basis functions in the mapping
<a href="#mjx-eqn-3.58">(3.58)</a>,
we may use the basis functions of the actual P$d$ element:

$$
\begin{equation}
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)},
\tag{3.59}
\end{equation}
$$

where \( r \) runs over all nodes, i.e., all points associated with the
degrees of freedom. This is called an <em>isoparametric mapping</em>.
For P1 elements it is identical to the affine mapping
<a href="#mjx-eqn-3.58">(3.58)</a>, but for higher-order elements
the mapping of the straight or planar faces of the reference cell will
result in a <em>curved</em> face in the physical coordinate system.
For example, when we use the basis functions of the triangular P2 element
in 2D in <a href="#mjx-eqn-3.59">(3.59)</a>, the straight faces of the
reference triangle are mapped onto curved faces of parabolic shape in
the physical coordinate system, see Figure <a href="#fem:approx:fe:map:fig:2DP2">60</a>.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fe:map:fig:2DP2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 60:  Isoparametric mapping of a P2 element.  <!-- caption label: fem:approx:fe:map:fig:2DP2 --> </p></center>
<p><img src="fig/ElmT6n2D_map.png" align="bottom" width=400></p>
</center>

<p>
From <a href="#mjx-eqn-3.58">(3.58)</a> or
<a href="#mjx-eqn-3.59">(3.59)</a> it is easy to realize that the
vertices are correctly mapped. Consider a vertex with local number \( s \).
Then \( \refphi_s=1 \) at this vertex and zero at the others.
This means that only one term in the sum is nonzero and \( \x=\xdno{q(e,s)} \),
which is the coordinate of this vertex in the global coordinate system.

<h2 id="___sec113" class="anchor">Computing integrals </h2>

<p>
Let \( \tilde\Omega^r \) denote the reference cell and \( \Omega^{(e)} \)
the cell in the physical coordinate system. The transformation of
the integral from the physical to the reference coordinate system reads

$$
\begin{align}
\int_{\Omega^{(e)}}\basphi_i (\x) \basphi_j (\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) \refphi_j (\X)
\det J\, \dX,
\tag{3.60}\\ 
\int_{\Omega^{(e)}}\basphi_i (\x) f(\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) f(\x(\X)) \det J\, \dX,
\tag{3.61}
\end{align}
$$

where \( \dx \) means the infinitesimal area element \( dx dy \) in 2D and
\( dx dy dz \) in 3D, with a similar
definition of \( \dX \). The quantity \( \det J \) is the determinant of the
Jacobian of the mapping \( \x(\X) \). In 2D,

$$
\begin{equation}
J = \left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial x}{\partial Y}\\ 
\frac{\partial y}{\partial X} & \frac{\partial y}{\partial Y}
\end{array}\right], \quad
\det J = \frac{\partial x}{\partial X}\frac{\partial y}{\partial Y}
- \frac{\partial x}{\partial Y}\frac{\partial y}{\partial X}
\tp
\tag{3.62}
\end{equation}
$$

With the affine mapping
<a href="#mjx-eqn-3.58">(3.58)</a>, \( \det J=2\Delta \), where \( \Delta \) is
the area or volume of the cell in the physical coordinate system.

<p>
<b>Remark.</b>
Observe that finite elements in 2D and 3D builds on the same
<em>ideas</em> and <em>concepts</em> as in 1D, but there is simply much
more to compute because the
specific mathematical formulas in 2D and 3D are more complicated
and the book keeping with dof maps also gets more complicated.
The manual work is tedious, lengthy, and error-prone
so automation by the computer is a must.

<p>
<!-- 2DO -->
<!-- First: two triangles -->
<!-- vertices = [(0,0), (1,0), (0,1), (1,1)] -->
<!-- cells = [[0, 1, 3], [0, 3, 2]] -->
<!-- dof_map = cells -->
<!-- write up affine mapping -->
<!-- D is the area that sympy.Triangle can compute :-) No, do that directly! 0.5... -->
<!-- rhs: choose simple f=x*y, try hand-calculation or two-step -->
<!-- sympy: first integrate in y with (0,1-x) as limits, then -->
<!-- integrate the result in x -->
<!-- a = integrate(x*y*(1-x-y), (y, 0, 1-x)) -->
<!-- b = integrate(a, (x,0,1)) -->
<!-- use the same for local element matrix -->
<!-- show assembly -->
<!-- should have pysketcher prog for drawing 2D mesh, mark and number nodes -->
<!-- and elements -->

<p>
<!-- Should have example with x**8*(1-x)*y**8*(1-y) worked out, but -->
<!-- need software -->

<p>
<!-- Need 2D exercises -->

<h1 id="fe:approx:fenics" class="anchor">Implementation</h1>

<p>
Our previous programs for doing 1D approximation by finite element
basis function had a focus on all the small details needed to compute
the solution. When going to 2D and 3D, the basic algorithms are the
same, but the amount of computational details with basis functions,
reference functions, mappings, numerical integration and so on,
becomes overwhelming because of all the flexibility and choices of
elements. For this purpose, we <em>must</em>, except in the simplest cases
with P1 elements, use some well-developed, existing computer
library.

<h2 id="fem:approx:fenics:2D" class="anchor">Example on approximation in 2D using FEniCS</h2>

<p>
Here we shall use <a href="http://fenicsproject.org" target="_self">FEniCS</a>, which
is a free, open finite element package for advanced computations. The
package can be programmed in C++ or Python. How it works is best
illustrated by an example.

<h3 id="___sec116" class="anchor">Mathematical problem </h3>

<p>
We want to approximate the function \( f(x)=2xy - x^2 \) by P1 and P2 elements
on \( [0,2]\times[-1,1] \) using a division into \( 8\times 8 \) squares, which are
then divided into rectangles and then into triangles.

<h3 id="___sec117" class="anchor">The code </h3>

<p>
Observe that the code employs the basic concepts from 1D, but is
capable of using <em>any</em> element in FEniCS on <em>any</em> mesh in <em>any</em> number of
space dimensions (!).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">approx</span>(f, V):
     <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return Galerkin approximation to f in V.&quot;&quot;&quot;</span>
     u <span style="color: #666666">=</span> TrialFunction(V)
     v <span style="color: #666666">=</span> TestFunction(V)
     a <span style="color: #666666">=</span> u<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
     L <span style="color: #666666">=</span> f<span style="color: #666666">*</span>v<span style="color: #666666">*</span>dx
     u <span style="color: #666666">=</span> Function(V)
     solve(a <span style="color: #666666">==</span> L, u)
     <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">problem</span>():
    f <span style="color: #666666">=</span> Expression(<span style="color: #BA2121">&#39;2*x[0]*x[1] - pow(x[0], 2)&#39;</span>, degree<span style="color: #666666">=2</span>)
    mesh <span style="color: #666666">=</span> RectangleMesh(Point(<span style="color: #666666">0</span>,<span style="color: #666666">-1</span>), Point(<span style="color: #666666">2</span>,<span style="color: #666666">1</span>), <span style="color: #666666">8</span>, <span style="color: #666666">8</span>)

    V1 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">1</span>)
    u1 <span style="color: #666666">=</span> approx(f, V1)
    u1<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u1&#39;</span>, <span style="color: #BA2121">&#39;u1&#39;</span>)
    u1_error <span style="color: #666666">=</span> errornorm(f, u1, <span style="color: #BA2121">&#39;L2&#39;</span>)
    u1_norm <span style="color: #666666">=</span> norm(u1, <span style="color: #BA2121">&#39;L2&#39;</span>)

    V2 <span style="color: #666666">=</span> FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
    u2 <span style="color: #666666">=</span> approx(f, V2)
    u2<span style="color: #666666">.</span>rename(<span style="color: #BA2121">&#39;u2&#39;</span>, <span style="color: #BA2121">&#39;u2&#39;</span>)
    u2_error <span style="color: #666666">=</span> errornorm(f, u2, <span style="color: #BA2121">&#39;L2&#39;</span>)
    u2_norm <span style="color: #666666">=</span> norm(u2, <span style="color: #BA2121">&#39;L2&#39;</span>)

    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;L2 errors: e1=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, e2=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u1_error, u2_error))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;L2 norms:  n1=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, n2=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u1_norm, u2_norm))
    <span style="color: #408080; font-style: italic"># Simple plotting</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
    plot(f, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;f&#39;</span>, mesh<span style="color: #666666">=</span>mesh)
    plt<span style="color: #666666">.</span>show()
    plot(u1, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u1&#39;</span>)
    plt<span style="color: #666666">.</span>show()
    plot(u2, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u2&#39;</span>)
    plt<span style="color: #666666">.</span>show()

<span style="color: #008000; font-weight: bold">if</span> <span style="color: #19177C">__name__</span> <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    problem()
</pre></div>
<p>
Figure <a href="#fem:approx:fenics:2D:fig1">61</a> shows the computed <code>u1</code>. The plots of
<code>u2</code> and <code>f</code> are identical and therefore not shown.
The plot shows that visually the approximation is quite close to 
<code>f</code>, but to quantify it more precisely we simply compute the
error using the function <code>errornorm</code>. The output
of errors becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>L2 errors: e1=0.01314,   e2=4.93418e-15
L2 norms:  n1=4.46217,   n2=4.46219
</pre></div>
<p>
Hence, the second order approximation <code>u2</code> is able to reproduce
<code>f</code> up to floating point precision, whereas the first
order approximation <code>u1</code> has an error of slightly more than $\frac{1}{3}$\%.

<p>
<!-- Remember to rotate PDF file from internal FEniCS plotting: -->
<!-- pdftk dolfin_plot_1.pdf cat 1-endnorth output rotated_file.pdf -->

<p>
<center> <!-- figure label: --> <div id="fem:approx:fenics:2D:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 61:  Plot of the computed approximation using Lagrange elements of second order.  <!-- caption label: fem:approx:fenics:2D:fig1 --> </p></center>
<p><img src="fig/fenics_2D_plot_approx.png" align="bottom" width=400></p>
</center>

<h3 id="___sec118" class="anchor">Dissection of the code </h3>

<p>
The function <code>approx</code> is a general solver function for any \( f \) and
\( V \).  We define the unknown \( u \) in the variational form \( a=a(u,v) = \int uv\dx \)
as a <code>TrialFunction</code> object and the test function \( v \) as a
<code>TestFunction</code> object. Then we define the variational form through
the integrand <code>u*v*dx</code>. The linear form \( L \) is similarly defined as
<code>f*v*dx</code>. Here, <code>f</code> is an <code>Expression</code> object in FEniCS, i.e., a
formula defined in terms of a C++ expression. This expression is in turn
jit-compiled into a Python object for fast evaluation. With <code>a</code> and <code>L</code> defined,
we re-define <code>u</code> to be a finite element function <code>Function</code>, which is
now the unknown scalar field to be computed by the simple expression
<code>solve(a == L, u)</code>. We remark that the above function <code>approx</code>
is implemented in FEniCS (in a slightly more general fashion)
in the function  <code>project</code>.

<p>
The <code>problem</code> function applies <code>approx</code> to solve a specific problem.

<h3 id="___sec119" class="anchor">Integrating SymPy and FEniCS </h3>

<p>
The definition of \( f \) must be expressed in C++.  This part requires
two definitions: one of \( f \) and one of \( \Omega \), or more precisely:
the mesh (discrete \( \Omega \) divided into cells).  The definition of
\( f \) is here expressed in C++ (it will be compiled for fast
evaluation), where the independent coordinates are given by a C/C++
vector <code>x</code>. This means that \( x \) is <code>x[0]</code>, \( y \) is <code>x[1]</code>, and \( z \) is
<code>x[2]</code>. Moreover, <code>x[0]**2</code> must be written as <code>pow(x[0], 2)</code> in
C/C++.

<p>
Fortunately, we can easily integrate SymPy and <code>Expression</code> objects,
because SymPy can take a formula and translate it to C/C++ code, and
then we can require a Python code to numerically evaluate the formula.
Here is how we can specify <code>f</code> in SymPy and use it in FEniCS as an
<code>Expression</code> object:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">*</span>y <span style="color: #666666">-</span> x<span style="color: #666666">**2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span>(f)
<span style="color: #666666">-</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)   <span style="color: #408080; font-style: italic"># Translate to C code</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span>(f)
<span style="color: #666666">-</span><span style="color: #008000">pow</span>(x[<span style="color: #666666">0</span>], <span style="color: #666666">2</span>) <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>x[<span style="color: #666666">1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">fe</span>
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>Expression(f, degree<span style="color: #666666">=2</span>)
</pre></div>
<p>
Here, the function <code>ccode</code> generates C code and we use
<code>x</code> and <code>y</code> as placeholders for
<code>x[0]</code> and <code>x[1]</code>, which represent the coordinate of
a general point <code>x</code> in any dimension. The output of  <code>ccode</code>
can then be used directly in  <code>Expression</code>.

<h2 id="fem:approx:fenics:2D:2" class="anchor">Refined code with curve plotting</h2>

<h3 id="___sec121" class="anchor">Interpolation and projection </h3>

<p>
The operation with defining <code>a</code>, <code>L</code>, and solving for a <code>u</code> is so
common that it has been implemented in the FEniCS function <code>project</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> project(f, V)
</pre></div>
<p>
So, there is no need for our <code>approx</code> function!

<p>
If we want to do interpolation (or collocation) instead, we simply do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>u <span style="color: #666666">=</span> interpolate(f, V)
</pre></div>

<h3 id="___sec122" class="anchor">Plotting the solution along a line </h3>

<p>
Having <code>u</code> and <code>f</code> available as finite element functions (<code>Function</code>
objects), we can easily plot the solution along a line since FEniCS
has functionality for evaluating a <code>Function</code> at arbitrary points
<em>inside the domain</em>. For example, here is the code for plotting \( u \) and
\( f \) along a line \( x=\hbox{const} \) or \( y=\hbox{const} \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">comparison_plot2D</span>(
    u, f,           <span style="color: #408080; font-style: italic"># Function expressions in x and y</span>
    value<span style="color: #666666">=0.5</span>,      <span style="color: #408080; font-style: italic"># x or y equals this value</span>
    variation<span style="color: #666666">=</span><span style="color: #BA2121">&#39;y&#39;</span>,  <span style="color: #408080; font-style: italic"># independent variable</span>
    n<span style="color: #666666">=100</span>,          <span style="color: #408080; font-style: italic"># no if intervals in plot</span>
    tol<span style="color: #666666">=1E-8</span>,       <span style="color: #408080; font-style: italic"># tolerance for points inside the domain</span>
    plottitle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;&#39;</span>,   <span style="color: #408080; font-style: italic"># heading in plot</span>
    filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp&#39;</span>, <span style="color: #408080; font-style: italic"># stem of filename</span>
    ):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Plot u and f along a line in x or y dir with n intervals</span>
<span style="color: #BA2121; font-style: italic">    and a tolerance of tol for points inside the domain.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    v <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1+</span>tol, <span style="color: #666666">1-</span>tol, n<span style="color: #666666">+1</span>)
    <span style="color: #408080; font-style: italic"># Compute points along specified line:</span>
    points <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([(value, v_)
                       <span style="color: #008000; font-weight: bold">if</span> variation <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;y&#39;</span> <span style="color: #008000; font-weight: bold">else</span> (v_, value)
                       <span style="color: #008000; font-weight: bold">for</span> v_ <span style="color: #AA22FF; font-weight: bold">in</span> v])
    u_values <span style="color: #666666">=</span> [u(point) <span style="color: #008000; font-weight: bold">for</span> point <span style="color: #AA22FF; font-weight: bold">in</span> points] <span style="color: #408080; font-style: italic"># eval. Function</span>
    f_values <span style="color: #666666">=</span> [f(point) <span style="color: #008000; font-weight: bold">for</span> point <span style="color: #AA22FF; font-weight: bold">in</span> points]
    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(v, u_values, <span style="color: #BA2121">&#39;r-&#39;</span>, v, f_values, <span style="color: #BA2121">&#39;b--&#39;</span>)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;f&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
    <span style="color: #008000; font-weight: bold">if</span> variation <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;y&#39;</span>:
        plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;y&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u, f&#39;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u, f&#39;</span>)
    plt<span style="color: #666666">.</span>title(plottitle)
    plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.png&#39;</span>)
</pre></div>

<h3 id="___sec123" class="anchor">Integrating plotting and computations </h3>

<p>
It is now very easy to give some graphical impression of the approximations
for various kinds of 2D elements.
Basically, to solve the problem of approximating \( f=2xy-x^2 \) on \( \Omega = [-1,1]\times [0,2] \) by P2 elements on a \( 2\times 2 \) mesh,
we want to integrate the function above with following type of computations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">fe</span>
f <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>Expression(<span style="color: #BA2121">&#39;2*x[0]*x[1] - pow(x[0], 2)&#39;</span>, degree<span style="color: #666666">=2</span>)
mesh <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>RectangleMesh(fe<span style="color: #666666">.</span>Point(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>), fe<span style="color: #666666">.</span>Point(<span style="color: #666666">2</span>,<span style="color: #666666">1</span>), <span style="color: #666666">2</span>, <span style="color: #666666">2</span>)
V <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, <span style="color: #666666">2</span>)
u <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>project(f, V)
err <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>errornorm(f, u, <span style="color: #BA2121">&#39;L2&#39;</span>)
<span style="color: #008000; font-weight: bold">print</span>(err)
</pre></div>
<p>
However, we can now easily compare different type of elements and
mesh resolutions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">fenics</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">fe</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x[0] x[1]&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">problem</span>(f, nx<span style="color: #666666">=8</span>, ny<span style="color: #666666">=8</span>, degrees<span style="color: #666666">=</span>[<span style="color: #666666">1</span>,<span style="color: #666666">2</span>]):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Plot u along x=const or y=const for Lagrange elements,</span>
<span style="color: #BA2121; font-style: italic">    of given degrees, on a nx times ny mesh. f is a SymPy expression.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>printing<span style="color: #666666">.</span>ccode(f)
    f <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>Expression(f, degree<span style="color: #666666">=2</span>)
    mesh <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>RectangleMesh(
        fe<span style="color: #666666">.</span>Point(<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>), fe<span style="color: #666666">.</span>Point(<span style="color: #666666">1</span>, <span style="color: #666666">2</span>), <span style="color: #666666">2</span>, <span style="color: #666666">2</span>)
    <span style="color: #008000; font-weight: bold">for</span> degree <span style="color: #AA22FF; font-weight: bold">in</span> degrees:
        <span style="color: #008000; font-weight: bold">if</span> degree <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            <span style="color: #408080; font-style: italic"># The P0 element is specified like this in FEniCS</span>
            V <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>FunctionSpace(mesh, <span style="color: #BA2121">&#39;DG&#39;</span>, <span style="color: #666666">0</span>)
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #408080; font-style: italic"># The Lagrange Pd family of elements, d=1,2,3,...</span>
            V <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>FunctionSpace(mesh, <span style="color: #BA2121">&#39;P&#39;</span>, degree)
        u <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>project(f, V)
        u_error <span style="color: #666666">=</span> fe<span style="color: #666666">.</span>errornorm(f, u, <span style="color: #BA2121">&#39;L2&#39;</span>)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;||u-f||=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> u_error, degree)
        comparison_plot2D(
            u, f,
            n<span style="color: #666666">=50</span>,
            value<span style="color: #666666">=0.4</span>, variation<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x&#39;</span>,
            plottitle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Approximation by P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements&#39;</span> <span style="color: #666666">%</span> degree,
            filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;approx_fenics_by_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> degree,
            tol<span style="color: #666666">=1E-3</span>)
        <span style="color: #408080; font-style: italic">#fe.plot(u, title=&#39;Approx by P%d&#39; % degree)</span>

<span style="color: #008000; font-weight: bold">if</span> <span style="color: #19177C">__name__</span> <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    <span style="color: #408080; font-style: italic"># x and y are global SymPy variables</span>
    f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">*</span>y <span style="color: #666666">-</span> x<span style="color: #666666">**16</span>
    f <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">*</span>y <span style="color: #666666">-</span> x<span style="color: #666666">**2</span>
    problem(f, nx<span style="color: #666666">=2</span>, ny<span style="color: #666666">=2</span>, degrees<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
(We note that this code issues a lot of warnings from the <code>u(point)</code>
evaluations.)

<p>
We show in Figure <a href="#fem:approx:fenics:2D:2:fig1">62</a>
how \( f \) is approximated by P0, P1, and P2 elements
on a very coarse \( 2\times 2 \) mesh consisting of 8 cells.

<p>
We have also added the result obtained by P2 elements.

<p>
<center> <!-- figure label: --> <div id="fem:approx:fenics:2D:2:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 62:  Comparison of P0, P1, and P2 approximations (left to right) along a line in a 2D mesh.  <!-- caption label: fem:approx:fenics:2D:2:fig1 --> </p></center>
<p><img src="fig/approx_fenics_f1.png" align="bottom" width=800></p>
</center>

<p>
<div class="alert alert-block alert-info alert-text-normal"><b>Questions.</b>
There are two striking features in the figure:

<ol>
<li> The P2 solution is exact. Why?</li>
<li> The P1 solution does not seem to be a least squares approximation. Why?</li>
</ol>
</div>


<p>
<!-- 1. f is of degree 2 so V covers f and therefore the P2 solution is an exact -->
<!-- of f everywhere. -->
<!-- 2. P1 solution is along a line and the curve is more over than under -->
<!-- f, but in other places it must be the other way around such that over -->
<!-- the entire domain \( \Omega \) we have a least squares approximation! -->

<p>
With this code, found in the file <a href="$approx_fenics.py" target="_self"><tt>approx_fenics.py</tt></a>,
we can easily run lots of experiments with the Lagrange element family.
Just write the
SymPy expression and choose the mesh resolution!

<h1 id="___sec124" class="anchor">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh1" class="anchor">Problem 11: Define nodes and elements</h2>

<p>
Consider a domain \( \Omega =[0,2] \) divided into the three elements
\( [0,1] \), \( [1,1.2] \), and \( [1.2,2] \).

<p>
For P1 and P2 elements, set up the list of coordinates and nodes
(<code>nodes</code>) and the numbers of the nodes that belong to each element
(<code>elements</code>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_1">

<p>
We can write up figure sketches and the data structure in code:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># P1 elements</span>
<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes    <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes    <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]


<span style="color: #408080; font-style: italic"># P2 elements</span>

<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    0  1  2  3  4  5  6</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.1</span>, <span style="color: #666666">1.6</span>, <span style="color: #666666">2</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">5</span>,<span style="color: #666666">6</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    6  5  4  3  2  1  0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.6</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1.1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">3</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">6</span>,<span style="color: #666666">5</span>,<span style="color: #666666">4</span>]]
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_numberings1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh2" class="anchor">Problem 12: Define vertices, cells, and dof maps</h2>

<p>
Repeat <a href="#fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</a>, but define the
data structures <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> instead of
<code>nodes</code> and <code>elements</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_12_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_12_1">

<p>
Written in Python, the solution becomes

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># P1 elements</span>
<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">dofs:     0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #408080; font-style: italic"># elements:   0   1   2</span>
<span style="color: #408080; font-style: italic"># vertices: 0   1   2   3</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">dofs:     3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]


<span style="color: #408080; font-style: italic"># P2 elements</span>

<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #408080; font-style: italic"># elements:   0   1   2</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">dofs:     0  1  2  3  4  5  6</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">5</span>,<span style="color: #666666">6</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #408080; font-style: italic"># elements:   2   1   0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">dofs:     6  5  4  3  2  1  0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">3</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">6</span>,<span style="color: #666666">5</span>,<span style="color: #666666">4</span>]]
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_numberings2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:defmesh:sparsity" class="anchor">Problem 13: Construct matrix sparsity patterns</h2>

<p>
<a href="#fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a \( 5\times 5 \) matrix and fill in the entries that will be nonzero.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_13_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_13_1">

<p>
A matrix entry \( (i,j) \) is nonzero if \( i \) and \( j \) are nodes in the
same element.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_13_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_13_2">

<p>
If we create an empty matrix, we can run through all elements and
then over all local node pairs and mark that the corresponding
entry \( (i,j) \) in the global matrix is a nonzero entry.
The <code>elements</code> data structure is sufficient. Below is a program
that fills matrix entries with an <code>X</code> and prints the matrix sparsity
pattern.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sparsity_pattern</span>(elements, N_n):
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    matrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N_n, N_n), dtype<span style="color: #666666">=</span><span style="color: #008000">str</span>)
    matrix[:,:] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;0&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> elements:
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> e:
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> e:
                matrix[i,j] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;X&#39;</span>
    matrix <span style="color: #666666">=</span> matrix<span style="color: #666666">.</span>tolist()
    matrix <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([matrix[i][j]
                                  <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(matrix[i]))])
                        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(matrix))])
    <span style="color: #008000; font-weight: bold">return</span> matrix


<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P1 elements, left-to-right numbering&#39;</span>)
N_n <span style="color: #666666">=</span> <span style="color: #666666">4</span>
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]
<span style="color: #008000; font-weight: bold">print</span>(sparsity_pattern(elements, N_n))

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P1 elements, right-to-left numbering&#39;</span>)
elements <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]
<span style="color: #008000; font-weight: bold">print</span>(sparsity_pattern(elements, N_n))

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P2 elements, left-to-right numbering&#39;</span>)
N_n <span style="color: #666666">=</span> <span style="color: #666666">7</span>
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">5</span>,<span style="color: #666666">6</span>]]
<span style="color: #008000; font-weight: bold">print</span>(sparsity_pattern(elements, N_n))

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P1 elements, right-to-left numbering&#39;</span>)
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">3</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">6</span>,<span style="color: #666666">5</span>,<span style="color: #666666">4</span>]]
<span style="color: #008000; font-weight: bold">print</span>(sparsity_pattern(elements, N_n))
</pre></div>
<p>
The output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>P1 elements, left-to-right numbering
X X 0 0
X X X 0
0 X X X
0 0 X X

P1 elements, right-to-left numbering
X X 0 0
X X X 0
0 X X X
0 0 X X

P2 elements, left-to-right numbering
X X X 0 0 0 0
X X X 0 0 0 0
X X X X X 0 0
0 0 X X X 0 0
0 0 X X X X X
0 0 0 0 X X X
0 0 0 0 X X X

P1 elements, right-to-left numbering
X X X 0 0 0 0
X X X 0 0 0 0
X X X X X 0 0
0 0 X X X 0 0
0 0 X X X X X
0 0 0 0 X X X
0 0 0 0 X X X
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_sparsity_pattern</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:symbolic" class="anchor">Problem 14: Perform symbolic finite element computations</h2>

<p>
Perform symbolic calculations to find formulas for the coefficient
matrix and right-hand side when approximating \( f(x) = \sin (x) \) on
\( \Omega=[0, \pi] \) by two P1 elements of size \( \pi/2 \).  Solve the
system and compare \( u(\pi/2) \) with the exact value 1.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_14_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_14_1">

<p>
Here are suitable <code>sympy</code> commands:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #408080; font-style: italic"># Mesh: |--------|-------|</span>
<span style="color: #408080; font-style: italic">#       0      pi/2      pi</span>
<span style="color: #408080; font-style: italic">#</span>
<span style="color: #408080; font-style: italic"># Basis functions:</span>
<span style="color: #408080; font-style: italic">#</span>
<span style="color: #408080; font-style: italic">#   phi_0   phi_1   phi_2</span>
<span style="color: #408080; font-style: italic">#     \      /\      /</span>
<span style="color: #408080; font-style: italic">#      \    /  \    /</span>
<span style="color: #408080; font-style: italic">#       \  /    \  /</span>
<span style="color: #408080; font-style: italic">#        \/      \/</span>
<span style="color: #408080; font-style: italic">#     |-------|-------|</span>
<span style="color: #408080; font-style: italic">#     0      pi/2     pi</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(<span style="color: #666666">3</span>,<span style="color: #666666">3</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin

phi_0 <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">2*</span>x)<span style="color: #666666">/</span>sym<span style="color: #666666">.</span>pi
phi_1l <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">/</span>sym<span style="color: #666666">.</span>pi          <span style="color: #408080; font-style: italic"># left part of phi_1</span>
phi_1r <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> (<span style="color: #666666">2*</span>x)<span style="color: #666666">/</span>sym<span style="color: #666666">.</span>pi    <span style="color: #408080; font-style: italic"># right part of phi_1</span>
phi_2 <span style="color: #666666">=</span> x<span style="color: #666666">/</span>(sym<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span>) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
node_0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>
node_1 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span>
node_2 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>pi

<span style="color: #408080; font-style: italic"># Diagonal terms</span>
A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_0<span style="color: #666666">**2</span>,  (x, node_0, node_1))
A[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_1l<span style="color: #666666">**2</span>, (x, node_0, node_1)) <span style="color: #666666">+</span> \
         sym<span style="color: #666666">.</span>integrate(phi_1r<span style="color: #666666">**2</span>, (x, node_1, node_2))
A[<span style="color: #666666">2</span>,<span style="color: #666666">2</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_2<span style="color: #666666">**2</span>,  (x, node_1, node_2))

<span style="color: #408080; font-style: italic"># Off-diagonal terms</span>
A[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_0<span style="color: #666666">*</span>phi_1l, (x, node_0, node_1))
A[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> A[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]

A[<span style="color: #666666">1</span>,<span style="color: #666666">2</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_1r<span style="color: #666666">*</span>phi_2, (x, node_1, node_2))
A[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> A[<span style="color: #666666">1</span>,<span style="color: #666666">2</span>]

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A)  <span style="color: #408080; font-style: italic"># Can compare with general matrix, h=pi/2</span>

b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(<span style="color: #666666">3</span>,<span style="color: #666666">1</span>)

b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_0<span style="color: #666666">*</span>f(x),  (x, node_0, node_1))
b[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_1l<span style="color: #666666">*</span>f(x), (x, node_0, node_1)) <span style="color: #666666">+</span> \
       sym<span style="color: #666666">.</span>integrate(phi_1r<span style="color: #666666">*</span>f(x), (x, node_1, node_2))
b[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_2<span style="color: #666666">*</span>f(x),  (x, node_1, node_2))

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b)

c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;c:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, c)

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(c)):
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;c[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (i, c[i]<span style="color: #666666">.</span>evalf()))
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;u(pi/2)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> c[<span style="color: #666666">1</span>])

<span style="color: #408080; font-style: italic"># For reports</span>
<span style="color: #008000; font-weight: bold">print</span>(sym<span style="color: #666666">.</span>latex(A))
<span style="color: #008000; font-weight: bold">print</span>(sym<span style="color: #666666">.</span>latex(b))
<span style="color: #008000; font-weight: bold">print</span>(sym<span style="color: #666666">.</span>latex(c))
</pre></div>
<p>
Running the program, we get the matrix system

$$
\left[\begin{matrix}\frac{\pi}{6} & \frac{\pi}{12} & 0\\\frac{\pi}{12} & \frac{\pi}{3} & \frac{\pi}{12}\\0 & \frac{\pi}{12} & \frac{\pi}{6}\end{matrix}\right]
\left[\begin{matrix}\frac{1}{\pi} \left(- \frac{24}{\pi} + 8\right)\\\frac{-28 + \frac{168}{\pi}}{7 \pi}\\\frac{1}{\pi} \left(- \frac{24}{\pi} + 8\right)\end{matrix}\right]
=
\left[\begin{matrix}- \frac{2}{\pi} + 1\\\frac{4}{\pi}\\- \frac{2}{\pi} + 1\end{matrix}\right]
$$

The solution at the midpoint is \( 1.15847 \), i.e., 16% error.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_sin_P1</code>.

<p>
<!-- Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b), -->
<!-- which is the integral -->
<!-- that arises on the right-hand side. -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P1P2" class="anchor">Problem 15: Approximate a steep function by P1 and P2 elements</h2>

<p>
Given

$$
\begin{equation*} f(x) = \tanh(s(x-\half))\end{equation*}
$$

use the Galerkin or least squares method with finite elements to find
an approximate function \( u(x) \). Choose \( s=20 \) and try
\( N_e=4,8,16 \) P1 elements and
\( N_e=2,4,8 \) P2 elements.
Integrate \( f\basphi_i \) numerically.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_15_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_15_1">

<p>
You can automate the computations by calling the <code>approximate</code> method
in the <code>fe_approx1D_numint</code> module.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_15_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_15_2">

<p>
The set of calls to <code>approximate</code> becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> approximate
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> tanh, Symbol
x <span style="color: #666666">=</span> Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

steepness <span style="color: #666666">=</span> <span style="color: #666666">20</span>
arg <span style="color: #666666">=</span> steepness<span style="color: #666666">*</span>(x<span style="color: #666666">-0.5</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>,
            d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p1_tanh_4e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>,
            d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=8</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p1_tanh_8e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>,
            d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=16</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p1_tanh_16e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>,
            d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=2</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p2_tanh_2e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>,
            d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p2_tanh_4e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>,
            d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=8</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p2_tanh_8e&#39;</span>)
</pre></div>
<p>
<br /><br /><center><p><img src="fig/fe_p1_tanh.png" align="bottom" width=800></p></center><br /><br />

<p>
<br /><br /><center><p><img src="fig/fe_p2_tanh.png" align="bottom" width=800></p></center><br /><br />

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_tanh_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P3P4" class="anchor">Problem 16: Approximate a steep function by P3 and P4 elements</h2>

<p>
<b>a)</b>
Solve <a href="#fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</a> using \( N_e=1,2,4 \) P3 and P4
elements.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_1">

<p>
We can easily adopt the code from <a href="#fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> approximate, u_glob
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> tanh, Symbol, lambdify
x <span style="color: #666666">=</span> Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

steepness <span style="color: #666666">=</span> <span style="color: #666666">20</span>
arg <span style="color: #666666">=</span> steepness<span style="color: #666666">*</span>(x<span style="color: #666666">-0.5</span>)

approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>,
            d<span style="color: #666666">=3</span>, N_e<span style="color: #666666">=1</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p3_tanh_1e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>,
            d<span style="color: #666666">=3</span>, N_e<span style="color: #666666">=2</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p3_tanh_2e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>,
            d<span style="color: #666666">=3</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p3_tanh_4e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>,
            d<span style="color: #666666">=4</span>, N_e<span style="color: #666666">=1</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p4_tanh_1e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>,
            d<span style="color: #666666">=4</span>, N_e<span style="color: #666666">=2</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p4_tanh_2e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>,
            d<span style="color: #666666">=4</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p4_tanh_4e&#39;</span>)
</pre></div>
<p>
<br /><br /><center><p><img src="fig/fe_p3_tanh.png" align="bottom" width=800></p></center><br /><br />

<p>
<br /><br /><center><p><img src="fig/fe_p4_tanh.png" align="bottom" width=800></p></center><br /><br />

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
How will an interpolation method work in
this case with the same number of nodes?

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_2">

<p>
The coefficients arising from the interpolation method are trivial to compute
since \( c_i=f(x_i) \), where \( x_i \) are the global nodes. The function
<code>u_glob</code> in the <code>fe_approx1D_numint</code> module can be used to compute
appropriate arrays for plotting the resulting finite element function.
We create plots where the finite element approximation is shown along
with \( f(x) \) and the interpolation points.
Since <code>u_glob</code> requires the <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> data
structures, we must compute these for the values of number of
elements (\( N_e \)) and the polynomial degree (\( d \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Interpolation method</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
f <span style="color: #666666">=</span> lambdify([x], tanh(arg), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)

<span style="color: #408080; font-style: italic"># Compute exact f on a fine mesh</span>
x_fine <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">101</span>)
f_fine <span style="color: #666666">=</span> f(x_fine)

<span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">3</span>, <span style="color: #666666">4</span>:
    <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">4</span>:
        h <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>N_e  <span style="color: #408080; font-style: italic"># element length</span>
        vertices <span style="color: #666666">=</span> [i<span style="color: #666666">*</span>h <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e<span style="color: #666666">+1</span>)]
        cells <span style="color: #666666">=</span> [[e, e<span style="color: #666666">+1</span>] <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]
        dof_map <span style="color: #666666">=</span> [[d<span style="color: #666666">*</span>e <span style="color: #666666">+</span> i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)] <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]
        N_n <span style="color: #666666">=</span> d<span style="color: #666666">*</span>N_e <span style="color: #666666">+</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Number of nodes</span>
        x_nodes <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, N_n)  <span style="color: #408080; font-style: italic"># Node coordinates</span>
        U <span style="color: #666666">=</span> f(x_nodes)  <span style="color: #408080; font-style: italic"># Interpolation method samples node values</span>
        x, u, _ <span style="color: #666666">=</span> u_glob(U, vertices, cells, dof_map,
                         resolution_per_element<span style="color: #666666">=51</span>)
        plt<span style="color: #666666">.</span>figure()
        plt<span style="color: #666666">.</span>plot(x, u, <span style="color: #BA2121">&#39;-&#39;</span>, x_fine, f_fine, <span style="color: #BA2121">&#39;--&#39;</span>,
                 x_nodes, U, <span style="color: #BA2121">&#39;bo&#39;</span>)
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements&#39;</span> <span style="color: #666666">%</span> (N_e, d),
                    <span style="color: #BA2121">&#39;exact&#39;</span>, <span style="color: #BA2121">&#39;interpolation points&#39;</span>],
                   loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> (N_e, d))
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (N_e, d))
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<br /><br /><center><p><img src="fig/tanh_fe_interpol_P3.png" align="bottom" width=800></p></center><br /><br />

<p>
<br /><br /><center><p><img src="fig/tanh_fe_interpol_P4.png" align="bottom" width=800></p></center><br /><br />

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>fe_tanh_P3P4</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:interpol:error" class="anchor">Exercise 17: Investigate the approximation error in finite elements</h2>

<p>
The theory <a href="._fem-book-sol013.html#mjx-eqn-3.42">(3.42)</a> from the section <a href="._fem-book-sol013.html#fem:approx:fe:error">Computing the error of the approximation</a> predicts that the error in the P$d$
approximation of a function should behave as \( h^{d+1} \), where \( h \) is
the length of the element. Use experiments to verify this asymptotic
behavior (i.e., for small enough \( h \)).  Choose three examples:
\( f(x)=Ae^{-\omega x} \) on \( [0,3/\omega] \), \( f(x) = A\sin (\omega x) \) on
\( \Omega=[0, 2\pi/\omega] \) for constant \( A \) and \( \omega \), and
\( f(x)=\sqrt{x} \) on \( [0,1] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_1">

<p>
Run a series of experiments: \( (h_i,E_i) \), \( i=0,\ldots,m \), where \( E_i \)
is the \( L^2 \) norm of the error corresponding to element length \( h_i \).
Assume an error model \( E=Ch^r \) and compute \( r \) from two successive
experiments:

$$ r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1\tp$$

Hopefully, the sequence \( r_0,\ldots,r_{m-1} \) converges to the true
\( r \), and \( r_{m-1} \) can be taken as an approximation to \( r \).
Run such experiments for different \( d \) for the different \( f(x) \) functions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_2">

<p>
The <code>approximate</code> function in <code>fe_approx1D_numint.py</code> is handy for
calculating the numerical solution. This function returns the
finite element solution as the coefficients \( \sequencei{c} \).
To compute \( u \), use <code>u_glob</code> from the same module.
Use the Trapezoidal rule to integrate the \( L^2 \) error:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>xc, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map)
e <span style="color: #666666">=</span> f_func(xc) <span style="color: #666666">-</span> u
L2_error <span style="color: #666666">=</span> <span style="color: #666666">0</span>
e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(xc)<span style="color: #666666">-1</span>):
    L2_error <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(e2[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> e2[i])<span style="color: #666666">*</span>(xc[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> xc[i])
L2_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(L2_error)
</pre></div>
<p>
The reason for this Trapezoidal integration is
that <code>u_glob</code> returns coordinates <code>xc</code> and corresponding <code>u</code> values
where some of the coordinates (the cell vertices) coincides, because
the solution is computed in one element at a time, using all local
nodes. Also note that there are many coordinates in \( xc \) per cell
such that we can accurately compute the error inside each cell.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_3">

<p>
Here is an appropriate program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> approximate, mesh_uniform, u_glob
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, exp, sin, Symbol, lambdify, simplify
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log

x <span style="color: #666666">=</span> Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
A <span style="color: #666666">=</span> <span style="color: #666666">1</span>
w <span style="color: #666666">=</span> <span style="color: #666666">1</span>

cases <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;sqrt&#39;</span>: {<span style="color: #BA2121">&#39;f&#39;</span>: sqrt(x), <span style="color: #BA2121">&#39;Omega&#39;</span>: [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]},
         <span style="color: #BA2121">&#39;exp&#39;</span>: {<span style="color: #BA2121">&#39;f&#39;</span>: A<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>w<span style="color: #666666">*</span>x), <span style="color: #BA2121">&#39;Omega&#39;</span>: [<span style="color: #666666">0</span>, <span style="color: #666666">3.0/</span>w]},
         <span style="color: #BA2121">&#39;sin&#39;</span>: {<span style="color: #BA2121">&#39;f&#39;</span>: A<span style="color: #666666">*</span>sin(w<span style="color: #666666">*</span>x), <span style="color: #BA2121">&#39;Omega&#39;</span>: [<span style="color: #666666">0</span>, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">/</span>w]}}

results <span style="color: #666666">=</span> {}
d_values <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]

<span style="color: #008000; font-weight: bold">for</span> case <span style="color: #AA22FF; font-weight: bold">in</span> cases:
    f <span style="color: #666666">=</span> cases[case][<span style="color: #BA2121">&#39;f&#39;</span>]
    f_func <span style="color: #666666">=</span> lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    Omega <span style="color: #666666">=</span> cases[case][<span style="color: #BA2121">&#39;Omega&#39;</span>]
    results[case] <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> d_values:
        results[case][d] <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;E&#39;</span>: [], <span style="color: #BA2121">&#39;h&#39;</span>: [], <span style="color: #BA2121">&#39;r&#39;</span>: []}
        <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">16</span>, <span style="color: #666666">32</span>, <span style="color: #666666">64</span>, <span style="color: #666666">128</span>]:
            <span style="color: #008000; font-weight: bold">try</span>:
                c <span style="color: #666666">=</span> approximate(
                    f, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                    numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (d<span style="color: #666666">+1</span>),
                    d<span style="color: #666666">=</span>d, N_e<span style="color: #666666">=</span>N_e, Omega<span style="color: #666666">=</span>Omega,
                    filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_d</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_e</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (case, d, N_e))
            <span style="color: #008000; font-weight: bold">except</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>LinAlgError <span style="color: #008000; font-weight: bold">as</span> e:
                <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #008000">str</span>(e))
                <span style="color: #008000; font-weight: bold">continue</span>
            vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(
                N_e, d, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
            xc, u, _ <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map, <span style="color: #666666">51</span>)
            e <span style="color: #666666">=</span> f_func(xc) <span style="color: #666666">-</span> u
            <span style="color: #408080; font-style: italic"># Trapezoidal integration of the L2 error over the</span>
            <span style="color: #408080; font-style: italic"># xc/u patches</span>
            e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
            L2_error <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(xc)<span style="color: #666666">-1</span>):
                L2_error <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(e2[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> e2[i])<span style="color: #666666">*</span>(xc[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> xc[i])
            L2_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(L2_error)
            h <span style="color: #666666">=</span> (Omega[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega[<span style="color: #666666">0</span>])<span style="color: #666666">/</span><span style="color: #008000">float</span>(N_e)
            results[case][d][<span style="color: #BA2121">&#39;E&#39;</span>]<span style="color: #666666">.</span>append(L2_error)
            results[case][d][<span style="color: #BA2121">&#39;h&#39;</span>]<span style="color: #666666">.</span>append(h)
        <span style="color: #408080; font-style: italic"># Compute rates</span>
        h <span style="color: #666666">=</span> results[case][d][<span style="color: #BA2121">&#39;h&#39;</span>]
        E <span style="color: #666666">=</span> results[case][d][<span style="color: #BA2121">&#39;E&#39;</span>]
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(h)<span style="color: #666666">-1</span>):
            r <span style="color: #666666">=</span> log(E[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>E[i])<span style="color: #666666">/</span>log(h[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>h[i])
            results[case][d][<span style="color: #BA2121">&#39;r&#39;</span>]<span style="color: #666666">.</span>append(<span style="color: #008000">round</span>(r, <span style="color: #666666">2</span>))

<span style="color: #008000; font-weight: bold">print</span>(results)
<span style="color: #008000; font-weight: bold">for</span> case <span style="color: #AA22FF; font-weight: bold">in</span> results:
    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(results[case]):
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;case=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> d=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, r: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
              (case, d, results[case][d][<span style="color: #BA2121">&#39;r&#39;</span>]))
</pre></div>
<p>
The output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>case=sqrt d=1, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=sqrt d=2, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=sqrt d=3, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=sqrt d=4, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=exp d=1, r: [2.01, 2.01, 2.0, 2.0, 2.0]
case=exp d=2, r: [2.81, 2.89, 2.94, 2.97, 2.98]
case=exp d=3, r: [3.98, 4.0, 4.0, 4.0, 4.0]
case=exp d=4, r: [4.87, 4.93, 4.96, 4.98, 4.99]
case=sin d=1, r: [2.15, 2.06, 2.02, 2.0, 2.0]
case=sin d=2, r: [2.68, 2.83, 2.93, 2.97, 2.99]
case=sin d=3, r: [4.06, 4.04, 4.01, 4.0, 4.0]
case=sin d=4, r: [4.79, 4.9, 4.96, 4.98, 4.99]
</pre></div>
<p>
showing that the convergence rate stabilizes quite quickly at \( N_e=128 \)
cells. While the theory predicts the rate as \( d+1 \), this is only
fulfilled for the exponential and sine functions, while the square root
functions gives a rate 1 regardless of \( d \). The reason is that the
estimate <a href="._fem-book-sol013.html#mjx-eqn-3.42">(3.42)</a> contains the integral of
the derivatives of \( f \) over \( [0,1] \). For \( f=\sqrt{x} \), we
have \( f'=\half x^{-1/2} \), \( f''=-\frac{1}{4}x^{-3/2} \), and all integrals
of \( f'' \) and higher derivatives are infinite on \( [0,L] \). Our experiments
show that the method still converges, but \( f \) is not smooth enough that
higher-order elements give superior convergence rates.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>Pd_approx_error</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Heaviside" class="anchor">Problem 18: Approximate a step function by finite elements</h2>

<p>
Approximate the step function

$$
\begin{equation*} f(x) = \left\lbrace\begin{array}{ll}
0 & \mbox{ if } 0\leq x < \halfi,\\ 
1 & \mbox{ if } \halfi \leq x \geq \halfi
\end{array}\right.
\end{equation*}
$$

by 2, 4, 8, and 16 elements and  P1, P2, P3, and P4. Compare approximations visually.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_1">

<p>
This \( f \) can also be expressed in terms of the Heaviside function \( H(x) \):
\( f(x) = H(x-\halfi) \).
Therefore, \( f \) can be defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Heaviside(x <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>))
</pre></div>
<p>
making the <code>approximate</code> function in the
<code>fe_approx1D.py</code> module an obvious candidate to solve the
problem. However, <code>sympy</code> does not handle symbolic integration
with this particular integrand, and the <code>approximate</code> function faces a problem
when converting <code>f</code> to a Python function (for plotting) since
<code>Heaviside</code> is not an available function in <code>numpy</code>.

<p>
An alternative is to perform hand calculations. This is an instructive
task, but in practice only feasible for few elements and P1 and P2 elements.
It is better to copy the functions <code>element_matrix</code>, <code>element_vector</code>,
<code>assemble</code>, and <code>approximate</code> from the <code>fe_approx1D_numint.py</code> file
and edit these functions such that they can compute approximations
with <code>f</code> given as a Python function and not a symbolic expression.
Also assume that <code>phi</code> computed by the <code>basis</code> function is a Python
callable function. Remove all instances of the <code>symbolic</code> variable
and associated code.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_2">

<p>
The modifications of <code>element_matrix</code>, <code>element_vector</code>,
<code>assemble</code>, and <code>approximate</code> from the <code>fe_approx1D_numint.py</code> file
are listed below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> mesh_uniform, u_glob
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #008000; font-weight: bold">import</span> basis
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_matrix</span>(phi, Omega_e, numint):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    A_e <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((n, n))
    h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #408080; font-style: italic"># dx/dX</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(r, n):
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(numint[<span style="color: #666666">0</span>])):
                Xj, wj <span style="color: #666666">=</span> numint[<span style="color: #666666">0</span>][j], numint[<span style="color: #666666">1</span>][j]
                A_e[r,s] <span style="color: #666666">+=</span> phi[r](Xj)<span style="color: #666666">*</span>phi[s](Xj)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>wj
            A_e[s,r] <span style="color: #666666">=</span> A_e[r,s]
    <span style="color: #008000; font-weight: bold">return</span> A_e

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_vector</span>(f, phi, Omega_e, numint):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    b_e <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n)
    h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(numint[<span style="color: #666666">0</span>])):
            Xj, wj <span style="color: #666666">=</span> numint[<span style="color: #666666">0</span>][j], numint[<span style="color: #666666">1</span>][j]
            xj <span style="color: #666666">=</span> (Omega_e[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> Omega_e[<span style="color: #666666">1</span>])<span style="color: #666666">/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>Xj  <span style="color: #408080; font-style: italic"># mapping</span>
            b_e[r] <span style="color: #666666">+=</span> f(xj)<span style="color: #666666">*</span>phi[r](Xj)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>wj
    <span style="color: #008000; font-weight: bold">return</span> b_e


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">assemble</span>(vertices, cells, dof_map, phi, f, numint):
    N_n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(<span style="color: #008000">list</span>(<span style="color: #008000">set</span>(np<span style="color: #666666">.</span>array(dof_map)<span style="color: #666666">.</span>ravel())))
    N_e <span style="color: #666666">=</span> <span style="color: #008000">len</span>(cells)
    A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N_n, N_n))
    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N_n)
    <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e):
        Omega_e <span style="color: #666666">=</span> [vertices[cells[e][<span style="color: #666666">0</span>]], vertices[cells[e][<span style="color: #666666">1</span>]]]
        A_e <span style="color: #666666">=</span> element_matrix(phi[e], Omega_e, numint)
        b_e <span style="color: #666666">=</span> element_vector(f, phi[e], Omega_e, numint)
        <span style="color: #408080; font-style: italic">#print(&#39;element&#39;, e)</span>
        <span style="color: #408080; font-style: italic">#print(b_e)</span>
        <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(dof_map[e])):
            <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(dof_map[e])):
                A[dof_map[e][r],dof_map[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
            b[dof_map[e][r]] <span style="color: #666666">+=</span> b_e[r]
    <span style="color: #008000; font-weight: bold">return</span> A, b

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">approximate</span>(f, d, N_e, numint, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute the finite element approximation, using Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of degree d, to a Python functionn f on a domain</span>
<span style="color: #BA2121; font-style: italic">    Omega. N_e is the number of elements.</span>
<span style="color: #BA2121; font-style: italic">    numint is the name of the numerical integration rule</span>
<span style="color: #BA2121; font-style: italic">    (Trapezoidal, Simpson, GaussLegendre2, GaussLegendre3,</span>
<span style="color: #BA2121; font-style: italic">    GaussLegendre4, etc.). numint=None implies exact</span>
<span style="color: #BA2121; font-style: italic">    integration.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt
    numint_name <span style="color: #666666">=</span> numint  <span style="color: #408080; font-style: italic"># save name</span>
    <span style="color: #008000; font-weight: bold">if</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Trapezoidal&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">1</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Simpson&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1./3</span>, <span style="color: #666666">4./3</span>, <span style="color: #666666">1./3</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Midpoint&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-1/</span>sqrt(<span style="color: #666666">3</span>), <span style="color: #666666">1/</span>sqrt(<span style="color: #666666">3</span>)], [<span style="color: #666666">1</span>, <span style="color: #666666">1</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-</span>sqrt(<span style="color: #666666">3./5</span>), <span style="color: #666666">0</span>, sqrt(<span style="color: #666666">3./5</span>)],
                  [<span style="color: #666666">5./9</span>, <span style="color: #666666">8./9</span>, <span style="color: #666666">5./9</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-0.86113631</span>, <span style="color: #666666">-0.33998104</span>,  <span style="color: #666666">0.33998104</span>,
                   <span style="color: #666666">0.86113631</span>],
                  [ <span style="color: #666666">0.34785485</span>,  <span style="color: #666666">0.65214515</span>,  <span style="color: #666666">0.65214515</span>,
                    <span style="color: #666666">0.34785485</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-0.90617985</span>, <span style="color: #666666">-0.53846931</span>, <span style="color: #666666">-0.</span>        ,
                   <span style="color: #666666">0.53846931</span>,  <span style="color: #666666">0.90617985</span>],
                  [ <span style="color: #666666">0.23692689</span>,  <span style="color: #666666">0.47862867</span>,  <span style="color: #666666">0.56888889</span>,
                    <span style="color: #666666">0.47862867</span>,  <span style="color: #666666">0.23692689</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;Numerical rule </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is not supported &#39;</span>\ 
              <span style="color: #BA2121">&#39;for numerical computing&#39;</span> <span style="color: #666666">%</span> numint)
        sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)


    vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(N_e, d, Omega)

    <span style="color: #408080; font-style: italic"># phi is a list where phi[e] holds the basis in cell no e</span>
    <span style="color: #408080; font-style: italic"># (this is required by assemble, which can work with</span>
    <span style="color: #408080; font-style: italic"># meshes with different types of elements).</span>
    <span style="color: #408080; font-style: italic"># len(dof_map[e]) is the number of nodes in cell e,</span>
    <span style="color: #408080; font-style: italic"># and the degree of the polynomial is len(dof_map[e])-1</span>
    phi <span style="color: #666666">=</span> [basis(<span style="color: #008000">len</span>(dof_map[e])<span style="color: #666666">-1</span>) <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]

    A, b <span style="color: #666666">=</span> assemble(vertices, cells, dof_map, phi, f,
                    numint<span style="color: #666666">=</span>numint)

    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;cells:&#39;</span>, cells)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;vertices:&#39;</span>, vertices)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;dof_map:&#39;</span>, dof_map)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b)
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;c:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, c)

    <span style="color: #008000; font-weight: bold">if</span> filename <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        title <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, N_e=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (d, N_e)
        title <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;, integration: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> numint_name
        x_u, u, _ <span style="color: #666666">=</span> u_glob(np<span style="color: #666666">.</span>asarray(c), vertices, cells, dof_map,
                           resolution_per_element<span style="color: #666666">=51</span>)
        x_f <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], <span style="color: #666666">10001</span>) <span style="color: #408080; font-style: italic"># mesh for f</span>
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
        plt<span style="color: #666666">.</span>plot(x_u, u, <span style="color: #BA2121">&#39;-&#39;</span>,
                 x_f, f(x_f), <span style="color: #BA2121">&#39;--&#39;</span>)
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;f&#39;</span>])
        plt<span style="color: #666666">.</span>title(title)
        plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.pdf&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.png&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> c
</pre></div>
<p>
With a purely numerical version of the <code>approximate</code> function, we can
easily investigate the suggested approximations in this exercise:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exercise</span>():
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #008000">isinstance</span>(x, np<span style="color: #666666">.</span>ndarray):
            <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>where(x <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>)

    N_e_values <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">16</span>]
    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>:
        <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> N_e_values:
            approximate(f, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (d<span style="color: #666666">+1</span>),
                        d<span style="color: #666666">=</span>d, N_e<span style="color: #666666">=</span>N_e,
                        filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_Heaviside_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">e&#39;</span> <span style="color: #666666">%</span> (d, N_e))
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;pdf&#39;</span>, <span style="color: #BA2121">&#39;png&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images &#39;</span>
            cmd <span style="color: #666666">+=</span> ext <span style="color: #666666">+</span> <span style="color: #BA2121">&#39; -2 &#39;</span>
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39;fe_Heaviside_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">e&#39;</span> <span style="color: #666666">%</span> (d, N_e)
                             <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> N_e_values])
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; fe_Heaviside_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> d
            <span style="color: #008000; font-weight: bold">print</span>(cmd)
            os<span style="color: #666666">.</span>system(cmd)
</pre></div>
<p>
Running this function reveals that even finite elements
(and not only sines, as demonstrated in <a href="._fem-book-sol009.html#fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</a>)
give oscillations around a discontinuity.

<p>
<br /><br /><center><p><img src="fig/fe_Heaviside_P1.png" align="bottom" width=800></p></center><br /><br />

<p>
<br /><br /><center><p><img src="fig/fe_Heaviside_P2.png" align="bottom" width=800></p></center><br /><br />

<p>
<br /><br /><center><p><img src="fig/fe_Heaviside_P3.png" align="bottom" width=800></p></center><br /><br />

<p>
<br /><br /><center><p><img src="fig/fe_Heaviside_P4.png" align="bottom" width=800></p></center><br /><br />

<p>
<b>Remarks.</b>
It is of extreme importance to use a Gauss-Legendre numerical integration
rule that matches the degree of polynomials in the basis.
Using a rule with fewer points may lead to very strange results.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_Heaviside_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:2Dsines:symbolic" class="anchor">Exercise 19: 2D approximation with orthogonal functions</h2>

<p>
<b>a)</b>
Assume we have basis functions \( \basphi_i(x,y) \) in 2D that are
orthogonal such that \( (\basphi_i,\basphi_j)=0 \) when \( i\neq j \).  The
function <code>least_squares</code> in the file <a href="http://tinyurl.com/znpudbt/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a> will then spend much time on computing
off-diagonal terms in the coefficient matrix that we know are zero.
To speed up the computations, make a version <code>least_squares_orth</code> that
utilizes the orthogonality among the basis functions.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_2">

<p>
We 1) remove the <code>j</code> loop in the <code>least_squares</code> function and set
<code>j = i</code>,
2) make <code>A</code> a vector (i.e., \( (N+1, 1) \) matrix as <code>b</code> and <code>c</code>),
3) solve for <code>c[i,0]</code> as soon as <code>A[i,0]</code> and <code>b[i,0]</code> are computed.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">mpmath</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_orth</span>(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>,
                       print_latex<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Given a function f(x,y) on a rectangular domain</span>
<span style="color: #BA2121; font-style: italic">    Omega=[[xmin,xmax],[ymin,ymax]],</span>
<span style="color: #BA2121; font-style: italic">    return the best approximation to f(x,y) in the space V</span>
<span style="color: #BA2121; font-style: italic">    spanned by the functions in the list psi.</span>
<span style="color: #BA2121; font-style: italic">    This function assumes that psi are orthogonal on Omega.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Modification of least_squares function: drop the j loop,</span>
    <span style="color: #408080; font-style: italic"># set j=i, compute c on the fly in the i loop.</span>

    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    <span style="color: #408080; font-style: italic"># Note that A, b, c becmes (N+1)x(N+1), use 1st column</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;...evaluating matrix...&#39;</span>, A<span style="color: #666666">.</span>shape, b<span style="color: #666666">.</span>shape, c<span style="color: #666666">.</span>shape)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        j <span style="color: #666666">=</span> i
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> (i, j))

        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>psi[j]
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,
                             (x, Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]),
                             (y, Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            <span style="color: #408080; font-style: italic"># Could not integrate symbolically, use numerical int.</span>
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;numerical integration of&#39;</span>, integrand)
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x,y], integrand, <span style="color: #BA2121">&#39;mpmath&#39;</span>)
            I <span style="color: #666666">=</span> mpmath<span style="color: #666666">.</span>quad(integrand,
                            [Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                            [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]])
        A[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I

        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,
                             (x, Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]),
                             (y, Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            <span style="color: #408080; font-style: italic"># Could not integrate symbolically, use numerical int.</span>
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;numerical integration of&#39;</span>, integrand)
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x,y], integrand, <span style="color: #BA2121">&#39;mpmath&#39;</span>)
            I <span style="color: #666666">=</span> mpmath<span style="color: #666666">.</span>quad(integrand,
                            [Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                            [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
        c[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[i,<span style="color: #666666">0</span>]<span style="color: #666666">/</span>A[i,<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">print</span>()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A, <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b)
    c <span style="color: #666666">=</span> [c[i,<span style="color: #666666">0</span>] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(c<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])]  <span style="color: #408080; font-style: italic"># make list</span>
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;coeff:&#39;</span>, c)

    <span style="color: #408080; font-style: italic"># c is a sympy Matrix object, numbers are in c[i,0]</span>
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;approximation:&#39;</span>, u)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;f:&#39;</span>, sym<span style="color: #666666">.</span>expand(f))
    <span style="color: #008000; font-weight: bold">if</span> print_latex:
        <span style="color: #008000; font-weight: bold">print</span>(sym<span style="color: #666666">.</span>latex(A, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>))
        <span style="color: #008000; font-weight: bold">print</span>(sym<span style="color: #666666">.</span>latex(b, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>))
        <span style="color: #008000; font-weight: bold">print</span>(sym<span style="color: #666666">.</span>latex(c, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Apply the function to approximate

$$ f(x,y) = x(1-x)y(1-y)e^{-x-y}$$

on \( \Omega = [0,1]\times [0,1] \) via basis functions

$$ \basphi_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,
$$

where \( p=0,\ldots,N_x \) and \( q=0,\ldots,N_y \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_1">

<p>
Get ideas from the function <code>least_squares_orth</code> in
the section <a href="._fem-book-sol006.html#fem:approx:global:orth">Orthogonal basis functions</a> and
file <a href="http://tinyurl.com/znpudbt/fe_approx1D.py" target="_self"><tt>approx1D.py</tt></a>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_3">

<p>
A function for computing the basis functions may look like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_basis</span>(Nx, Ny):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute basis sin((p+1)*pi*x)*sin((q+1)*pi*y),</span>
<span style="color: #BA2121; font-style: italic">    p=0,...,Nx, q=0,...,Ny.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    psi <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> q <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
            r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin((p<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin((q<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>y)
            psi<span style="color: #666666">.</span>append(r)
    <span style="color: #008000; font-weight: bold">return</span> psi
</pre></div>
<p>
Application of this basis to approximate the given function is coded in
the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo</span>(N):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Find the approximation of f by the least squares method.</span>
<span style="color: #BA2121; font-style: italic">    The basis is sin((p+1)*pi*x)sin((q+1)*pi*y) where</span>
<span style="color: #BA2121; font-style: italic">    0&lt;p&lt;=N, p&lt;q&lt;=N.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">*</span>y<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>y)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x<span style="color: #666666">-</span>y)

    psi <span style="color: #666666">=</span> sine_basis(N, N)

    Omega <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]]
    u, c  <span style="color: #666666">=</span> least_squares_orth(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx2D</span> <span style="color: #008000; font-weight: bold">import</span> comparison_plot
    comparison_plot(f, u, Omega, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> N)
    <span style="color: #008000; font-weight: bold">print</span>(c)

<span style="color: #008000; font-weight: bold">if</span> <span style="color: #19177C">__name__</span><span style="color: #666666">==</span><span style="color: #BA2121">&#39;__main__&#39;</span>:
    <span style="color: #408080; font-style: italic">#test_least_squares_orth()</span>
    demo(N<span style="color: #666666">=2</span>)
</pre></div>
<p>
A lesson learned is that <code>symbolic=False</code> is important, otherwise <code>sympy</code>
consumes a lot of CPU time on trying to integrate symbolically.

<p>
The figure below shows the error in the approximation for \( N=0 \) (left)
and \( N=2 \) (right). The coefficients for \( N=2 \) decay rapidly:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>[0.025, 0.0047, 0.0014, 0.0047, 0.0009, 0.0003, 0.0014, 0.0003,
 8.2e-5]
</pre></div>
<p>
<br /><br /><center><p><img src="fig/approx2D_ls_orth_sine_c.png" align="bottom" width=800></p></center><br /><br />

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Make a unit test for the <code>least_squares_orth</code> function.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_4">

<p>
Let us use the basis in b), fix the coefficients of some function
\( f \), and check that the computed approximation, with the
same basis, has the same coefficients (this test employs the principle
that if \( f\in V \), then \( u=f \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_least_squares_orth</span>():
    <span style="color: #408080; font-style: italic"># Use sine functions</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    N <span style="color: #666666">=</span> <span style="color: #666666">2</span>  <span style="color: #408080; font-style: italic"># (N+1)**2 = 9 basis functions</span>
    psi <span style="color: #666666">=</span> sine_basis(N, N)
    f_coeff <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span><span style="color: #008000">len</span>(psi)
    f_coeff[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    f_coeff[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    f <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(f_coeff[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #408080; font-style: italic"># Check that u exactly reproduces f</span>
    u, c <span style="color: #666666">=</span> least_squares_orth(f, psi, Omega<span style="color: #666666">=</span>[[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]],
                              symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(np<span style="color: #666666">.</span>array(c) <span style="color: #666666">-</span> np<span style="color: #666666">.</span>array(f_coeff))<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;diff:&#39;</span>, diff)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>approx2D_ls_orth</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:trapez" class="anchor">Exercise 20: Use the Trapezoidal rule and P1 elements</h2>

<p>
Consider approximation of some \( f(x) \) on an interval \( \Omega \) using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a href="._fem-book-sol014.html#mjx-eqn-3.50">(3.50)</a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form \( c_i=f(\xno{i}) \) for \( i\in\If \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_20_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_20_1">

<p>
The Trapezoidal rule for integrals on \( [-1,1] \)
is given by <a href="._fem-book-sol014.html#mjx-eqn-3.50">(3.50)</a>.
The expressions for the entries in the element matrix
are given by <a href="._fem-book-sol010.html#mjx-eqn-3.15">(3.15)</a> in
the section <a href="._fem-book-sol010.html#fem:approx:fe:mapping">Mapping to a reference element</a>:

$$
\begin{align*} \tilde A^{(e)}_{r,s} &=
\int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,\dX\\ 
&\approx \frac{h}{2}(\refphi_r(-1)\refphi_s(-1)
+ \refphi_r(1)\refphi_s(1))\tp
\end{align*}
$$

We know that if \( \refphi_r(\pm 1) \) is 0 or 1, so evaluating
the formula above for \( r,s=0,1 \) gives

$$ \tilde A^{(e)} = \frac{h}{2}\left(\begin{array}{cc}
1 & 0\\ 
0 & 1
\end{array}\right)\tp$$

As usual, \( h \) is the length of the element in physical coordinates.

<p>
The element vector in the reference element is given by
<a href="._fem-book-sol010.html#mjx-eqn-3.16">(3.16)</a>:

$$
\begin{align*}
\tilde b^{(e)}_{r} &=  \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,\dX\\ 
&\approx \frac{h}{2}(f(x(-1))\refphi_r(-1)
+ f(x(1))\refphi_r(1))\tp
\end{align*}
$$

Evaluating the formula for \( r=0,1 \) leads to

$$ \tilde b^{(e)} = \frac{h}{2}\left(\begin{array}{c}
f(x_L)\\ 
f(x_R)
\end{array}\right),$$

where \( x_L \) and \( x_R \) are the \( x \) coordinates of the local points
\( X=-1 \) and \( X=1 \), respectively.

<p>
With a uniform mesh with nodes \( \xno{i}=ih \), the element matrix and
vectors assemble to a coefficient matrix

$$ \frac{h}{2}\hbox{diag}(1, 2, \ldots, 2, 1),$$

and right-hand side vector

$$ \frac{h}{2}(f(\xno{0}), 2f(\xno{1}), \ldots, 2f(\xno{N_n-1}),
f(\xno{N_n}))\tp$$

The factors \( h/2 \) and \( 2 \) cancel, so we are left with the solution of
the system as

$$ c_i = f(\xno{i})\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_P1_trapez</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:P1:vs:interp" class="anchor">Exercise 21: Compare P1 elements and interpolation</h2>

<p>
We shall approximate the function

$$ f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],$$

where \( n\in\Integer \) and \( \epsilon \geq 0 \).

<p>
<b>a)</b>
Plot \( f(x) \) for \( n=1,2,3 \) and find the wave length of the function.

<p>
<b>b)</b>
We want to use \( N_P \) elements per wave length. Show that the number
of elements is then \( nN_P \).

<p>
<b>c)</b>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an \( f \) with just one wave length in \( \Omega = [0,1] \).
Set \( \epsilon = 0.5 \).

<p>
Run the least squares or projection/Galerkin method for
\( N_P=2,4,8,16,32 \). Compute the error \( E=||u-f||_{L^2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_21_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_21_1">

<p>
Use the <code>fe_approx1D_numint</code> module to compute \( u \) and use
the technique from the section <a href="._fem-book-sol013.html#fem:approx:fe:error">Computing the error of the approximation</a> to
compute the norm of the error.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_21_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_21_2">

<p>
Read up on the Nyquist&#8211;Shannon sampling theorem.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute \( u(x) \) (recall that \( c_i \) is now simply \( f(\xno{i}) \)).
Compute the error \( E=||u-f||_{L^2} \).
Which method seems to be most accurate?

<p>
Filename: <code>fe_P1_vs_interp</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:3D:approx3D" class="anchor">Exercise 22: Implement 3D computations with global basis functions</h2>

<p>
Extend the <a href="http://tinyurl.com/znpudbt/approx2D.py" target="_self"><tt>approx2D.py</tt></a> code to 3D
applying ideas from the section <a href="._fem-book-sol008.html#fem:approx:3D:global">Extension to 3D</a>.
Construct some 3D problem to make a test function for the
implementation.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_22_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_22_1">

<p>
Drop symbolic integration since it is in general too slow for 3D problems.
Also use <code>scipy.integrate.nquad</code> instead of <code>mpmath.quad</code>
for numerical integration, since it is much faster.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_22_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_22_2">

<p>
We take a copy of <code>approx2D.py</code> and drop the <code>comparison_plot</code> function since
plotting in 3D is much more complicated (could make a special version with
curves through lines in the 3D domain, for instance).
Furthermore, we remove the lines with symbolic integration and replace
the calls to <code>mpmath.quad</code> by calls to
<code>scipy.integrate.nquad</code>. The resulting function becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.integrate</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Given a function f(x,y,z) on a rectangular domain</span>
<span style="color: #BA2121; font-style: italic">    Omega=[[xmin,xmax],[ymin,ymax],[zmin,zmax]],</span>
<span style="color: #BA2121; font-style: italic">    return the best approximation to f in the space V</span>
<span style="color: #BA2121; font-style: italic">    spanned by the functions in the list psi.</span>
<span style="color: #BA2121; font-style: italic">    f and psi are symbolic (sympy) expressions, but will</span>
<span style="color: #BA2121; font-style: italic">    be converted to numeric functions for faster integration.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    x, y, z <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y, z], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    psi_sym <span style="color: #666666">=</span> psi[:]  <span style="color: #408080; font-style: italic"># take a copy, needed for forming u later</span>
    psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>lambdify([x, y, z], psi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi))]

    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;...evaluating matrix...&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> (i, j))

            integrand <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y, z: psi[i](x,y,z)<span style="color: #666666">*</span>psi[j](x,y,z)
            I, err <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>nquad(
                integrand,
                [[Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                 [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]],
                 [Omega[<span style="color: #666666">2</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">2</span>][<span style="color: #666666">1</span>]]])
            A[i,j] <span style="color: #666666">=</span> A[j,i] <span style="color: #666666">=</span> I
        integrand <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y, z: psi[i](x,y,z)<span style="color: #666666">*</span>f(x,y,z)
        I, err <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>nquad(
            integrand,
            [[Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
             [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]],
             [Omega[<span style="color: #666666">2</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">2</span>][<span style="color: #666666">1</span>]]])
        b[i] <span style="color: #666666">=</span> I
    <span style="color: #008000; font-weight: bold">print</span>()
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)
    <span style="color: #008000; font-weight: bold">if</span> N <span style="color: #666666">&lt;=</span> <span style="color: #666666">10</span>:
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A, <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b)
        <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;coeff:&#39;</span>, c)
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi_sym[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi_sym)))
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;approximation:&#39;</span>, u)
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
As test example, we can use the basis

$$ \baspsi_{p,q,r} = \sin((p+1)\pi x)\sin((q+1)\pi y)\sin((r+1)\pi z),$$

for \( p=1,\ldots,N_x \), \( q=1,\ldots,N_y \), \( r=1,\ldots,N_z \).
We choose \( f \) as some prescribed combination of these functions and
check that the computed \( u \) is exactly equal to \( f \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_basis</span>(Nx, Ny, Nz):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute basis sin((p+1)*pi*x)*sin((q+1)*pi*y)*sin((r+1)*pi*z),</span>
<span style="color: #BA2121; font-style: italic">    p=0,...,Nx, q=0,...,Ny, r=0,...,Nz.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x, y, z <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    psi <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nz<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> q <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>):
            <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
                s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin((p<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>\ 
                    sym<span style="color: #666666">.</span>sin((q<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>y)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin((r<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>z)
                psi<span style="color: #666666">.</span>append(s)
    <span style="color: #008000; font-weight: bold">return</span> psi

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_least_squares</span>():
    <span style="color: #408080; font-style: italic"># Use sine functions</span>
    x, y, z <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    N <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># (N+1)**3 = 8 basis functions</span>
    psi <span style="color: #666666">=</span> sine_basis(N, N, N)
    f_coeff <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span><span style="color: #008000">len</span>(psi)
    f_coeff[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    f_coeff[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    f <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(f_coeff[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #408080; font-style: italic"># Check that u exactly reproduces f</span>
    u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega<span style="color: #666666">=</span>[[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]])
    diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(np<span style="color: #666666">.</span>array(c) <span style="color: #666666">-</span> np<span style="color: #666666">.</span>array(f_coeff))<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;diff:&#39;</span>, diff)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>approx3D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:simpson" class="anchor">Exercise 23: Use Simpson's rule and P2 elements</h2>

<p>
Redo <a href="#fem:approx:fe:exer:1D:trapez">Exercise 20: Use the Trapezoidal rule and P1 elements</a>, but use P2
elements and Simpson's rule based on sampling the integrands at
the nodes in the reference cell.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_23_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_23_1">

<p>
Simpson's rule for integrals on \( [-1,1] \)
is given by <a href="._fem-book-sol014.html#mjx-eqn-3.51">(3.51)</a>.
The expressions for the entries in the element matrix
are given by <a href="._fem-book-sol010.html#mjx-eqn-3.15">(3.15)</a>:

$$
\begin{align*} \tilde A^{(e)}_{r,s} &=
\int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,\dX\\ 
&\approx \frac{1}{3}\frac{h}{2}(\refphi_r(-1)\refphi_s(-1)
+ 4\refphi_r(0)\refphi_s(0)
+ \refphi_r(1)\refphi_s(1))\tp
\end{align*}
$$

The expressions for \( \refphi_r(X) \) are given by
<a href="._fem-book-sol010.html#mjx-eqn-3.17">(3.17)</a>-<a href="._fem-book-sol010.html#mjx-eqn-3.18">(3.18)</a>.
Evaluating the formula for \( r,s=0,1,2 \) gives the element matrix

$$ \tilde A^{(e)} = \frac{h}{6}\left(\begin{array}{ccc}
1 & 0 & 0\\ 
0 & 4 & 0\\ 
0 & 0 & 1
\end{array}\right)\tp$$

As usual, \( h \) is the length of the element in physical coordinates.

<p>
The element vector in the reference element is given by
<a href="._fem-book-sol010.html#mjx-eqn-3.16">(3.16)</a>:

$$
\begin{align*}
\tilde b^{(e)}_{r} &=  \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,\dX\\ 
&\approx \frac{1}{3}\frac{h}{2}(f(x(-1))\refphi_r(-1)
+ 4f(x(0))\refphi_r(0)
+ f(x(1))\refphi_r(1))\tp
\end{align*}
$$

Evaluating the formula for \( r=0,1,2 \) leads to

$$ \tilde b^{(e)} = \frac{h}{2}\left(\begin{array}{c}
f(x_L)\\ 
4f(x_c)
f(x_R)
\end{array}\right),$$

where \( x_L \), \( x_c \), and \( x_R \) are the \( x \) coordinates of the local points
\( X=-1 \), \( X=0 \), and \( X=1 \), respectively. These correspond to the nodes
in the element.

<p>
With a uniform mesh with nodes \( \xno{i}=ih \), the element matrix and
vectors assemble to a coefficient matrix

$$ \frac{h}{6}\hbox{diag}(1, 4, 2, 4, 2, 4, \ldots, 2, 4, 1),$$

and right-hand side vector

$$ \frac{h}{6}(f(\xno{0}), 4f(\xno{1}), 2f(\xno{2}),
4f(\xno{3}), 2f(\xno{4}), \ldots, 2f(\xno{N_n-2}),
4f(\xno{N_n-1}), f(\xno{N_n}))\tp$$

The factors \( h/6 \), \( 2 \) and \( 4 \) all cancel, so we are left with the solution of
the system as

$$ c_i = f(\xno{i})\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_P2_simpson</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec138" class="anchor">Exercise 24: Make a 3D code for Lagrange elements of arbitrary order </h2>

<p>
Extend the code from the section <a href="#fem:approx:fenics:2D:2">Refined code with curve plotting</a> to 3D.

<p>
<!-- 2DO -->
<!-- Must illustrate how to make weak form of continuous problem and -->
<!-- discretize. Do that in time-dependent problems too. -->

<p>
<!-- Maybe <,> \langle, \rangle as inner product -->

<p>
<!-- Must say something about error estimates! -->

<p>
<!-- no (au')', have (\alpha u')' - it solves all the problems with a and a(.,.) -->
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">

  <li class="previous">
    <a href="._fem-book-sol014.html">&larr; Prev</a>
  </li>

  <li class="next">
    <a href="._fem-book-sol016.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

