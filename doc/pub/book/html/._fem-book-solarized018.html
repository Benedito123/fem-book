<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to Numerical Methods for Variational Problems">
<meta name="keywords" content="trial function,test function,approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,normal equations,$A^TA=A^Tb$ (normal equations),approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,Bernstein(interpolating) polynomial,tensor product,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,FEniCS,residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,convection-diffusion,convection-diffusion,Petrov-Galerkin methods,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,group finite element method,product approximation technique,polynomial chaos,Chaospy software,intrusive polynomial chaos,non-intrusive polynomial chaos,Krylov space,linear solvers GMRES,linear solvers GCR,linear solvers minimum residuals,linear solvers generalized conjugate residuals,search (direction) vectors,linear solvers conjugate gradients,linear systems preconditioned,linear solvers preconditioning,preconditioning,preconditioning classical iterations,MILU,ILU,incomplete factorization">

<title>Introduction to Numerical Methods for Variational Problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              (u'Preface', 0, u'ch:preface', u'ch:preface'),
              (u'Contents', 3, None, '___sec1'),
              (u'Supplementary materials', 3, None, '___sec2'),
              (u'Quick overview of the finite element method',
               0,
               u'ch:overview',
               u'ch:overview'),
              (u'Function approximation by global functions',
               0,
               u'ch:approx:global',
               u'ch:approx:global'),
              (u'Approximation of vectors',
               1,
               u'fem:approx:vec',
               u'fem:approx:vec'),
              (u'Approximation of planar vectors',
               2,
               u'fem:approx:vec:plane',
               u'fem:approx:vec:plane'),
              (u'The least squares method', 3, None, '___sec7'),
              (u'The projection method', 3, None, '___sec8'),
              (u'Approximation of general vectors',
               2,
               u'fem:approx:vec:Np1dim',
               u'fem:approx:vec:Np1dim'),
              (u'The least squares method', 3, None, '___sec10'),
              (u'The Galerkin or projection method', 3, None, '___sec11'),
              (u'Approximation principles',
               1,
               u'fem:approx:global',
               u'fem:approx:global'),
              (u'The least squares method',
               2,
               u'fem:approx:LS',
               u'fem:approx:LS'),
              (u'The projection (or Galerkin) method', 2, None, '___sec14'),
              (u'Example on linear approximation',
               2,
               u'fem:approx:global:linear',
               u'fem:approx:global:linear'),
              (u'Implementation of the least squares method',
               2,
               u'fem:approx:global:LS:code',
               u'fem:approx:global:LS:code'),
              (u'Symbolic integration', 3, None, '___sec17'),
              (u'Fall back on numerical integration', 3, None, '___sec18'),
              (u'Plotting the approximation', 3, None, '___sec19'),
              (u'Perfect approximation',
               2,
               u'fem:approx:global:exact1',
               u'fem:approx:global:exact1'),
              (u'The regression method',
               2,
               u'fem:approx:global:regression',
               u'fem:approx:global:regression'),
              (u'Overdetermined equation system', 3, None, '___sec22'),
              (u'The normal equations derived from a least squares principle',
               3,
               None,
               '___sec23'),
              (u'Implementation', 3, None, '___sec24'),
              (u'Example', 3, None, '___sec25'),
              (u'Orthogonal basis functions', 1, None, '___sec26'),
              (u'Ill-conditioning',
               2,
               u'fem:approx:global:illconditioning',
               u'fem:approx:global:illconditioning'),
              (u'Fourier series',
               2,
               u'fem:approx:global:Fourier',
               u'fem:approx:global:Fourier'),
              (u'Orthogonal basis functions',
               2,
               u'fem:approx:global:orth',
               u'fem:approx:global:orth'),
              (u'Numerical computations', 2, None, '___sec30'),
              (u'Interpolation', 1, None, '___sec31'),
              (u'The interpolation (or collocation) principle',
               2,
               u'fem:approx:global:interp',
               u'fem:approx:global:interp'),
              (u'Example', 3, None, '___sec33'),
              (u'Lagrange polynomials',
               2,
               u'fem:approx:global:Lagrange',
               u'fem:approx:global:Lagrange'),
              (u'Approximation of a polynomial', 3, None, '___sec35'),
              (u'Successful example', 3, None, '___sec36'),
              (u'Less successful example', 3, None, '___sec37'),
              (u'Remedy for strong oscillations', 3, None, '___sec38'),
              (u'Bernstein polynomials',
               2,
               u'fem:approx:global:Bernstein',
               u'fem:approx:global:Bernstein'),
              (u'Approximation properties and convergence rates',
               1,
               None,
               '___sec40'),
              (u'Approximation of functions in higher dimensions',
               1,
               u'fem:approx:2D',
               u'fem:approx:2D'),
              (u'2D basis functions as tensor products of 1D functions',
               2,
               u'fem:approx:2D:global',
               u'fem:approx:2D:global'),
              (u'Example on polynomial basis in 2D', 2, None, '___sec43'),
              (u'Implementation',
               2,
               u'fem:approx:2D:global:code',
               u'fem:approx:2D:global:code'),
              (u'Extension to 3D',
               2,
               u'fem:approx:3D:global',
               u'fem:approx:3D:global'),
              (u'Exercises', 1, None, '___sec46'),
              (u'Problem 1: Linear algebra refresher',
               2,
               u'fem:approx:exer:linalg1',
               u'fem:approx:exer:linalg1'),
              (u'Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               u'fem:approx:exer:vec:3Dby2D',
               u'fem:approx:exer:vec:3Dby2D'),
              (u'Problem 3: Approximate a parabola by a sine',
               2,
               u'fem:approx:exer:parabola_sine',
               u'fem:approx:exer:parabola_sine'),
              (u'Problem 4: Approximate the exponential function by power functions',
               2,
               u'fem:approx:exer:exp:powers',
               u'fem:approx:exer:exp:powers'),
              (u'Problem 5: Approximate the sine function by power functions',
               2,
               u'fem:approx:exer:sin:powers',
               u'fem:approx:exer:sin:powers'),
              (u'Problem 6: Approximate a steep function by sines',
               2,
               u'fem:approx:exer:tanh:sine1',
               u'fem:approx:exer:tanh:sine1'),
              (u'Remarks', 3, None, '___sec53'),
              (u'Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               u'fem:approx:exer:tanh:sine3',
               u'fem:approx:exer:tanh:sine3'),
              (u'Remarks', 3, None, '___sec55'),
              (u'Exercise 8: Fourier series as a least squares approximation',
               2,
               u'fem:approx:exer:Fourier',
               u'fem:approx:exer:Fourier'),
              (u'Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               u'fem:approx:exer:tanh:Lagrange',
               u'fem:approx:exer:tanh:Lagrange'),
              (u'Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               u'fem:approx:exer:tanh:Lagrange:regression',
               u'fem:approx:exer:tanh:Lagrange:regression'),
              (u'Function approximation by finite elements',
               0,
               u'ch:approx:fe',
               u'ch:approx:fe'),
              (u'Finite element basis functions',
               1,
               u'fem:approx:fe',
               u'fem:approx:fe'),
              (u'Elements and nodes',
               2,
               u'fem:approx:fe:def:elements:nodes',
               u'fem:approx:fe:def:elements:nodes'),
              (u'Example', 3, None, '___sec62'),
              (u'The basis functions', 2, None, '___sec63'),
              (u'Construction principles', 3, None, '___sec64'),
              (u'Properties of $\\basphi_i$', 3, None, '___sec65'),
              (u'Example on quadratic finite element functions',
               2,
               None,
               '___sec66'),
              (u'Example on linear finite element functions',
               2,
               None,
               '___sec67'),
              (u'Example on cubic finite element functions',
               2,
               None,
               '___sec68'),
              (u'Calculating the linear system',
               2,
               u'fem:approx:global:linearsystem',
               u'fem:approx:global:linearsystem'),
              (u'Calculating specific matrix entries', 3, None, '___sec70'),
              (u'Calculating a general row in the matrix',
               3,
               None,
               '___sec71'),
              (u'Assembly of elementwise computations',
               2,
               u'fem:approx:fe:elementwise',
               u'fem:approx:fe:elementwise'),
              (u'The element matrix', 3, None, '___sec73'),
              (u'Assembly of element matrices', 3, None, '___sec74'),
              (u'Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec75'),
              (u'The element vector', 3, None, '___sec76'),
              (u'Mapping to a reference element',
               2,
               u'fem:approx:fe:mapping',
               u'fem:approx:fe:mapping'),
              (u'The coordinate transformation', 3, None, '___sec78'),
              (u'Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec79'),
              (u'Formulas for local basis functions', 3, None, '___sec80'),
              (u'Example on integration over a reference element',
               2,
               u'fem:approx:fe:intg:ref',
               u'fem:approx:fe:intg:ref'),
              (u'Implementation',
               1,
               u'fem:approx:fe:impl',
               u'fem:approx:fe:impl'),
              (u'Integration',
               2,
               u'fem:approx:fe:impl:intg',
               u'fem:approx:fe:impl:intg'),
              (u'Linear system assembly and solution',
               2,
               u'fem:approx:fe:impl:linsys',
               u'fem:approx:fe:impl:linsys'),
              (u'Example on computing symbolic approximations',
               2,
               u'fem:approx:fe:impl:ex1:symbolic',
               u'fem:approx:fe:impl:ex1:symbolic'),
              (u'Using interpolation instead of least squares',
               2,
               u'fem:approx:fe:impl:ex1:collocation',
               u'fem:approx:fe:impl:ex1:collocation'),
              (u'Example on computing numerical approximations',
               2,
               u'fem:approx:fe:impl:ex1:numeric',
               u'fem:approx:fe:impl:ex1:numeric'),
              (u'The structure of the coefficient matrix',
               2,
               u'fem:approx:fe:A:structure',
               u'fem:approx:fe:A:structure'),
              (u'Applications',
               2,
               u'fem:approx:fe:impl:ex2',
               u'fem:approx:fe:impl:ex2'),
              (u'Sparse matrix storage and solution',
               2,
               u'fem:approx:fe:impl:sparse',
               u'fem:approx:fe:impl:sparse'),
              (u'Comparison of finite elements and finite differences',
               1,
               u'fem:approx:fe:fd',
               u'fem:approx:fe:fd'),
              (u'Finite difference approximation of given functions',
               2,
               u'fem:approx:fe:fd:fdproj',
               u'fem:approx:fe:fd:fdproj'),
              (u'Interpretation of a finite element approximation in terms of finite difference operators',
               2,
               u'fem:approx:fe:fd:feproj',
               u'fem:approx:fe:fd:feproj'),
              (u'Making finite elements behave as finite differences',
               2,
               u'fem:deq:1D:approx:fem_vs_fdm',
               u'fem:deq:1D:approx:fem_vs_fdm'),
              (u'Computations in physical space', 3, None, '___sec95'),
              (u'Elementwise computations', 3, None, '___sec96'),
              (u'Terminology', 3, None, '___sec97'),
              (u'A generalized element concept',
               1,
               u'fem:approx:fe:element',
               u'fem:approx:fe:element'),
              (u'Cells, vertices, and degrees of freedom',
               2,
               u'fem:approx:fe:element:terminology',
               u'fem:approx:fe:element:terminology'),
              (u'Extended finite element concept',
               2,
               u'fem:approx:fe:element:def',
               u'fem:approx:fe:element:def'),
              (u'Implementation',
               2,
               u'fem:approx:fe:element:impl',
               u'fem:approx:fe:element:impl'),
              (u'Computing the error of the approximation',
               2,
               u'fem:approx:fe:error',
               u'fem:approx:fe:error'),
              (u'Example on cubic Hermite polynomials',
               2,
               u'fem:approx:fe:element:impl:Hermite',
               u'fem:approx:fe:element:impl:Hermite'),
              (u'Numerical integration', 1, None, '___sec104'),
              (u'Newton-Cotes rules',
               2,
               u'fem:approx:fe:numint1',
               u'fem:approx:fe:numint1'),
              (u'Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec106'),
              (u'Finite elements in 2D and 3D', 1, None, '___sec107'),
              (u'Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec108'),
              (u'Element matrices and vectors', 3, None, '___sec109'),
              (u'Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec110'),
              (u'Affine mapping of the reference cell', 2, None, '___sec111'),
              (u'Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec112'),
              (u'Computing integrals', 2, None, '___sec113'),
              (u'Implementation',
               1,
               u'fe:approx:fenics',
               u'fe:approx:fenics'),
              (u'Example on approximation in 2D using FEniCS',
               2,
               u'fem:approx:fenics:2D',
               u'fem:approx:fenics:2D'),
              (u'Mathematical problem', 3, None, '___sec116'),
              (u'The code', 3, None, '___sec117'),
              (u'Dissection of the code', 3, None, '___sec118'),
              (u'Integrating SymPy and FEniCS', 3, None, '___sec119'),
              (u'Refined code with curve plotting',
               2,
               u'fem:approx:fenics:2D:2',
               u'fem:approx:fenics:2D:2'),
              (u'Interpolation and projection', 3, None, '___sec121'),
              (u'Plotting the solution along a line', 3, None, '___sec122'),
              (u'Integrating plotting and computations',
               3,
               None,
               '___sec123'),
              (u'Exercises', 1, None, '___sec124'),
              (u'Problem 11: Define nodes and elements',
               2,
               u'fem:approx:fe:exer:mesh1',
               u'fem:approx:fe:exer:mesh1'),
              (u'Problem 12: Define vertices, cells, and dof maps',
               2,
               u'fem:approx:fe:exer:mesh2',
               u'fem:approx:fe:exer:mesh2'),
              (u'Problem 13: Construct matrix sparsity patterns',
               2,
               u'fem:approx:fe:exer:defmesh:sparsity',
               u'fem:approx:fe:exer:defmesh:sparsity'),
              (u'Problem 14: Perform symbolic finite element computations',
               2,
               u'fem:approx:fe:exer:Asinwt:symbolic',
               u'fem:approx:fe:exer:Asinwt:symbolic'),
              (u'Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               u'fem:approx:exer:tanh:P1P2',
               u'fem:approx:exer:tanh:P1P2'),
              (u'Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               u'fem:approx:exer:tanh:P3P4',
               u'fem:approx:exer:tanh:P3P4'),
              (u'Exercise 17: Investigate the approximation error in finite elements',
               2,
               u'fem:approx:fe:exer:Asinwt:interpol:error',
               u'fem:approx:fe:exer:Asinwt:interpol:error'),
              (u'Problem 18: Approximate a step function by finite elements',
               2,
               u'fem:approx:fe:exer:Heaviside',
               u'fem:approx:fe:exer:Heaviside'),
              (u'Exercise 19: 2D approximation with orthogonal functions',
               2,
               u'fem:approx:fe:exer:2Dsines:symbolic',
               u'fem:approx:fe:exer:2Dsines:symbolic'),
              (u'Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               u'fem:approx:fe:exer:1D:trapez',
               u'fem:approx:fe:exer:1D:trapez'),
              (u'Exercise 21: Compare P1 elements and interpolation',
               2,
               u'fem:approx:fe:exer:1D:P1:vs:interp',
               u'fem:approx:fe:exer:1D:P1:vs:interp'),
              (u'Exercise 22: Implement 3D computations with global basis functions',
               2,
               u'fem:approx:fe:exer:3D:approx3D',
               u'fem:approx:fe:exer:3D:approx3D'),
              (u"Exercise 23: Use Simpson's rule and P2 elements",
               2,
               u'fem:approx:fe:exer:1D:simpson',
               u'fem:approx:fe:exer:1D:simpson'),
              (u'Exercise 24: Make a 3D code for Lagrange elements of arbitrary order',
               2,
               None,
               '___sec138'),
              (u'Variational formulations with global basis functions',
               0,
               u'ch:varform:global',
               u'ch:varform:global'),
              (u'Basic principles for approximating differential equations',
               1,
               u'fem:deq:1D:principles',
               u'fem:deq:1D:principles'),
              (u'Differential equation models',
               2,
               u'fem:deq:1D:models',
               u'fem:deq:1D:models'),
              (u'Simple model problems and their solutions',
               2,
               u'fem:deq:1D:models:simple',
               u'fem:deq:1D:models:simple'),
              (u'Forming the residual',
               2,
               u'fem:deq:1D:residual:min',
               u'fem:deq:1D:residual:min'),
              (u'The least squares method', 2, None, '___sec144'),
              (u'The Galerkin method', 2, None, '___sec145'),
              (u'The method of weighted residuals', 2, None, '___sec146'),
              (u'Test and trial functions', 2, None, '___sec147'),
              (u'The collocation method', 2, None, '___sec148'),
              (u'The subdomain collocation method', 3, None, '___sec149'),
              (u'Examples on using the principles',
               2,
               u'fem:deq:1D:ex:sines',
               u'fem:deq:1D:ex:sines'),
              (u'The model problem', 3, None, '___sec151'),
              (u'Basis functions', 3, None, '___sec152'),
              (u'The residual', 3, None, '___sec153'),
              (u'The least squares method', 3, None, '___sec154'),
              (u'The Galerkin method', 3, None, '___sec155'),
              (u'The collocation method', 3, None, '___sec156'),
              (u'Comparison', 3, None, '___sec157'),
              (u'Integration by parts',
               2,
               u'fem:deq:1D:varform',
               u'fem:deq:1D:varform'),
              (u'Weak form', 3, None, '___sec159'),
              (u'Boundary function',
               2,
               u'fem:deq:1D:essBC:Bfunc',
               u'fem:deq:1D:essBC:Bfunc'),
              (u'Computing with global polynomials', 1, None, '___sec161'),
              (u'Computing with Dirichlet and Neumann conditions',
               2,
               u'fem:deq:1D:varform:ex:DN:case',
               u'fem:deq:1D:varform:ex:DN:case'),
              (u'When the numerical method is exact', 2, None, '___sec163'),
              (u'Abstract notation for variational formulations',
               2,
               u'fem:deq:1D:varform:abstract',
               u'fem:deq:1D:varform:abstract'),
              (u'Variational problems and minimization of functionals',
               2,
               u'fem:deq:1D:optimization',
               u'fem:deq:1D:optimization'),
              (u'Example', 3, None, '___sec166'),
              (u'The general minimization problem', 3, None, '___sec167'),
              (u'Derivation', 3, None, '___sec168'),
              (u'Minimization of the discretized functional',
               3,
               None,
               '___sec169'),
              (u'Calculus of variations', 3, None, '___sec170'),
              (u'Examples on variational formulations',
               1,
               u'fem:deq:1D:varform:ex',
               u'fem:deq:1D:varform:ex'),
              (u'Variable coefficient', 2, None, '___sec172'),
              (u'First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec173'),
              (u'Nonlinear coefficient', 2, None, '___sec174'),
              (u'Implementation of the algorithms',
               1,
               u'fem:global:deq:1D:code',
               u'fem:global:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:global',
               u'fem:deq:1D:code:global'),
              (u'Fallback on numerical methods', 2, None, '___sec177'),
              (u'Example with constant right-hand side',
               2,
               None,
               '___sec178'),
              (u'Approximations may fail: convection-diffusion',
               1,
               u'ch:convdiff',
               u'ch:convdiff'),
              (u'Exercises', 1, None, '___sec180'),
              (u'Exercise 25: Refactor functions into a more general class',
               2,
               u'fem:deq:exer:BVP1D:class',
               u'fem:deq:exer:BVP1D:class'),
              (u'Exercise 26: Compute the deflection of a cable with sine functions',
               2,
               u'fem:deq:exer:tension:cable',
               u'fem:deq:exer:tension:cable'),
              (u'Exercise 27: Compute the deflection of a cable with power functions',
               2,
               u'fem:deq:exer:tension:cable_xn',
               u'fem:deq:exer:tension:cable_xn'),
              (u'Exercise 28: Check integration by parts',
               2,
               u'fem:deq:exer:intg:parts',
               u'fem:deq:exer:intg:parts'),
              (u'Variational formulations with finite elements',
               0,
               u'ch:varform:fe',
               u'ch:varform:fe'),
              (u'Computing with finite elements',
               1,
               u'fem:deq:1D:fem1',
               u'fem:deq:1D:fem1'),
              (u'Finite element mesh and basis functions',
               2,
               None,
               '___sec187'),
              (u'Computation in the global physical domain',
               2,
               u'fem:deq:1D:comp:global',
               u'fem:deq:1D:comp:global'),
              (u'Comparison with a finite difference discretization',
               2,
               u'fem:deq:1D:fdm_vs_fem',
               u'fem:deq:1D:fdm_vs_fem'),
              (u'Cellwise computations',
               2,
               u'fem:deq:1D:comp:elmwise',
               u'fem:deq:1D:comp:elmwise'),
              (u'The integral for the element matrix', 3, None, '___sec191'),
              (u'The integral for the element vector', 3, None, '___sec192'),
              (u'Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec193'),
              (u'Contributions from the first and last cell',
               3,
               None,
               '___sec194'),
              (u'Assembly', 3, None, '___sec195'),
              (u'Boundary conditions: specified nonzero value',
               1,
               u'fem:deq:1D:essBC',
               u'fem:deq:1D:essBC'),
              (u'General construction of a boundary function',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc',
               u'fem:deq:1D:fem:essBC:Bfunc'),
              (u'Example on computing with a finite element-based boundary function',
               2,
               None,
               '___sec198'),
              (u'Computations in physical coordinates', 3, None, '___sec199'),
              (u'Cellwise computations on the reference element',
               3,
               None,
               '___sec200'),
              (u'Modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (u'Computations in the physical system', 3, None, '___sec202'),
              (u'Symmetric modification of the linear system',
               2,
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               u'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (u'Modification of the element matrix and vector',
               2,
               None,
               '___sec204'),
              (u'Boundary conditions: specified derivative',
               1,
               u'fem:deq:1D:BC:nat',
               u'fem:deq:1D:BC:nat'),
              (u'The variational formulation', 2, None, '___sec206'),
              (u'Boundary term vanishes because of the test functions',
               2,
               u'fem:deq:1D:BC:nat:uLtest',
               u'fem:deq:1D:BC:nat:uLtest'),
              (u'Boundary term vanishes because of linear system modifications',
               2,
               u'fem:deq:1D:BC:nat:uLmod',
               u'fem:deq:1D:BC:nat:uLmod'),
              (u'Direct computation of the global linear system',
               2,
               u'fem:deq:1D:BC:nat:Aub',
               u'fem:deq:1D:BC:nat:Aub'),
              (u'Cellwise computations', 2, None, '___sec210'),
              (u'Implementation of finite element algorithms',
               1,
               u'fem:deq:1D:code',
               u'fem:deq:1D:code'),
              (u'Extensions of the code for approximation',
               2,
               u'fem:deq:1D:code:fe',
               u'fem:deq:1D:code:fe'),
              (u'Utilizing a sparse matrix',
               2,
               u'fem:deq:1D:code:fe_sparse',
               u'fem:deq:1D:code:fe_sparse'),
              (u'Application to our model problem', 2, None, '___sec214'),
              (u'Variational formulations in 2D and 3D',
               1,
               u'fem:deq:2D:varform',
               u'fem:deq:2D:varform'),
              (u'Integration by parts', 2, None, '___sec216'),
              (u'Example on a multi-dimensional variational problem',
               2,
               u'sec:varform:general:convdiff',
               u'sec:varform:general:convdiff'),
              (u'Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec218'),
              (u'Numerical integration', 2, None, '___sec219'),
              (u'Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec220'),
              (u'A glimpse of the mathematical theory of the finite element method',
               2,
               None,
               '___sec221'),
              (u'Abstract variational forms', 3, None, '___sec222'),
              (u'Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec223'),
              (u'Assumptions', 3, None, '___sec224'),
              (u'Existence and uniqueness', 3, None, '___sec225'),
              (u'Stability', 3, None, '___sec226'),
              (u'Equivalent minimization problem', 3, None, '___sec227'),
              (u'Best approximation principle', 3, None, '___sec228'),
              (u'Best approximation property in the norm of the space',
               3,
               None,
               '___sec229'),
              (u'Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec230'),
              (u'Equivalent matrix minimization problem',
               3,
               None,
               '___sec231'),
              (u'A priori error estimate for the derivative',
               3,
               None,
               '___sec232'),
              (u'A priori error estimate for the solution',
               3,
               None,
               '___sec233'),
              (u'Implementation in 2D and 3D via FEniCS',
               1,
               u'fem:varform:fenics',
               u'fem:varform:fenics'),
              (u'Mathematical problem',
               2,
               u'fem:varform:fenics:problem',
               u'fem:varform:fenics:problem'),
              (u'Symmetry', 3, None, '___sec236'),
              (u'Variational formulation',
               2,
               u'fem:varform:fenics:varform',
               u'fem:varform:fenics:varform'),
              (u'The FEniCS solver', 2, None, '___sec238'),
              (u'Making the mesh', 2, None, '___sec239'),
              (u'Solving a problem', 2, None, '___sec240'),
              (u'Convection-diffusion and Petrov-Galerkin methods',
               1,
               None,
               '___sec241'),
              (u'Summary', 1, None, '___sec242'),
              (u'Exercises', 1, None, '___sec243'),
              (u'Exercise 29: Compute the deflection of a cable with 2 P1 elements',
               2,
               u'fem:deq:exer:cable:2P1',
               u'fem:deq:exer:cable:2P1'),
              (u'Exercise 30: Compute the deflection of a cable with 1 P2 element',
               2,
               u'fem:deq:exer:cable:1P2',
               u'fem:deq:exer:cable:1P2'),
              (u'Exercise 31: Compute the deflection of a cable with a step load',
               2,
               u'fem:deq:exer:cable:stepload',
               u'fem:deq:exer:cable:stepload'),
              (u'Exercise 32: Compute with a non-uniform mesh',
               2,
               u'fem:deq:exer:1D:mesh:nonuniform',
               u'fem:deq:exer:1D:mesh:nonuniform'),
              (u'Problem 33: Solve a 1D finite element problem by hand',
               2,
               u'fem:deq:exer:1D:gen:problem1',
               u'fem:deq:exer:1D:gen:problem1'),
              (u'Exercise 34: Investigate exact finite element solutions',
               2,
               u'fem:deq:exer:1D:exact_numerics',
               u'fem:deq:exer:1D:exact_numerics'),
              (u'Exercise 35: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               u'fem:deq:exer:1D:Poisson:polar',
               u'fem:deq:exer:1D:Poisson:polar'),
              (u'Exercise 36: Compute with variable coefficients and P1 elements by hand',
               2,
               u'fem:deq:exer:1D:gen:problem2',
               u'fem:deq:exer:1D:gen:problem2'),
              (u'Exercise 37: Solve a 2D Poisson equation using polynomials and sines',
               2,
               u'fem:deq:exer:2D:torsion:xy:sin',
               u'fem:deq:exer:2D:torsion:xy:sin'),
              (u'Time-dependent variational forms',
               0,
               u'ch:femtime',
               u'ch:femtime'),
              (u'Discretization in time by a Forward Euler scheme',
               1,
               u'fem:deq:diffu:FE',
               u'fem:deq:diffu:FE'),
              (u'Time discretization', 2, None, '___sec255'),
              (u'Space discretization', 2, None, '___sec256'),
              (u'Variational forms', 2, None, '___sec257'),
              (u'Notation for the solution at recent time levels',
               2,
               None,
               '___sec258'),
              (u'Deriving the linear systems', 2, None, '___sec259'),
              (u'Computational algorithm', 2, None, '___sec260'),
              (u'Example using sinusoidal basis functions',
               2,
               u'fem:deq:diffu:FE:cosex',
               u'fem:deq:diffu:FE:cosex'),
              (u'Comparing P1 elements with the finite difference method',
               2,
               u'fem:deq:diffu:FE:fdvsP1fe',
               u'fem:deq:diffu:FE:fdvsP1fe'),
              (u'Lumping the mass matrix', 3, None, '___sec263'),
              (u'Discretization in time by a Backward Euler scheme',
               1,
               u'fem:deq:diffu:BE',
               u'fem:deq:diffu:BE'),
              (u'Time discretization', 2, None, '___sec265'),
              (u'Variational forms', 2, None, '___sec266'),
              (u'Linear systems', 2, None, '___sec267'),
              (u'Finite difference operators corresponding to P1 elements',
               3,
               None,
               '___sec268'),
              (u'Dirichlet boundary conditions',
               1,
               u'fem:deq:diffu:Dirichlet',
               u'fem:deq:diffu:Dirichlet'),
              (u'Boundary function', 2, None, '___sec270'),
              (u'Finite element basis functions', 2, None, '___sec271'),
              (u'Modification of the linear system', 2, None, '___sec272'),
              (u'Example: Oscillating Dirichlet boundary condition',
               2,
               u'fem:deq:diffu:Dirichlet:ex',
               u'fem:deq:diffu:Dirichlet:ex'),
              (u'Accuracy of the finite element solution',
               1,
               u'fem:deq:diffu:anal',
               u'fem:deq:diffu:anal'),
              (u'Illustrating example', 2, None, '___sec275'),
              (u'Methods of analysis', 2, None, '___sec276'),
              (u'Fourier components and dispersion relations',
               2,
               None,
               '___sec277'),
              (u'Forward Euler discretization', 2, None, '___sec278'),
              (u'Backward Euler discretization', 2, None, '___sec279'),
              (u'Comparing amplification factors', 2, None, '___sec280'),
              (u'Exercises', 1, None, '___sec281'),
              (u'Exercise 38: Analyze a Crank-Nicolson scheme for the diffusion equation',
               2,
               u'fem:deq:exer:diffu:analysis:CN',
               u'fem:deq:exer:diffu:analysis:CN'),
              (u'Variational forms for systems of PDEs',
               0,
               u'ch:femsys',
               u'ch:femsys'),
              (u'Variational forms', 1, u'fem:sys:vform', u'fem:sys:vform'),
              (u'Sequence of scalar PDEs formulation', 2, None, '___sec285'),
              (u'Vector PDE formulation', 2, None, '___sec286'),
              (u'A worked example', 1, u'fem:sys:uT:ex', u'fem:sys:uT:ex'),
              (u'Identical function spaces for the unknowns',
               1,
               None,
               '___sec288'),
              (u'Variational form of each individual PDE',
               2,
               None,
               '___sec289'),
              (u'Compound scalar variational form', 2, None, '___sec290'),
              (u'Decoupled linear systems', 2, None, '___sec291'),
              (u'Coupled linear systems', 2, None, '___sec292'),
              (u'Different function spaces for the unknowns',
               1,
               None,
               '___sec293'),
              (u'Computations in 1D',
               1,
               u'femsys:cooling:1D',
               u'femsys:cooling:1D'),
              (u'Another example in 1D',
               2,
               u'fem:sys:up:1D',
               u'fem:sys:up:1D'),
              (u'Exercises', 1, None, '___sec296'),
              (u'Problem 39: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:1',
               u'femsys:exer:cooling:1'),
              (u'Problem 40: Estimate order of convergence for the Cooling law',
               2,
               u'femsys:exer:cooling:2',
               u'femsys:exer:cooling:2'),
              (u'Flexible implementations of boundary conditions',
               0,
               u'ch:nitsche',
               u'ch:nitsche'),
              (u'Optimization with constraint',
               1,
               u'nitsche:fxy:opt',
               u'nitsche:fxy:opt'),
              (u'Elimination of variables', 2, None, '___sec301'),
              (u'Lagrange multiplier method',
               2,
               u'nitsche:fxy:opt:Lagrange',
               u'nitsche:fxy:opt:Lagrange'),
              (u'Penalty method',
               2,
               u'nitsche:fxy:opt:penalty',
               u'nitsche:fxy:opt:penalty'),
              (u'Optimization of functionals',
               1,
               u'nitsche:pde:opt',
               u'nitsche:pde:opt'),
              (u'Classical calculus of variations',
               2,
               u'nitsche:pde:opt:varcalculus',
               u'nitsche:pde:opt:varcalculus'),
              (u'Penalty method for optimization with constraints',
               2,
               u'nitsche:pde:opt:penalty',
               u'nitsche:pde:opt:penalty'),
              (u'Lagrange multiplier method for optimization with constraints',
               2,
               u'nitsche:pde:opt:Lagrange',
               u'nitsche:pde:opt:Lagrange'),
              (u'Example: 1D problem',
               2,
               u'nitsche:pde:opt:1Dex',
               u'nitsche:pde:opt:1Dex'),
              (u'Example: adding a constraint in a Neumann problem',
               2,
               None,
               '___sec309'),
              (u'Nonlinear problems', 0, u'ch:nonlin', u'ch:nonlin'),
              (u'Introduction of basic concepts',
               1,
               u'nonlin:timediscrete:logistic',
               u'nonlin:timediscrete:logistic'),
              (u'Linear versus nonlinear equations', 2, None, '___sec312'),
              (u'Algebraic equations', 3, None, '___sec313'),
              (u'Differential equations', 3, None, '___sec314'),
              (u'A simple model problem', 2, None, '___sec315'),
              (u'Linearization by explicit time discretization',
               2,
               u'nonlin:timediscrete:logistic:FE',
               u'nonlin:timediscrete:logistic:FE'),
              (u'Exact solution of nonlinear algebraic equations',
               2,
               u'nonlin:timediscrete:logistic:roots',
               u'nonlin:timediscrete:logistic:roots'),
              (u'Linearization', 2, None, '___sec318'),
              (u'Picard iteration',
               2,
               u'nonlin:timediscrete:logistic:Picard',
               u'nonlin:timediscrete:logistic:Picard'),
              (u'Stopping criteria', 3, None, '___sec320'),
              (u'A single Picard iteration', 3, None, '___sec321'),
              (u'Linearization by a geometric mean',
               2,
               u'nonlin:timediscrete:logistic:geometric:mean',
               u'nonlin:timediscrete:logistic:geometric:mean'),
              (u"Newton's method",
               2,
               u'nonlin:timediscrete:logistic:Newton',
               u'nonlin:timediscrete:logistic:Newton'),
              (u'Relaxation',
               2,
               u'nonlin:timediscrete:logistic:relaxation',
               u'nonlin:timediscrete:logistic:relaxation'),
              (u'Implementation and experiments',
               2,
               u'nonlin:timediscrete:logistic:impl',
               u'nonlin:timediscrete:logistic:impl'),
              (u'Generalization to a general nonlinear ODE',
               2,
               u'nonlin:ode:generic',
               u'nonlin:ode:generic'),
              (u'Explicit time discretization', 3, None, '___sec327'),
              (u'Backward Euler discretization', 3, None, '___sec328'),
              (u'Crank-Nicolson discretization', 3, None, '___sec329'),
              (u'Systems of ODEs',
               2,
               u'nonlin:ode:generic:sys:pendulum',
               u'nonlin:ode:generic:sys:pendulum'),
              (u'Example', 3, None, '___sec331'),
              (u'Systems of nonlinear algebraic equations',
               1,
               u'nonlin:systems:alg',
               u'nonlin:systems:alg'),
              (u'Picard iteration',
               2,
               u'nonlin:systems:alg:Picard',
               u'nonlin:systems:alg:Picard'),
              (u"Newton's method",
               2,
               u'nonlin:systems:alg:Newton',
               u'nonlin:systems:alg:Newton'),
              (u'Stopping criteria',
               2,
               u'nonlin:systems:alg:terminate',
               u'nonlin:systems:alg:terminate'),
              (u'Example: A nonlinear ODE model from epidemiology',
               2,
               u'nonlin:systems:alg:SI',
               u'nonlin:systems:alg:SI'),
              (u'Implicit time discretization', 3, None, '___sec337'),
              (u'A Picard iteration', 3, None, '___sec338'),
              (u"Newton's method", 3, None, '___sec339'),
              (u'Linearization at the differential equation level',
               1,
               u'nonlin:pdelevel',
               u'nonlin:pdelevel'),
              (u'Explicit time integration',
               2,
               u'nonlin:pdelevel:explicit',
               u'nonlin:pdelevel:explicit'),
              (u'Backward Euler scheme and Picard iteration',
               2,
               u'nonlin:pdelevel:Picard',
               u'nonlin:pdelevel:Picard'),
              (u"Backward Euler scheme and Newton's method",
               2,
               u'nonlin:pdelevel:Newton',
               u'nonlin:pdelevel:Newton'),
              (u'Linearization via Taylor expansions', 3, None, '___sec344'),
              (u'Similarity with Picard iteration', 3, None, '___sec345'),
              (u'Implementation', 3, None, '___sec346'),
              (u'Derivation with alternative notation', 3, None, '___sec347'),
              (u'Crank-Nicolson discretization',
               2,
               u'nonlin:pdelevel:Picard:CN',
               u'nonlin:pdelevel:Picard:CN'),
              (u'1D stationary nonlinear differential equations',
               1,
               u'nonlin:alglevel:1D',
               u'nonlin:alglevel:1D'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:1D:fd',
               u'nonlin:alglevel:1D:fd'),
              (u'Solution of algebraic equations', 2, None, '___sec351'),
              (u'The structure of the equation system', 3, None, '___sec352'),
              (u'Picard iteration', 3, None, '___sec353'),
              (u'Mesh with two cells', 3, None, '___sec354'),
              (u"Newton's method", 3, None, '___sec355'),
              (u'Multi-dimensional PDE problems', 1, None, '___sec356'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:dD:fd',
               u'nonlin:alglevel:dD:fd'),
              (u'Picard iteration', 3, None, '___sec358'),
              (u"Newton's method", 3, None, '___sec359'),
              (u'Continuation methods', 2, None, '___sec360'),
              (u'Exercises', 1, u'nonlin:exer', u'nonlin:exer'),
              (u'Problem 41: Determine if equations are nonlinear or not',
               2,
               u'nonlin:exer:lin:vs:nonlin',
               u'nonlin:exer:lin:vs:nonlin'),
              (u'Exercise 42: Derive and investigate a generalized logistic model',
               2,
               u'nonlin:exer:logistic:gen',
               u'nonlin:exer:logistic:gen'),
              (u"Problem 43: Experience the behavior of Newton's method",
               2,
               u'nonlin:exer:Newton:problems1',
               u'nonlin:exer:Newton:problems1'),
              (u'Problem 44: Compute the Jacobian of a $2\\times 2$ system',
               2,
               u'nonlin:exer:vib:Jacobian',
               u'nonlin:exer:vib:Jacobian'),
              (u'Problem 45: Solve nonlinear equations arising from a vibration ODE',
               2,
               u'nonlin:exer:vib:geometric:mean',
               u'nonlin:exer:vib:geometric:mean'),
              (u'Exercise 46: Find the truncation error of arithmetic mean of products',
               2,
               u'nonlin:exer:products:arith:mean',
               u'nonlin:exer:products:arith:mean'),
              (u"Problem 47: Newton's method for linear problems",
               2,
               u'nonlin:exer:Newton:linear',
               u'nonlin:exer:Newton:linear'),
              (u'Exercise 48: Discretize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:fem',
               u'nonlin:exer:1D:1pu2:fem'),
              (u'Exercise 49: Linearize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:PicardNewton',
               u'nonlin:exer:1D:1pu2:PicardNewton'),
              (u'Problem 50: Finite differences for the 1D Bratu problem',
               2,
               u'nonlin:exer:1D:fu:discretize:fd',
               u'nonlin:exer:1D:fu:discretize:fd'),
              (u'Exercise 51: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               u'nonlin:exer:1D:heat:nonlinear:fdm',
               u'nonlin:exer:1D:heat:nonlinear:fdm'),
              (u'Exercise 52: Differentiate a highly nonlinear term',
               2,
               u'nonlin:exer:grad:pow:term',
               u'nonlin:exer:grad:pow:term'),
              (u'Exercise 53: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               u'nonlin:exer:2D:heat:nonlinear:fd',
               u'nonlin:exer:2D:heat:nonlinear:fd'),
              (u'Exercise 54: Find the sparsity of the Jacobian',
               2,
               u'nonlin:exer:sparsity:Jacobian',
               u'nonlin:exer:sparsity:Jacobian'),
              (u'Problem 55: Investigate a 1D problem with a continuation method',
               2,
               u'nonlin:exer:continuation:1DnNflow',
               u'nonlin:exer:continuation:1DnNflow'),
              (u'Symbolic nonlinear finite element equations',
               1,
               u'nonlin:app:fem_vs_fdm',
               u'nonlin:app:fem_vs_fdm'),
              (u'Finite element basis functions',
               2,
               u'nonlin:alglevel:1D:fe_basis',
               u'nonlin:alglevel:1D:fe_basis'),
              (u'The group finite element method',
               2,
               u'nonlin:alglevel:1D:fe:group',
               u'nonlin:alglevel:1D:fe:group'),
              (u'Finite element approximation of functions of $u$',
               3,
               None,
               '___sec380'),
              (u'Simplified problem', 3, None, '___sec381'),
              (u'Integrating nonlinear functions', 3, None, '___sec382'),
              (u'Application of the group finite element method',
               3,
               None,
               '___sec383'),
              (u'Numerical integration of nonlinear terms by hand',
               2,
               u'nonlin:alglevel:1D:fe:f',
               u'nonlin:alglevel:1D:fe:f'),
              (u'Discretization of a variable coefficient Laplace term',
               2,
               u'nonlin:alglevel:1D:fe:Laplace',
               u'nonlin:alglevel:1D:fe:Laplace'),
              (u'Group finite element method', 3, None, '___sec386'),
              (u'Numerical integration at the nodes', 3, None, '___sec387'),
              (u'Uncertainty quantification and polynomial chaos expansions',
               0,
               u'ch:pc',
               u'ch:pc'),
              (u'Sample problems', 1, None, '___sec389'),
              (u'ODE for decay processes', 2, None, '___sec390'),
              (u'The stochastic Poisson equation', 2, None, '___sec391'),
              (u'Basic principles', 1, None, '___sec392'),
              (u'Basic statistical results', 2, None, '___sec393'),
              (u'Least-squares methods', 2, None, '___sec394'),
              (u'Example: Least squares applied to the decay ODE',
               2,
               None,
               '___sec395'),
              (u'Modeling the response', 2, None, '___sec396'),
              (u'Numerical integration', 2, None, '___sec397'),
              (u'Stochastic collocation', 2, None, '___sec398'),
              (u'The Chaospy software', 1, u'pc:chaospy', u'pc:chaospy'),
              (u'Intrusive polynomial chaos methods',
               1,
               u'pc:intrusive',
               u'pc:intrusive'),
              (u'Variational methods for linear systems',
               0,
               u'ch:cg',
               u'ch:cg'),
              (u'Conjugate gradient-like iterative methods',
               1,
               u'ch:linalg:CGmethods',
               u'ch:linalg:CGmethods'),
              (u'The Galerkin method', 2, None, '___sec403'),
              (u'The least squares method', 2, None, '___sec404'),
              (u'Krylov subspaces', 2, None, '___sec405'),
              (u'Computation of the basis vectors', 2, None, '___sec406'),
              (u'Computation of a new solution vector', 2, None, '___sec407'),
              (u'Summary of the least squares method', 2, None, '___sec408'),
              (u'Remark', 3, None, '___sec409'),
              (u'Truncation and restart', 2, None, '___sec410'),
              (u'Summary of the Galerkin method', 2, None, '___sec411'),
              (u'A framework based on the error', 2, None, '___sec412'),
              (u'Preconditioning',
               1,
               u'ch:linalg2:preconditioning',
               u'ch:linalg2:preconditioning'),
              (u'Motivation and Basic Principles', 2, None, '___sec414'),
              (u'Use of the preconditioning matrix in the iterative methods',
               2,
               None,
               '___sec415'),
              (u'Classical iterative methods as preconditioners',
               2,
               u'ch:linalg:SORprecond',
               u'ch:linalg:SORprecond'),
              (u'Incomplete factorization preconditioners',
               2,
               u'linalg:ILU',
               u'linalg:ILU'),
              (u'Appendix: Useful formulas',
               0,
               u'ch:formulas',
               u'ch:formulas'),
              (u'Finite difference operator notation',
               1,
               u'sec:form:fdop',
               u'sec:form:fdop'),
              (u'Truncation errors of finite difference approximations',
               1,
               u'sec:form:truncerr',
               u'sec:form:truncerr'),
              (u'Finite differences of exponential functions',
               1,
               u'sec:form:fdexp',
               u'sec:form:fdexp'),
              (u'Complex exponentials', 3, None, '___sec422'),
              (u'Real exponentials', 3, None, '___sec423'),
              (u'Finite differences of $t^n$',
               1,
               u'sec:form:fdtn',
               u'sec:form:fdtn'),
              (u'Software', 2, None, '___sec425'),
              (u'References', 1, None, '___sec426')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{{q}}
\newcommand{\residual}{r}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0018"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized017.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized019.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:deq:1D:varform:ex">Examples on variational formulations</h1>

<p>
The following sections derive variational formulations for some
prototype differential equations in 1D, and demonstrate how we with
ease can handle variable coefficients, mixed Dirichlet and Neumann
boundary conditions, first-order derivatives, and nonlinearities.

<h2 id="___sec172">Variable coefficient </h2>

<p>
Consider the problem

$$
\begin{equation}
-\frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D\tp
\tag{186}
\end{equation}
$$

There are two new features of this problem compared with
previous examples: a variable
coefficient \( \dfc (x) \) and nonzero Dirichlet conditions at both boundary points.

<p>
Let us first deal with the boundary conditions. We seek

$$ u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x)\tp$$

Since the Dirichlet conditions demand

$$ \baspsi_i(0)=\baspsi_i(L)=0,\quad i\in\If,$$

the function \( B(x) \)
must fulfill \( B(0)=C \) and \( B(L)=D \). The we are guaranteed that \( u(0)=C \)
and \( u(L)=D \). How \( B \) varies in between
\( x=0 \) and \( x=L \) is not of importance. One possible choice is

$$ B(x) = C + \frac{1}{L}(D-C)x,$$

which follows from <a href="._fem-book-solarized016.html#mjx-eqn-183">(183)</a> with \( p=1 \).

<p>
We seek \( (u-B)\in V \). As usual,

$$ V = \hbox{span}\{\baspsi_0,\ldots,\baspsi_N\}\tp$$

Note that any \( v\in V \) has the property \( v(0)=v(L)=0 \).

<p>
The residual arises by inserting our \( u \) in the differential equation:

$$ R = -\frac{d}{dx}\left( \dfc\frac{du}{dx}\right) -f\tp $$

Galerkin's method is

$$
(R, v) = 0,\quad \forall v\in V,
$$

or written with explicit integrals,

$$
\int_{\Omega} \left(-\frac{d}{dx}\left( \dfc\frac{du}{dx}\right) -f\right)v \dx = 0,\quad \forall v\in V \tp
$$

We proceed with integration by parts to lower the derivative from
second to first order:

$$ -\int_{\Omega} \frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) v \dx
= \int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}\dx -
\left[\dfc\frac{du}{dx}v\right]_0^L
\tp
$$

<p>
The boundary term vanishes since \( v(0)=v(L)=0 \).
The variational formulation is then

$$
\int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}\dx = \int_{\Omega} f(x)v\dx,\quad
\forall v\in V\tp
$$

The variational formulation can alternatively be written in a more
compact form:

$$
(\dfc u',v') = (f,v),\quad \forall v\in V
\tp
$$

The corresponding abstract notation reads

$$ a(u,v)=L(v)\quad\forall v\in V,$$

with
$$ a(u,v)= (\dfc u',v'),\quad L(v)=(f,v) \tp  $$

<p>
We may insert \( u=B + \sum_jc_j\baspsi_j \) and \( v=\baspsi_i \) to
derive the linear system:

$$
(\dfc B' + \dfc \sum_{j\in\If} c_j \baspsi_j', \baspsi_i') =
(f,\baspsi_i), \quad i\in\If \tp
$$

Isolating everything with the \( c_j \) coefficients on the left-hand side
and all known terms on the right-hand side
gives

$$ \sum_{j\in\If} (\dfc\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (\alpha (D-C)L^{-1}, \baspsi_i'), \quad i\in\If
\tp
$$

This is nothing but a linear system \( \sum_j A_{i,j}c_j=b_i \)
with

$$
\begin{align*}
A_{i,j} &= (\alpha \baspsi_j', \baspsi_i') = \int_{\Omega} \dfc(x)\baspsi_j'(x),
\baspsi_i'(x)\dx,\\ 
b_i &= (f,\baspsi_i) + (\alpha (D-C)L^{-1},\baspsi_i')=
\int_{\Omega} \left(f(x)\baspsi_i(x) + \dfc(x)\frac{D-C}{L}\baspsi_i'(x)\right) \dx
\tp
\end{align*}
$$

<h2 id="___sec173">First-order derivative in the equation and boundary condition </h2>

<p>
The next problem to formulate in terms of a variational form reads

$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E\tp
\tag{187}
\end{equation}
$$

The new features are a first-order derivative \( u' \) in the equation
and the boundary
condition involving the derivative: \( u'(L)=E \).
Since we have a Dirichlet condition at \( x=0 \),
we must force \( \baspsi_i(0)=0 \) and use a boundary function
to take care of the condition \( u(0)=C \).
Because there is no Dirichlet
condition on \( x=L \) we do not make any requirements to \( \baspsi_i(L) \).
The simplest possible choice of \( B(x) \) is \( B(x)=C \).

<p>
The expansion for \( u \) becomes

$$ u = C + \sum_{j\in\If} c_j \baspsi_i(x)
\tp
$$

<p>
The variational formulation arises from multiplying the equation by
a test function \( v\in V \) and integrating over \( \Omega \):

$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V$$

We apply integration by parts to the \( u''v \) term only. Although we could
also integrate \( u' v \) by parts, this is not common.
The result becomes

$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V \tp $$

Now, \( v(0)=0 \) so

$$ [u' v]_0^L = u'(L)v(L) = E v(L),$$

because \( u'(L)=E \).
Thus, integration by parts allows us to take care of the Neumann condition
in the boundary term.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Natural and essential boundary conditions.</b>
<p>
A common mistake is to forget a boundary term like \( [u'v]_0^L \) in
the integration by parts. Such a mistake implies that we actually
impose the condition \( u'=0 \) unless there is a Dirichlet condition
(i.e., \( v=0 \)) at that point! This fact has great practical
consequences, because it is easy to forget the boundary term, and that
implicitly set a boundary condition!

<p>
Since homogeneous Neumann conditions can be incorporated without
&quot;doing anything&quot; (i.e., omitting the boundary term), and
non-homogeneous Neumann conditions can just be inserted in the
boundary term, such conditions are known as <em>natural boundary
conditions</em>.  Dirichlet conditions require more essential steps in the
mathematical formulation, such as forcing all \( \basphi_i=0 \) on the
boundary and constructing a \( B(x) \), and are therefore known as
<em>essential boundary conditions</em>.
</div>


<p>
The final variational form reads

$$ (u',v') + (bu',v) = (f,v) + E v(L), \quad\forall v\in V \tp $$

In the abstract notation we have

$$ a(u,v)=L(v)\quad\forall v\in V,$$

with the particular formulas
$$ a(u,v)=(u',v') + (bu',v),\quad L(v)= (f,v) + E v(L)\tp $$

<p>
The associated linear system is derived by inserting \( u=B+\sum_jc_j\baspsi_j \)
and replacing \( v \) by \( \baspsi_i \) for \( i\in\If \). Some algebra results in

$$ \sum_{j\in\If} \underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}} c_j = \underbrace{(f,\baspsi_i) + E \baspsi_i(L)}_{b_i}
\tp
$$

Observe that in this problem, the coefficient matrix is not symmetric,
because of the term

$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i \dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_j \dx = (\baspsi_i',b\baspsi_j)
\tp
$$

<p>
<!-- Too early: -->
<!-- For finite element basis functions, it is worth noticing that the boundary term -->
<!-- \( E\baspsi_i(L) \) is nonzero only in the entry \( b_N \) since all -->
<!-- \( \baspsi_i \), \( i\neq N \), are zero at \( x=L \), provided the degrees of freedom -->
<!-- are numbered from left to right in 1D so that \( \xno{N}=L \). -->

<h2 id="___sec174">Nonlinear coefficient </h2>

<p>
Finally, we show that the techniques used above to derive variational
forms apply to nonlinear differential equation
problems as well. Here is a model problem with
a nonlinear coefficient \( \alpha(u) \) and a nonlinear right-hand side \( f(u) \):

$$
\begin{equation}
-(\dfc(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\tp
\tag{188}
\end{equation}
$$

Our space \( V \) has basis \( \sequencei{\baspsi} \), and because of the
condition \( u(0)=0 \), we must require \( \baspsi_i(0)=0 \), \( i\in\If \).

<p>
Galerkin's method is about inserting the approximate
\( u \), multiplying the differential equation by \( v\in V \), and integrate,

$$ -\int_0^L \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right)v \dx =
\int_0^L f(u)v \dx\quad\forall v\in V
\tp
$$

The integration by parts does not differ from the case where we have
\( \dfc(x) \) instead of \( \dfc(u) \):

$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}\dx =
\int_0^L f(u)v\dx + [\dfc(u)vu']_0^L\quad\forall v\in V
\tp
$$

The term \( \dfc(u(0))v(0)u'(0)=0 \) since \( v(0) \).
The other term, \( \dfc(u(L))v(L)u'(L) \),
is used to impose the other boundary condition \( u'(L)=E \), resulting in

$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}\dx =
\int_0^L f(u)v\dx + \dfc(u(L))v(L)E\quad\forall v\in V,
$$

or alternatively written more compactly as

$$ (\dfc(u)u', v') = (f(u),v) + \dfc(u(L))v(L)E\quad\forall v\in V
\tp
$$

Since the problem is nonlinear, we cannot identify a bilinear
form \( a(u,v) \) and a linear form \( L(v) \).
An abstract formulation is typically <em>find \( u \) such that</em>

$$ F(u;v) = 0\quad\forall v\in V,$$

with
$$ F(u;v) = (a(u)u', v') - (f(u),v) - a(L)v(L)E
\tp
$$

<p>
By inserting \( u=\sum_j c_j\baspsi_j \) and \( v=\baspsi_i \) in \( F(u;v) \),
we get a <em>nonlinear system of
algebraic equations</em> for the unknowns \( c_i \), \( i\in\If \). Such systems must
be solved by constructing a sequence of linear systems whose solutions
hopefully converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton's method.

<h1 id="fem:global:deq:1D:code">Implementation of the algorithms</h1>

<p>
Our hand calculations can benefit greatly by symbolic computing, as shown
earlier, so it is natural to extend our approximation programs based on
<code>sympy</code> to the problem domain of variational formulations.

<h2 id="fem:deq:1D:code:global">Extensions of the code for approximation</h2>

<p>
The user must prepare a function <code>integrand_lhs(psi, i, j)</code> for
returning the integrand of the integral that contributes to matrix
entry \( (i,j) \) on the left-hand side.  The <code>psi</code> variable is a Python dictionary holding the
basis functions and their derivatives in symbolic form. More
precisely, <code>psi[q]</code> is a list of

$$
\begin{equation*}
\{\frac{d^q\baspsi_0}{dx^q},\ldots,\frac{d^q\baspsi_{N_n-1}}{dx^q}\}
\tp
\end{equation*}
$$

Similarly, <code>integrand_rhs(psi, i)</code> returns the integrand
for entry number \( i \) in the right-hand side vector.

<p>
Since we also have contributions to the right-hand side vector (and
potentially also the matrix) from boundary terms without any integral,
we introduce two additional functions, <code>boundary_lhs(psi, i, j)</code> and
<code>boundary_rhs(psi, i)</code> for returning terms in the variational
formulation that are not to be integrated over the domain \( \Omega \).
Examples, to be shown later, will explain in more detail how these
user-supplied function may look like.

<p>
The linear system can be computed and solved symbolically by
the following function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sympy as sym

def solver(integrand_lhs, integrand_rhs, psi, Omega,
           boundary_lhs=None, boundary_rhs=None):
    N = len(psi[0]) - 1
    A = sym.zeros((N+1, N+1))
    b = sym.zeros((N+1, 1))
    x = sym.Symbol('x')
    for i in range(N+1):
        for j in range(i, N+1):
            integrand = integrand_lhs(psi, i, j)
            I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
            if boundary_lhs is not None:
                I += boundary_lhs(psi, i, j)
            A[i,j] = A[j,i] = I   # assume symmetry
        integrand = integrand_rhs(psi, i)
        I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
        if boundary_rhs is not None:
            I += boundary_rhs(psi, i)
        b[i,0] = I
    c = A.LUsolve(b)
    u = sum(c[i,0]*psi[0][i] for i in range(len(psi[0])))
    return u, c
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec177">Fallback on numerical methods </h2>

<p>
Not surprisingly, symbolic solution of differential
equations, discretized by a Galerkin or least squares method
with global basis functions,
is of limited interest beyond the simplest problems, because
symbolic integration might be very time consuming or impossible, not
only in <code>sympy</code> but also in
<a href="http://wolframalpha.com" target="_self">WolframAlpha</a>
(which applies the perhaps most powerful symbolic integration
software available today: Mathematica). Numerical integration
as an option is therefore desirable.

<p>
The extended <code>solver</code> function below tries to combine symbolic and
numerical integration.  The latter can be enforced by the user, or it
can be invoked after a non-successful symbolic integration (being
detected by an <code>Integral</code> object as the result of the integration
in <code>sympy</code>).
<!-- see the section <a href="._fem-book-solarized007.html#fem:approx:global:Lagrange">Lagrange polynomials</a>). -->
Note that for a
numerical integration, symbolic expressions must be converted to
Python functions (using <code>lambdify</code>), and the expressions cannot contain
other symbols than <code>x</code>. The real <code>solver</code> routine in the
<a href="http://tinyurl.com/znpudbt/varform1D.py" target="_self"><tt>varform1D.py</tt></a>
file has error checking and meaningful error messages in such cases.
The <code>solver</code> code below is a condensed version of the real one, with
the purpose of showing how to automate the Galerkin or least squares
method for solving differential equations in 1D with global basis functions:

<p>

<!-- begin inline comment -->
<font color="red">(<b>kam 10</b>: this point has been made many times already)</font>
<!-- end inline comment -->

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(integrand_lhs, integrand_rhs, psi, Omega,
           boundary_lhs=None, boundary_rhs=None, symbolic=True):
    N = len(psi[0]) - 1
    A = sym.zeros((N+1, N+1))
    b = sym.zeros((N+1, 1))
    x = sym.Symbol('x')
    for i in range(N+1):
        for j in range(i, N+1):
            integrand = integrand_lhs(psi, i, j)
            if symbolic:
                I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
                if isinstance(I, sym.Integral):
                    symbolic = False  # force num.int. hereafter
            if not symbolic:
                integrand = sym.lambdify([x], integrand)
                I = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
            if boundary_lhs is not None:
                I += boundary_lhs(psi, i, j)
            A[i,j] = A[j,i] = I
        integrand = integrand_rhs(psi, i)
        if symbolic:
            I = sym.integrate(integrand, (x, Omega[0], Omega[1]))
            if isinstance(I, sym.Integral):
                symbolic = False
        if not symbolic:
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
        if boundary_rhs is not None:
            I += boundary_rhs(psi, i)
        b[i,0] = I
    c = A.LUsolve(b)
    u = sum(c[i,0]*psi[0][i] for i in range(len(psi[0])))
    return u, c
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec178">Example with constant right-hand side </h2>

<p>
To demonstrate the code above, we address

$$
\begin{equation*} -u''(x)=b,\quad x\in\Omega=[0,1],\quad u(0)=1,\ u(1)=0,\end{equation*}
$$

with \( b \) as a (symbolic) constant. A possible basis for the space \( V \)
is \( \baspsi_i(x) = x^{i+1}(1-x) \), \( i\in\If \). Note that
\( \baspsi_i(0)=\baspsi_i(1)=0 \) as required by the Dirichlet conditions.
We need a \( B(x) \) function to take care of the known boundary
values of \( u \). Any function \( B(x)=1-x^p \), \( p\in\Real \), is a candidate,
and one arbitrary choice from this family
is \( B(x)=1-x^3 \). The unknown function is then written as

$$
\begin{equation*}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x)\tp
\end{equation*}
$$

<p>
Let us use the Galerkin method to derive the variational formulation.
Multiplying the differential
equation by \( v \) and integrating by parts yield

$$
\begin{equation*}
\int_0^1 u'v' \dx = \int_0^1 fv \dx\quad\forall v\in V,
\end{equation*}
$$

and with \( u=B + \sum_jc_j\baspsi_j \) we get the linear system

$$
\begin{equation}
\sum_{j\in\If}\left(\int_0^1\baspsi_i'\baspsi_j' \dx\right)c_j =
\int_0^1(f\baspsi_i-B'\baspsi_i') \dx,
\quad i\in\If\tp
\tag{189}
\end{equation}
$$

<p>
The application can be coded as follows with <code>sympy</code>:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import sympy as sym
x, b = sym.symbols('x b')
f = b
B = 1 - x**3
dBdx = sym.diff(B, x)

# Compute basis functions and their derivatives
N = 3
psi = {0: [x**(i+1)*(1-x) for i in range(N+1)]}
psi[1] = [sym.diff(psi_i, x) for psi_i in psi[0]]

def integrand_lhs(psi, i, j):
    return psi[1][i]*psi[1][j]

def integrand_rhs(psi, i):
    return f*psi[0][i] - dBdx*psi[1][i]

Omega = [0, 1]

from varform1D import solver
u_bar, c = solver(integrand_lhs, integrand_rhs, psi, Omega,
                  verbose=True, symbolic=True)
u = B + u_bar
print 'solution u:', sym.simplify(sym.expand(u))
</code></pre>
<!-- end verbatim block -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>kam 11</b>: does not work)</font>
<!-- end inline comment -->


<!-- begin inline comment -->
<font color="red">(<b>hpl 12</b>: We must get it to work. It's a small extension of the code for approximation and very natural to include when we have so much material already on <code>sympy</code> for implementing algorithms.)</font>
<!-- end inline comment -->

<p>
The printout of <code>u</code> reads <code>-b*x**2/2 + b*x/2 - x + 1</code>.  Note that
expanding <code>u</code>, before simplifying, is necessary in the present case to
get a compact, final expression with <code>sympy</code>. Doing <code>expand</code> before
<code>simplify</code> is a common strategy for simplifying expressions in
<code>sympy</code>. However, a non-expanded <code>u</code> might be preferable in other
cases - this depends on the problem in question.

<p>
The exact solution \( \uex(x) \) can be derived by some <code>sympy</code> code that
closely follows the examples in the section <a href="._fem-book-solarized016.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a>. The idea is to integrate \( -u''=b \) twice
and determine the integration constants from the boundary conditions:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>C1, C2 = sym.symbols('C1 C2')    # integration constants
f1 = sym.integrate(f, x) + C1
f2 = sym.integrate(f1, x) + C2
# Find C1 and C2 from the boundary conditions u(0)=0, u(1)=1
s = sym.solve([u_e.subs(x,0) - 1, u_e.subs(x,1) - 0], [C1, C2])
# Form the exact solution
u_e = -f2 + s[C1]*x + s[C2]
print 'analytical solution:', u_e
print 'error:', sym.simplify(sym.expand(u - u_e))
</code></pre>
<!-- end verbatim block -->
The last line prints <code>0</code>, which is not surprising when
\( \uex(x) \) is a parabola and our approximate \( u \) contains polynomials up to
degree 4. It suffices to have \( N=1 \), i.e., polynomials of degree
2, to recover the exact solution.

<p>
We can play around with the code and test that with \( f=Kx^p \), for
some constants \( K \) and \( p \),
the solution is a polynomial of degree \( p+2 \), and \( N=p+1 \) guarantees
that the approximate solution is exact.

<p>
Although the symbolic code is capable of integrating many choices of \( f(x) \),
the symbolic expressions for \( u \) quickly become lengthy and non-informative,
so numerical integration in the code, and hence numerical answers,
have the greatest application potential.

<h1 id="ch:convdiff">Approximations may fail: convection-diffusion</h1>

<p>
In the previous examples we have obtained reasonable approximations
of the continuous solution with several different approaches. In this
chapter we will consider a convection-diffusion equation where
many methods will fail. The failure is purely numerical
and it is often tied to the resolution. The current example is perhaps
the prime example of numerical instabilities in the context of
numerical solution algorithms for PDEs.

<p>
Consider the equation
$$
\begin{align}
\tag{190}
- \epsilon u_{xx} - u_x &= 0, \quad \in  (0,1), \\ 
u(0) &= 1, 
\tag{191}\\ 
u(1) &= 0 .
\tag{192}
\end{align}
$$

<p>
The problem describes a convection-diffusion problem where the
convection is modelled by the first order term \( -u_x \) and diffusion is
described by the second order term \( -\epsilon u_{xx} \). In many
applications \( \epsilon \ll 1 \) and the dominating term is \( -u_x \). The
sign of \( -u_x \) is not important, the same problem occurs for
\( u_x \). The sign only determine the direction of the convection.

<p>
For \( \epsilon=0 \), the solution satisfies
$$
u(x) - u(1) = \int_1^x (-u_x) (-\dx) = 0 ,
$$

which means that \( u(x) = u(1) \). Clearly only the boundary condition at \( x=1 \) is required
and the solution is constant throughout the domain.

<p>
If \( 0 < \epsilon \ll 1 \) such that the term \( -u_x \) is dominating, the
solution is similar to the solution for \( \epsilon=0 \) in the interior.
However, the second order term \( -\epsilon u_{xx} \) makes the problem a
second order problem and two boundary conditions are required, one
condition at each side.  The boundary condition at \( x=0 \) forces the
solution to be zero at that point and this creates a sharp gradient
close to \( x=0 \).  For this reason, the problem is called a <em>singular
perturbation problem</em> as the problem changes fundamentally in the
sense that different boundary conditions are required in the limiting
case \( \epsilon=0 \).

<p>
The solution of the above problem is
$$
\begin{equation}
\tag{193}
u(x) = \frac{e^{-x/\epsilon} - 1}{ e^{-1/\epsilon} -1 } .
\end{equation}
$$

<p>
<center> <!-- figure label: --> <div id="convdiff:analytical"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 62:  Analytical solution to the convection-diffusion problem for varying \( \epsilon \).  <!-- caption label: convdiff:analytical --> </p></center>
<p><img src="fig/conv-diff-analytical.png" align="bottom" width=400></p>
</center>

<p>
The solution is plotted in Figure <a href="#convdiff:analytical">62</a> for
different values of \( \epsilon \).  Clearly, as \( \epsilon \) decrease the
exponential function represents a sharper and sharper gradient.  From
a physical or engineering point of view, the equation
<a href="#mjx-eqn-190">(190)</a> represents the simplest problem involving a common
phenomenon of boundary layers.  Boundary layers are common in all
kinds of fluid flow and is a main problem when discretizing such
equations.  Boundary layers have the characteristics of the solution
<a href="#mjx-eqn-193">(193)</a>, that is; a sharp local exponential
gradient.  In fluid flow the parameter \( \epsilon \) is often related to
the inverse of the Reynolds number which frequently in engineering is
significantly larger than \( 10^3 \) as it was here.  In these
applications the boundary layer is extremely thin and the gradient
extremely sharp.

<p>
In this chapter we will not embark on the fascinating and complex
issue of boundary layer theory but only consider the numerical issues
related to this phenomenon.  Let us as earlier therefore consider an
approximate solution on the following form

$$
\begin{equation}
u(x) =  \hat{u}(x) + B(x) = \sum^{N-1}_{j=1} c_j \baspsi_j(x)  + B(x)
\tag{194}
\end{equation}
$$

<p>
As earlier \( \{\baspsi_j(x)\}_{j=1}^{N-1}\} \) are zero at the boundary \( x=0 \)
and \( x=1 \) and the boundary conditions are accounted for by the function \( B(x) \).
Let

$$
\begin{equation}
B(x) = c_0 (1-x) + c_N x \tp
\tag{195}
\end{equation}
$$

<p>
Then we fixate \( c_0=0 \) and \( c_N=1 \) which makes \( B(x) = x \).
To determine \( \{c_j\}_{j=1}^{N-1}\} \)  we consider the homogeneous Dirichlet problem
where we solve for \( \hat{u} = u - B \). The homogeneous Dirichlet problem reads
$$
\begin{align}
- \epsilon \hat{u}_{xx} + \hat{u}_x &= 1, \quad \in  (0,1), 
\tag{196}\\ 
\tag{197}
\hat{u}(0) &= 0, \\ 
\nonumber
\hat{u}(1) &= 0 \tp
\nonumber
\end{align}
$$

<p>
The Galerkin formulation of <a href="#mjx-eqn-197">(197)</a> is obtained as
$$
\int_0^1
(- \epsilon \hat{u}'' + \hat{u}' - 1) \baspsi_j \dx \tp
$$

Integration by parts leads to
$$
\int_0^1
\epsilon \hat{u}' \baspsi_i' + \hat{u}' \baspsi_i - 1 \baspsi_i \dx \tp
$$

In other words, we need to solve the linear system \( \sum_j A_{i,j} c_j = b_i \) where

$$
\begin{align*}
A_{i,j} &= \int_0^1\epsilon \baspsi_j' \baspsi_i' + \baspsi_j' \baspsi_i \dx,\\ 
b_i &=\int_0^1 1 \baspsi_j \dx \tp
\end{align*}
$$

<p>
A sketch of a
corresponding code where we also plot the behavior of the solution
with respect to different \( \epsilon \) goes as follows.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import matplotlib.pyplot as plt
N = 8
psi = series(x, series_type, N)  # Lagrange, Bernstein, sin, ...
eps_values =[1.0, 0.1, 0.01, 0.001]
for eps in eps_valuess:
    A = sym.zeros((N-1), (N-1))
    b = sym.zeros((N-1))

    for i in range(0, N-1):
        integrand = f*psi[i]
        integrand = sym.lambdify([x], integrand)
        b[i,0] = sym.mpmath.quad(integrand, [Omega[0], Omega[1]])
        for j in range(0, N-1):
            integrand = eps*sym.diff(psi[i], x)*\ 
                 sym.diff(psi[j], x) - sym.diff(psi[i], x)*psi[j]
            integrand = sym.lambdify([x], integrand)
            A[i,j] = sym.mpmath.quad(integrand,
                                     [Omega[0], Omega[1]])

    c = A.LUsolve(b)
    u = sum(c[r,0]*psi[r] for r in range(N-1)) + x

    U = sym.lambdify([x], u, modules='numpy')
    x_ = numpy.arange(Omega[0], Omega[1], 1/((N+1)*100.0))
    U_ = U(x_)
    plt.plot(x_, U_)
</code></pre>
<!-- end verbatim block -->

<p>
<center> <!-- figure label: --> <div id="convdiff:osc:Lagrange8"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 63:  Solution obtained with Galerkin approximation using Lagrangian polynomials of order up to 8 for various \( \epsilon \).  <!-- caption label: convdiff:osc:Lagrange8 --> </p></center>
<p><img src="fig/Lagrange_convdiff_8.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure label: --> <div id="convdiff:osc:Lagrange16"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 64:  Solution obtained with Galerkin approximation using Lagrangian polynomials of order up to 16 for various \( \epsilon \).  <!-- caption label: convdiff:osc:Lagrange16 --> </p></center>
<p><img src="fig/Lagrange_convdiff_16.png" align="bottom" width=400></p>
</center>

<p>
The numerical solutions for different \( \epsilon \) is shown in Figure
<a href="#convdiff:osc:Lagrange8">63</a> and <a href="#convdiff:osc:Lagrange16">64</a> for \( N=8 \)
and \( N=16 \), respectively.  From these figures we can make two
observations. The first observation is that the numerical solution
contains non-physical oscillations that grows as \( \epsilon \)
decreases. These oscillations are so strong that for \( N=8 \), the
numerical solutions do not resemble the true solution at all for
\( \epsilon \) less than \( 1/10 \). The true solution is always in the
interval \( [0,1] \) while the numerical solution has values larger than 2
for \( \epsilon=1/100 \) and larger than 10 for \( \epsilon=1/1000 \).  The
second observation is that the numerical solutions appear to improve
as \( N \) increases. While the numerical solution is outside the interval
\( [0,1] \) for \( \epsilon \) less than \( 1/10 \) the magnitude of the
oscillations clearly has decreased.

<p>
We will return to this example later and show examples of
techniques that can be used to improve the approximation.
The complete source code can be found in
 <a href="http://tinyurl.com/znpudbt/conv_diff_global.py" target="_self"><tt>conv_diff_global.py</tt></a>.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fem-book-solarized017.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fem-book-solarized019.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

